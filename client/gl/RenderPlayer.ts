import { RenderContext } from "./RenderContext";
import { WebGLProgram, WebGLUniformLocation, WebGLBuffer, GLint } from "./WebGL";
import { consoleLog } from "../../netcode/netcode";
import { RenderColor } from "./RenderCommon";

const kInnerVS: string = `
    precision highp float;

    // Input from application:
    attribute vec2 a_position;
    uniform vec2 u_xy;
    uniform float u_scale;

    // Output to fragment shader:
    varying vec2 v_pos;

    void main() {
        vec2 p = a_position;
        v_pos = p;
        p = p * u_scale + u_xy;
        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);
    }
`;

const kInnerFS: string = `
    precision highp float;

    // Input from application:
    uniform vec3 u_color;
    uniform float u_shine_angle;
    uniform float u_shine_dist;

    // Input from vertex shader:
    varying vec2 v_pos;

    void main() {
        // Radius of circle is always 1, so dist2 = 1 on the border
        float alpha = (sin(atan(v_pos.y, v_pos.x) - u_shine_angle - 3.14159 * 0.5) + 1.0) * 0.5;

        gl_FragColor = vec4(mix(u_color, vec3(1.0, 1.0, 1.0), alpha*alpha * u_shine_dist), 1.0);
    }
`;

const kOuterVS: string = `
    precision highp float;

    // Input from application:
    attribute vec2 a_position;
    uniform vec2 u_xy;
    uniform float u_scale;

    // Output to fragment shader:
    varying vec2 v_pos;

    void main() {
        vec2 p = a_position;
        v_pos = p;
        p = p * u_scale + u_xy;
        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);
    }
`;

const kOuterFS: string = `
    precision highp float;

    // Input from application:
    uniform vec3 u_color;
    uniform float u_t;

    // Input from vertex shader:
    varying vec2 v_pos;

    void main() {
        // Radius of circle is always 1, so dist2 = 1 on the border
        float x = v_pos.x * v_pos.x + v_pos.y * v_pos.y;

        float y = (sin(u_t) + 1.0) * 0.05;

        float alpha = clamp(x * 0.8 - y, 0.0, 1.0);

        gl_FragColor = vec4(u_color, 1.0 - alpha);
    }
`;

// Data generated by RenderPlayerData and cached for each use
export class RenderPlayerData {
    vertices: StaticArray<f32>;

    inner_indices: StaticArray<u8>;
    outer_indices: StaticArray<u8>;

    // Inner radius is the corner vertices on the inside
    // Outer radius is the middle of the outer quads
    // 1.0 is always the radius of the circle of the player
    constructor(cells: i32, inner_radius_max: f32, outer_radius_min: f32) {
        if (cells < 5) {
            cells = 5;
        } else if (cells > 127) {
            // Limit to 8-bit indices
            cells = 127;
        }

        const base_angle: f32 = 2.0 * f32(Math.PI) / f32(cells);
        const outer_radius_max: f32 = outer_radius_min / f32(Math.cos(base_angle));

        this.vertices = new StaticArray<f32>(2 + 4 * cells);
        this.inner_indices = new StaticArray<u8>(3 * cells);
        this.outer_indices = new StaticArray<u8>(6 * cells);

        // index 0
        this.vertices[0] = 0.0;
        this.vertices[1] = 0.0;

        let iv: i32 = 2, ii: i32 = 0;
        let ov: i32 = 2 + 2 * cells, oi: i32 = 0;

        for (let i: i32 = 0; i < cells; ++i) {
            const angle: f32 = base_angle * f32(i);
            const cos_angle: f32 = f32(Math.cos(angle));
            const sin_angle: f32 = f32(Math.sin(angle));

            this.vertices[iv + 0] = inner_radius_max * cos_angle;
            this.vertices[iv + 1] = inner_radius_max * sin_angle;

            this.vertices[ov + 0] = outer_radius_max * cos_angle;
            this.vertices[ov + 1] = outer_radius_max * sin_angle;

            this.inner_indices[ii + 0] = 0;
            this.inner_indices[ii + 1] = u8(i + 1);
            if (i == cells - 1) {
                this.inner_indices[ii + 2] = 1;
                this.outer_indices[oi + 2] = 1;
                this.outer_indices[oi + 4] = u8(1 + cells);
                this.outer_indices[oi + 5] = 1;
            } else {
                this.inner_indices[ii + 2] = u8(i + 2);
                this.outer_indices[oi + 2] = u8(i + 2);
                this.outer_indices[oi + 4] = u8(2 + cells + i);
                this.outer_indices[oi + 5] = u8(i + 2);
            }

            this.outer_indices[oi + 0] = u8(i + 1);
            this.outer_indices[oi + 1] = u8(1 + cells + i);

            this.outer_indices[oi + 3] = u8(1 + cells + i);

            iv += 2;
            ii += 3;

            ov += 2;
            oi += 6;
        }
    }
}

// Render program shared between all players
export class RenderPlayerProgram {
    // Inner program
    inner_program: WebGLProgram;
    inner_a_position: GLint;
    inner_u_xy: WebGLUniformLocation;
    inner_u_scale: WebGLUniformLocation;
    inner_u_color: WebGLUniformLocation;
    inner_u_shine_angle: WebGLUniformLocation;
    inner_u_shine_dist: WebGLUniformLocation;

    // Outer program
    outer_program: WebGLProgram;
    outer_a_position: GLint;
    outer_u_xy: WebGLUniformLocation;
    outer_u_scale: WebGLUniformLocation;
    outer_u_color: WebGLUniformLocation;
    outer_u_t: WebGLUniformLocation;

    vertices_buffer: WebGLBuffer;
    inner_indices_buffer: WebGLBuffer;
    outer_indices_buffer: WebGLBuffer;

    data: RenderPlayerData;

    constructor() {
        const gl = RenderContext.I.gl;

        gl.getExtension('OES_standard_derivatives');
        gl.getExtension('OES_texture_float_linear');
        //gl.getExtension('OES_texture_border_clamp');

        const inner_vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(inner_vs, kInnerVS);
        gl.compileShader(inner_vs);

        const inner_fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(inner_fs, kInnerFS);
        gl.compileShader(inner_fs);

        this.inner_program = gl.createProgram();
        gl.attachShader(this.inner_program, inner_vs);
        gl.attachShader(this.inner_program, inner_fs);
        gl.linkProgram(this.inner_program);
        gl.useProgram(this.inner_program);

        this.inner_a_position = gl.getAttribLocation(this.inner_program, "a_position");
        this.inner_u_xy = gl.getUniformLocation(this.inner_program, "u_xy");
        this.inner_u_scale = gl.getUniformLocation(this.inner_program, "u_scale");
        this.inner_u_color = gl.getUniformLocation(this.inner_program, "u_color");
        this.inner_u_shine_angle = gl.getUniformLocation(this.inner_program, "u_shine_angle");
        this.inner_u_shine_dist = gl.getUniformLocation(this.inner_program, "u_shine_dist");

        const outer_vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(outer_vs, kOuterVS);
        gl.compileShader(outer_vs);

        const outer_fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(outer_fs, kOuterFS);
        gl.compileShader(outer_fs);

        this.outer_program = gl.createProgram();
        gl.attachShader(this.outer_program, outer_vs);
        gl.attachShader(this.outer_program, outer_fs);
        gl.linkProgram(this.outer_program);
        gl.useProgram(this.outer_program);

        this.outer_a_position = gl.getAttribLocation(this.outer_program, "a_position");
        this.outer_u_xy = gl.getUniformLocation(this.outer_program, "u_xy");
        this.outer_u_scale = gl.getUniformLocation(this.outer_program, "u_scale");
        this.outer_u_color = gl.getUniformLocation(this.outer_program, "u_color");
        this.outer_u_t = gl.getUniformLocation(this.outer_program, "u_t");

        this.vertices_buffer = gl.createBuffer();
        this.inner_indices_buffer = gl.createBuffer();
        this.outer_indices_buffer = gl.createBuffer();

        this.data = new RenderPlayerData(11, 0.9, 1.1);
    }

    public DrawPlayer(
        color: RenderColor,
        x: f32, y: f32,
        scale: f32,
        shine_angle: f32, shine_dist: f32,
        t: u64): void {
        const gl = RenderContext.I.gl;

        const data = this.data;


        gl.useProgram(this.inner_program);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);

        gl.enableVertexAttribArray(this.inner_a_position);

        // attribute | dimensions | data type | normalize | stride bytes | offset bytes
        gl.vertexAttribPointer(this.inner_a_position, 2, gl.FLOAT, +false, 8, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.inner_indices_buffer);

        gl.uniform3f(this.inner_u_color, color.r, color.g, color.b);

        gl.uniform2f(this.inner_u_xy, x, y);
        gl.uniform1f(this.inner_u_scale, scale);
        gl.uniform1f(this.inner_u_shine_angle, shine_angle);
        gl.uniform1f(this.inner_u_shine_dist, shine_dist);

        // Use DYNAMIC_DRAW because we want to change this for each line we render
        gl.bufferData<f32>(gl.ARRAY_BUFFER, data.vertices, gl.DYNAMIC_DRAW);
        gl.bufferData<u8>(gl.ELEMENT_ARRAY_BUFFER, data.inner_indices, gl.DYNAMIC_DRAW);

        gl.drawElements(gl.TRIANGLES, data.inner_indices.length, gl.UNSIGNED_BYTE, 0);


        gl.useProgram(this.outer_program);

        gl.enableVertexAttribArray(this.outer_a_position);

        // attribute | dimensions | data type | normalize | stride bytes | offset bytes
        gl.vertexAttribPointer(this.outer_a_position, 2, gl.FLOAT, +false, 8, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.outer_indices_buffer);

        //gl.uniform3f(this.outer_u_color, foreground_r, foreground_g, foreground_b);
        gl.uniform3f(this.outer_u_color, 0.0, 0.0, 0.0);

        gl.uniform2f(this.outer_u_xy, x, y);
        gl.uniform1f(this.outer_u_scale, scale);
        gl.uniform1f(this.outer_u_t, f32(t/4 % 1024) * 2.0 * f32(Math.PI) / 1024.0);

        // Use DYNAMIC_DRAW because we want to change this for each line we render
        gl.bufferData<u8>(gl.ELEMENT_ARRAY_BUFFER, data.outer_indices, gl.DYNAMIC_DRAW);

        gl.drawElements(gl.TRIANGLES, data.outer_indices.length, gl.UNSIGNED_BYTE, 0);
    }
}
