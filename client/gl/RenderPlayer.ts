import { RenderContext } from "./RenderContext";
import { ImageData, WebGLProgram, WebGLUniformLocation, WebGLBuffer, GLint, WebGLTexture } from "./WebGL";
import { JSON } from "assemblyscript-json";
import { consoleLog } from "../../netcode/netcode";

const kInnerVS: string = `
    precision highp float;

    // Input from application:
    attribute vec2 a_position;
    uniform vec2 u_xy;
    uniform float u_scale;

    void main() {
        vec2 p = a_position * u_scale + u_xy;
        // Normalized upper left (0,0) lower right (1,1)
        gl_Position = vec4((p.x - 0.5) * 2.0, (0.5 - p.y) * 2.0, 0.0, 1.0);
    }
`;

const kInnerFS: string = `
    precision highp float;

    // Input from application:
    uniform vec3 u_inner_color;

    void main() {
        gl_FragColor = vec4(u_inner_color, 1.0);
    }
`;

const kOuterVS: string = `
    precision highp float;

    // Input from application:
    attribute vec2 a_position;
    uniform vec2 u_xy;
    uniform float u_scale;

    // Output to fragment shader:
    varying vec2 fs_pos;

    void main() {
        fs_pos = a_position;
        vec2 p = a_position * u_scale + u_xy;
        // Normalized upper left (0,0) lower right (1,1)
        gl_Position = vec4((p.x - 0.5) * 2.0, (0.5 - p.y) * 2.0, 0.0, 1.0);
    }
`;

const kOuterFS: string = `
    precision highp float;

    // Input from application:
    uniform vec3 u_foreground_color;
    uniform vec3 u_background_color;

    // Input from vertex shader:
    varying vec2 fs_pos;

    void main() {
        // Radius of circle is always 1, so dist2 = 1 on the border
        float dist2 = fs_pos.x * fs_pos.x + fs_pos.y * fs_pos.y;

        float beta = (dist2 - 0.5) * 16.0 + 0.5;

        float alpha = clamp(beta, 0.0, 1.0);

        gl_FragColor = vec4(mix(u_background_color, u_foreground_color, alpha), 1.0);
    }
`;

// Data generated by RenderPlayerData and cached for each use
export class RenderPlayerData {
    vertices: StaticArray<f32>;

    inner_indices: StaticArray<u8>;
    outer_indices: StaticArray<u8>;

    // Inner radius is the corner vertices on the inside
    // Outer radius is the middle of the outer quads
    // 1.0 is always the radius of the circle of the player
    constructor(cells: i32, inner_radius_max: f32, outer_radius_min: f32) {
        if (cells < 5) {
            cells = 5;
        } else if (cells > 127) {
            // Limit to 8-bit indices
            cells = 127;
        }

        const base_angle: f32 = 2.0 * Math.PI / f32(cells);
        const outer_radius_max: f32 = outer_radius_min / Math.cos(base_angle);

        this.vertices = new StaticArray<f32>(2 + 4 * cells);
        this.inner_indices = new StaticArray<u8>(3 * cells);
        this.outer_indices = new StaticArray<u8>(6 * cells);

        // index 0
        this.vertices[0] = 0.0;
        this.vertices[1] = 0.0;

        let iv: i32 = 2, ii: i32 = 1;
        let ov: i32 = 2 + 2 * cells, oi: i32 = (1 + cells) * 3;

        for (let i: i32 = 0; i < cells; ++i) {
            const angle: f32 = base_angle * f32(i);
            const cos_angle: f32 = Math.cos(angle);
            const sin_angle: f32 = Math.sin(angle);

            this.vertices[iv + 0] = inner_radius_max * cos_angle;
            this.vertices[iv + 1] = inner_radius_max * sin_angle;

            this.vertices[ov + 0] = outer_radius_max * cos_angle;
            this.vertices[ov + 1] = outer_radius_max * sin_angle;

            this.inner_indices[ii + 0] = 0;
            this.inner_indices[ii + 1] = i + 1;
            if (i == cells - 1) {
                this.inner_indices[ii + 2] = 1;
                this.outer_indices[oi + 2] = 1;
                this.outer_indices[oi + 4] = 1 + cells;
                this.outer_indices[oi + 5] = 1;
            } else {
                this.inner_indices[ii + 2] = i + 2;
                this.outer_indices[oi + 2] = i + 2;
                this.outer_indices[oi + 4] = 2 + cells + i;
                this.outer_indices[oi + 5] = i + 2;
            }

            this.outer_indices[oi + 0] = i + 1;
            this.outer_indices[oi + 1] = 1 + cells + i;

            this.outer_indices[oi + 3] = 1 + cells + i;

            iv += 2;
            ii += 3;

            ov += 2;
            oi += 6;
        }
    }
}

// Render program shared between all texts
export class RenderPlayerProgram {
    // Inner program
    inner_program: WebGLProgram;
    inner_a_position: GLint;
    inner_u_xy: WebGLUniformLocation;
    inner_u_scale: WebGLUniformLocation;
    inner_u_inner_color: WebGLUniformLocation;

    // Outer program
    outer_program: WebGLProgram;
    outer_a_position: GLint;
    outer_u_xy: WebGLUniformLocation;
    outer_u_scale: WebGLUniformLocation;
    outer_u_foreground_color: WebGLUniformLocation;
    outer_u_background_color: WebGLUniformLocation;

    vertices_buffer: WebGLBuffer;
    inner_indices_buffer: WebGLBuffer;
    outer_indices_buffer: WebGLBuffer;

    constructor(texture_image_location: string) {
        const gl = RenderContext.I.gl;

        gl.getExtension('OES_standard_derivatives');
        gl.getExtension('OES_texture_float_linear');
        //gl.getExtension('OES_texture_border_clamp');

        const inner_vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(inner_vs, kInnerVS);
        gl.compileShader(inner_vs);

        const inner_fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(inner_fs, kInnerFS);
        gl.compileShader(inner_fs);

        this.inner_program = gl.createProgram();
        gl.attachShader(this.inner_program, inner_vs);
        gl.attachShader(this.inner_program, inner_fs);
        gl.linkProgram(this.inner_program);
        gl.useProgram(this.inner_program);

        const outer_vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(outer_vs, kOuterVS);
        gl.compileShader(outer_vs);

        const outer_fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(outer_fs, kOuterFS);
        gl.compileShader(outer_fs);

        this.outer_program = gl.createProgram();
        gl.attachShader(this.outer_program, outer_vs);
        gl.attachShader(this.outer_program, outer_fs);
        gl.linkProgram(this.outer_program);
        gl.useProgram(this.outer_program);

        this.inner_a_position = gl.getAttribLocation(this.inner_program, "a_position");
        this.inner_u_xy = gl.getUniformLocation(this.inner_program, "u_xy");
        this.inner_u_scale = gl.getUniformLocation(this.inner_program, "u_scale");
        this.inner_u_inner_color = gl.getUniformLocation(this.inner_program, "u_inner_color");

        this.outer_a_position = gl.getAttribLocation(this.outer_program, "a_position");
        this.outer_u_xy = gl.getUniformLocation(this.outer_program, "u_xy");
        this.outer_u_scale = gl.getUniformLocation(this.outer_program, "u_scale");
        this.outer_u_foreground_color = gl.getUniformLocation(this.outer_program, "u_foreground_color");
        this.outer_u_background_color = gl.getUniformLocation(this.outer_program, "u_background_color");

        this.vertices_buffer = gl.createBuffer();
        this.inner_indices_buffer = gl.createBuffer();
        this.outer_indices_buffer = gl.createBuffer();
    }

    public Render(
        foreground_r: f32, foreground_g: f32, foreground_b: f32,
        background_r: f32, background_g: f32, background_b: f32,
        x: f32, y: f32,
        scale: f32,
        data: RenderPlayerData): void {
        const gl = RenderContext.I.gl;

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);


        gl.useProgram(this.inner_program);

        gl.enableVertexAttribArray(this.inner_a_position);

        // attribute | dimensions | data type | normalize | stride bytes | offset bytes
        gl.vertexAttribPointer(this.inner_a_position, 2, gl.FLOAT, +false, 8, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.inner_indices_buffer);

        gl.uniform3f(this.inner_u_inner_color, foreground_r, foreground_g, foreground_b);

        gl.uniform2f(this.inner_u_xy, x, y);
        gl.uniform1f(this.inner_u_scale, scale);

        // Use DYNAMIC_DRAW because we want to change this for each line we render
        gl.bufferData<f32>(gl.ARRAY_BUFFER, data.vertices, gl.DYNAMIC_DRAW);
        gl.bufferData<u8>(gl.ELEMENT_ARRAY_BUFFER, data.inner_indices, gl.DYNAMIC_DRAW);

        gl.drawElements(gl.TRIANGLES, data.inner_indices.length, gl.UNSIGNED_SHORT, 0);


        gl.useProgram(this.outer_program);

        gl.enableVertexAttribArray(this.outer_a_position);

        // attribute | dimensions | data type | normalize | stride bytes | offset bytes
        gl.vertexAttribPointer(this.outer_a_position, 2, gl.FLOAT, +false, 8, 0);

        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.outer_indices_buffer);

        gl.uniform3f(this.outer_u_foreground_color, foreground_r, foreground_g, foreground_b);
        gl.uniform3f(this.outer_u_background_color, background_r, background_g, background_b);

        gl.uniform2f(this.outer_u_xy, x, y);
        gl.uniform1f(this.outer_u_scale, scale);

        // Use DYNAMIC_DRAW because we want to change this for each line we render
        gl.bufferData<u8>(gl.ELEMENT_ARRAY_BUFFER, data.inner_indices, gl.DYNAMIC_DRAW);

        gl.drawElements(gl.TRIANGLES, data.inner_indices.length, gl.UNSIGNED_SHORT, 0);
    }
}
