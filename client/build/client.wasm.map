{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/rt/tcms.ts","client/gl/WebGL.ts","netcode/netcode.ts","~lib/util/math.ts","~lib/math.ts","client/gl/RenderText.ts","node_modules/as-3d-math/src/as/math/MathUtils.ts","~lib/util/error.ts","node_modules/as-3d-math/src/as/math/Matrix4.ts","~lib/shared/typeinfo.ts","~lib/rt.ts","~lib/memory.ts","~lib/util/memory.ts","node_modules/as-3d-math/src/as/math/Euler.ts","node_modules/as-3d-math/src/as/math/Quaternion.ts","node_modules/as-3d-math/src/as/math/Vector4.ts","node_modules/as-3d-math/src/as/math/Color.ts","node_modules/as-3d-math/src/as/math/Vector3.ts","~lib/util/number.ts","~lib/util/string.ts","~lib/string.ts","node_modules/as-3d-math/src/as/math/Box3.ts","~lib/array.ts","~lib/number.ts","node_modules/as-3d-math/src/as/math/Sphere.ts","node_modules/as-3d-math/src/as/core/Object3D.ts","node_modules/as-3d-math/src/as/math/Frustum.ts","node_modules/as-3d-math/src/as/math/Ray.ts","client/gl/RenderPlayer.ts","client/gl/RenderString.ts","client/gl/RenderBomb.ts","client/gl/RenderBullet.ts","client/gl/RenderMap.ts","client/gl/RenderArrow.ts","client/gl/RenderSun.ts","client/client.ts","client/gl/RenderCommon.ts","~lib/arraybuffer.ts","~lib/util/hash.ts","~lib/map.ts","~lib/typedarray.ts","~lib/util/sort.ts","~lib/builtins.ts","~lib/staticarray.ts","client/gl/RenderContext.ts","~lib/function.ts"],"names":[],"mappings":"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AAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,EAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,EAAI,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,EAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,EAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,EAAG,EAAI,EAAI,EAAI,EAAG,EAAI,SACtD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAI,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAI,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAI,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAG,SACvD,KAAiB,GAAI,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAI,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAI,EAAW,EAAG,GAAI,EAAI,EAAI,EAAG,EAAI,SACtD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACzD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,EAAI,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAI,GAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAI,SACzD,KAAiB,GAAK,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACzD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAI,SACzD,KAAiB,GAAK,EAAW,EAAI,GAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,EAAI,EAAI,EAAI,EAAG,EAAI,SACzD,KAAiB,GAAK,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAI,SACzD,KAAiB,GAAK,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAI,SACzD,KAAiB,GAAK,EAAW,EAAI,GAAI,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAI,SACzD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAG,EAAI,SACxD,KAAiB,GAAK,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAI,SACzD,KAAiB,GAAK,EAAW,EAAI,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAK,EAAW,GAAK,EAAG,EAAI,EAAI,EAAI,EAAI,SACzD,KAAiB,GAAK,EAAW,GAAI,EAAG,EAAI,EAAI,EAAG,EAAI,SACvD,KAAiB,GAAK,EAAW,GAAK,GAAI,EAAI,EAAI,EAAG,EAAI,gKkClLhC,EAAgB,EAAmB,WACvC,EAAmB,QAGf,EAAgB,EAAmB,EAVlE,YAW+B,OACF,OACD,0DlCyCJ,4BAKM,8GAiIxB,AAAW,gCAEX,MAAgB,gBAChB,MAAgB,MJw6DhB,AAAa,KAAY,KIr6DzB,KAEA,EAAa,MAAe,IJwpB5B,AAAmB,QIvpBnB,EAAe,MJ4gEf,AAAqB,WI1gErB,AAAsB,MAAgB,MJ0xCtC,kBIzxCA,MAAgB,IAAe,iBAC/B,MAAiB,cAKjB,AAAwB,MAAgB,MJ+wCxC,MAgvBA,AAAoB,KAAY,OI9/DhC,MAAgB,IAAiB,KJktEjC,AAAa,KAAY,EAAQ,KIjtEjC,MAAiB,IJ69DjB,AAAc,KAAY,KIx9D1B,EAAsB,MJk/DtB,AAAqB,WIj/DrB,MAAgB,OAAqB,gBACrC,MAAgB,OAAqB,IJ45DrC,AAAa,KAAY,EAAS,KI35DlC,MAAe,OJgrEf,AAAY,KAAY,KI/qExB,MAAc,OJqzEd,AAAW,KAAY,KInzEvB,EAAkB,MAAqB,OAAqB,qBAC5D,EAAkB,MAAqB,OAAqB,MJklE5D,AAAyB,KAAY,EAAS,QIhlE9C,EAAY,MAAsB,OAAqB,qBACvD,EAAe,MAAsB,OAAqB,qBAE1D,EAA0B,MAAsB,OAAqB,qBACrE,EAAsB,MAAsB,OAAqB,qBACjE,EAAiB,MAAsB,OAAqB,MJ6nE5D,AAA0B,KAAY,EAAS,QI3nE/C,EAAuB,iBACvB,EAAsB,MJy9DtB,AAAoB,oM0C7pExB,AAAI,EAAc,MAAuB,MAAc,EAAqB,mBAC5E,AAAc,EAAiB,KAC/B,AAAU,AAAiC,EAAS,MACpD,AAAY,EAAwB,EAAG,KACvC,yCAIA,AAAO,AAAmB,EAA0B,MAA2B,MAqC/E,AAAS,EAA2B,EAAgB,IAAe,KACnE,AAAI,MANJ,AAAI,EAAc,AAAK,QAAa,EAAqB,mBACzD,EAAY,EAAO,mDfjCf,AAAI,EAAQ,KACR,AAAQ,KACL,AAAI,EAAQ,MAEf,AAAQ,OAGZ,AAAwB,KAAM,IAAW,MACzC,AAA8B,EAAmB,AAAU,QAE3D,EAAgB,EAAqB,EAAI,EAAI,UAC7C,EAAqB,EAAoB,EAAI,SAC7C,EAAqB,EAAoB,EAAI,SAG7C,KAAc,EAAK,QACnB,KAAc,EAAK,QAEL,IAAa,IACb,EAAI,EAAI,MAAiB,IAElC,AAAa,QAAG,EAAI,WACrB,AAAmB,EAAa,MAChC,AAAuB,AAAU,OACjC,AAAuB,AAAU,OAEjC,KAAc,EAAK,GAAK,EAAmB,MAC3C,KAAc,EAAK,GAAK,EAAmB,MAE3C,KAAc,EAAK,GAAK,EAAmB,MAC3C,KAAc,EAAK,GAAK,EAAmB,MAE3C,KAAmB,EAAK,GAAK,KAC7B,KAAmB,EAAK,GAAK,AAAG,EAAI,MACpC,AAAI,EAAK,EAAQ,MACb,KAAmB,EAAK,GAAK,KAC7B,KAAmB,EAAK,GAAK,KAC7B,KAAmB,EAAK,GAAK,AAAG,EAAI,MACpC,KAAmB,EAAK,GAAK,MAE7B,KAAmB,EAAK,GAAK,AAAG,EAAI,MACpC,KAAmB,EAAK,GAAK,AAAG,EAAI,MACpC,KAAmB,EAAK,GAAK,AAAG,EAAI,GAAQ,MAC5C,KAAmB,EAAK,GAAK,AAAG,EAAI,OAGxC,KAAmB,EAAK,GAAK,AAAG,EAAI,MACpC,KAAmB,EAAK,GAAK,AAAG,EAAI,GAAQ,MAE5C,KAAmB,EAAK,GAAK,AAAG,EAAI,GAAQ,MAE5C,EAAM,KACN,EAAM,KAEN,EAAM,KACN,EAAM,MAlCsB,AAAE,+KAiElC,AAAW,gCAEX,MAAgB,gBAChB,MAAgB,M3Bo+DhB,AAAa,KAAY,K2Bj+DzB,AAAiB,MAAgB,wBACjC,MAAgB,IAAU,iBAC1B,MAAiB,cAEjB,AAAiB,MAAgB,wBACjC,MAAgB,IAAU,iBAC1B,MAAiB,cAEjB,EAAqB,iBACrB,MAAgB,OAAoB,gBACpC,MAAgB,OAAoB,gBACpC,MAAe,iBACf,MAAc,iBAEd,EAAwB,MAAqB,OAAoB,qBACjE,EAAkB,MAAsB,OAAoB,qBAC5D,EAAqB,MAAsB,OAAoB,qBAC/D,EAAqB,MAAsB,OAAoB,qBAC/D,EAA2B,MAAsB,OAAoB,qBACrE,EAA0B,MAAsB,OAAoB,qBAEpE,AAAiB,MAAgB,M3Bs0CjC,kB2Br0CA,MAAgB,IAAU,iBAC1B,MAAiB,cAEjB,AAAiB,MAAgB,M3B8zCjC,MAgvBA,AAAoB,KAAY,O2B7iEhC,MAAgB,IAAU,K3BiwE1B,AAAa,KAAY,EAAQ,K2BhwEjC,MAAiB,I3B4gEjB,AAAc,KAAY,K2B1gE1B,EAAqB,M3BoiErB,AAAqB,W2BniErB,MAAgB,OAAoB,gBACpC,MAAgB,OAAoB,I3B88DpC,AAAa,KAAY,EAAS,K2B78DlC,MAAe,O3BkuEf,AAAY,KAAY,K2BjuExB,MAAc,O3Bu2Ed,AAAW,KAAY,K2Br2EvB,EAAwB,MAAqB,OAAoB,M3BqoEjE,AAAyB,KAAY,EAAS,Q2BpoE9C,EAAkB,MAAsB,OAAoB,qBAC5D,EAAqB,MAAsB,OAAoB,qBAC/D,EAAqB,MAAsB,OAAoB,qBAC/D,EAAiB,MAAsB,OAAoB,M3BmrE3D,AAA0B,KAAY,EAAS,Q2BjrE/C,EAAuB,iBACvB,EAA4B,iBAC5B,EAA4B,M3B8gE5B,AAAoB,W2B5gEpB,EAAY,EAAqB,EAAI,KAAK,6JC1LrB,EAAqB,SAG1C,AAAW,+BAEX,MAAgB,gBAChB,MAAgB,M5BwmEhB,AAAa,KAAY,K4BrmEzB,AAAW,MAAgB,M5B+9C3B,kB4B99CA,MAAgB,IAAI,iBACpB,MAAiB,cAEjB,AAAW,MAAgB,M5Bu9C3B,MAgvBA,AAAoB,KAAY,O4BtsEhC,MAAgB,IAAI,K5B05EpB,AAAa,KAAY,EAAQ,K4Bz5EjC,MAAiB,I5BqqEjB,AAAc,KAAY,K4BnqE1B,EAAe,M5B6rEf,AAAqB,W4B5rErB,MAAgB,OAAc,gBAC9B,MAAgB,OAAc,I5BumE9B,AAAa,KAAY,EAAS,K4BtmElC,MAAe,O5B23Ef,AAAY,KAAY,K4B13ExB,MAAc,O5BggFd,AAAW,KAAY,K4B9/EvB,EAAkB,MAAqB,OAAc,M5B8xErD,AAAyB,KAAY,EAAS,Q4B7xE9C,EAAe,MAAsB,OAAc,qBACnD,EAAW,MAAsB,OAAc,M5B80E/C,AAA0B,KAAY,EAAS,Q4B50E/C,EAAuB,M5B2qEvB,AAAoB,6L6BxqEpB,AAAW,gCAEX,AAAW,MAAgB,M7Bw8C3B,kB6Bv8CA,MAAgB,IAAI,iBACpB,MAAiB,cAEjB,AAAW,MAAgB,M7Bg8C3B,MAgvBA,AAAoB,KAAY,O6B/qEhC,MAAgB,IAAI,K7Bm4EpB,AAAa,KAAY,EAAQ,K6Bl4EjC,MAAiB,I7B8oEjB,AAAc,KAAY,K6B5oE1B,EAAe,M7BsqEf,AAAqB,W6BrqErB,MAAgB,OAAc,gBAC9B,MAAgB,OAAc,I7BglE9B,AAAa,KAAY,EAAS,K6B/kElC,MAAe,O7Bo2Ef,AAAY,KAAY,K6Bn2ExB,MAAc,O7By+Ed,AAAW,KAAY,K6Bv+EvB,EAAkB,MAAqB,OAAc,M7BuwErD,AAAyB,KAAY,EAAS,Q6BtwE9C,EAAY,MAAsB,OAAc,qBAChD,EAAe,MAAsB,OAAc,qBACnD,EAAe,MAAsB,OAAc,qBACnD,EAAe,MAAsB,OAAc,qBACnD,EAAW,MAAsB,OAAc,M7BozE/C,AAA0B,KAAY,EAAS,Q6BlzE/C,EAAuB,iBACvB,EAAsB,M7BgpEtB,AAAoB,W6B9oEpB,AAAoC,EAAqB,OACzD,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QAEjB,AAAkC,EAAoB,OACtD,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAEhB,MAAc,WAAiB,mBAC/B,MAAmB,M7ByhCnB,K6BzhCoC,IAAa,yBAEjD,MAAc,WAAyB,O7BkjEvC,AAAW,KAAY,EAAQ,K6BjjE/B,MAAkB,M7B0hClB,K6B1hC2C,IAAY,M7B0iCvD,KAkiCA,AAAc,KAAY,EAAQ,EAAM,uL8B9nExC,AAAW,gCAEX,AAAW,MAAgB,M9B08C3B,kB8Bz8CA,MAAgB,IAAI,iBACpB,MAAiB,cAEjB,AAAW,MAAgB,M9Bk8C3B,MAgvBA,AAAoB,KAAY,O8BjrEhC,MAAgB,IAAI,K9Bq4EpB,AAAa,KAAY,EAAQ,K8Bp4EjC,MAAiB,I9BgpEjB,AAAc,KAAY,K8B9oE1B,EAAe,M9BwqEf,AAAqB,W8BvqErB,MAAgB,OAAc,gBAC9B,MAAgB,OAAc,I9BklE9B,AAAa,KAAY,EAAS,K8BjlElC,MAAe,O9Bs2Ef,AAAY,KAAY,K8Br2ExB,MAAc,O9B2+Ed,AAAW,KAAY,K8Bz+EvB,EAAkB,MAAqB,OAAc,M9BywErD,AAAyB,KAAY,EAAS,Q8BxwE9C,EAAY,MAAsB,OAAc,qBAChD,EAAe,MAAsB,OAAc,qBACnD,EAAe,MAAsB,OAAc,qBACnD,EAAe,MAAsB,OAAc,qBACnD,EAAW,MAAsB,OAAc,M9BszE/C,AAA0B,KAAY,EAAS,Q8BpzE/C,EAAuB,iBACvB,EAAsB,M9BkpEtB,AAAoB,W8BhpEpB,AAAoC,EAAqB,OACzD,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QAEjB,AAAkC,EAAoB,OACtD,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAEhB,MAAc,WAAiB,mBAC/B,MAAmB,M9B2hCnB,K8B3hCoC,IAAa,yBAEjD,MAAc,WAAyB,O9BojEvC,AAAW,KAAY,EAAQ,K8BnjE/B,MAAkB,M9B4hClB,K8B5hC2C,IAAY,M9B4iCvD,KAkiCA,AAAc,KAAY,EAAQ,EAAM,qJ+B9iExC,AAAW,gCAEX,MAAgB,gBAChB,MAAgB,M/B+/DhB,AAAa,KAAY,K+B5/DzB,AAAsB,MAAgB,M/Bs3CtC,kB+Br3CA,MAAgB,IAAe,iBAC/B,MAAiB,cAEjB,AAAwB,MAAgB,M/B82CxC,MAgvBA,AAAoB,KAAY,O+B7lEhC,MAAgB,IAAiB,K/BizEjC,AAAa,KAAY,EAAQ,K+BhzEjC,MAAiB,I/B4jEjB,AAAc,KAAY,K+B1jE1B,EAAsB,M/BolEtB,AAAqB,W+BnlErB,MAAgB,OAAqB,gBACrC,MAAgB,OAAqB,I/B8/DrC,AAAa,KAAY,EAAS,K+B7/DlC,MAAe,O/BkxEf,AAAY,KAAY,K+BjxExB,MAAc,O/Bu5Ed,AAAW,KAAY,K+Br5EvB,EAAkB,MAAqB,OAAqB,M/BqrE5D,AAAyB,KAAY,EAAS,Q+BnrE9C,EAAY,MAAsB,OAAqB,qBACvD,EAAe,MAAsB,OAAqB,qBAC1D,EAAW,MAAsB,OAAqB,M/BmuEtD,AAA0B,KAAY,EAAS,Q+BjuE/C,EAAuB,iBACvB,EAAsB,M/B+jEtB,AAAoB,W+B7jEpB,AAAoC,EAAqB,OACzD,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QAEjB,AAAkC,EAAoB,OACtD,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAEhB,MAAc,WAAiB,mBAC/B,MAAmB,M/Bw8BnB,K+Bx8BoC,IAAa,yBAEjD,MAAc,WAAyB,O/Bi+DvC,AAAW,KAAY,EAAQ,K+Bh+D/B,MAAkB,M/By8BlB,K+Bz8B2C,IAAY,M/By9BvD,KAkiCA,AAAc,KAAY,EAAQ,EAAM,sKgChpExC,AAAW,+BAEX,AAAW,MAAgB,MhC49C3B,kBgC39CA,MAAgB,IAAI,iBACpB,MAAiB,cAEjB,AAAW,MAAgB,MhCo9C3B,MAgvBA,AAAoB,KAAY,OgCnsEhC,MAAgB,IAAI,KhCu5EpB,AAAa,KAAY,EAAQ,KgCt5EjC,MAAiB,IhCkqEjB,AAAc,KAAY,KgChqE1B,EAAe,MhC0rEf,AAAqB,WgCzrErB,MAAgB,OAAc,gBAC9B,MAAgB,OAAc,IhComE9B,AAAa,KAAY,EAAS,KgCnmElC,MAAe,OhCw3Ef,AAAY,KAAY,KgCv3ExB,MAAc,OhC6/Ed,AAAW,KAAY,KgC3/EvB,EAAkB,MAAqB,OAAc,MhC2xErD,AAAyB,KAAY,EAAS,QgC1xE9C,EAAY,MAAsB,OAAc,qBAChD,EAAe,MAAsB,OAAc,qBACnD,EAAe,MAAsB,OAAc,qBACnD,EAAe,MAAsB,OAAc,qBACnD,EAAW,MAAsB,OAAc,MhCw0E/C,AAA0B,KAAY,EAAS,QgCt0E/C,EAAuB,MhCqqEvB,AAAoB,WgCnqEpB,AAAoC,EAAqB,OACzD,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QAEjB,MAAc,WAAiB,OhColE/B,AAAW,KAAY,EAAQ,KgCnlE/B,MAAmB,MhCwjCnB,KgCxjCoC,IAAa,MhC4kCjD,KAkiCA,AAAc,KAAY,EAAQ,EAAM,qJiCnoExC,AAAW,gCAEX,AAAW,MAAgB,MjC+8C3B,kBiC98CA,MAAgB,IAAI,iBACpB,MAAiB,cAEjB,AAAW,MAAgB,MjCu8C3B,MAgvBA,AAAoB,KAAY,OiCtrEhC,MAAgB,IAAI,KjC04EpB,AAAa,KAAY,EAAQ,KiCz4EjC,MAAiB,IjCqpEjB,AAAc,KAAY,KiCnpE1B,EAAe,MjC6qEf,AAAqB,WiC5qErB,MAAgB,OAAc,gBAC9B,MAAgB,OAAc,IjCulE9B,AAAa,KAAY,EAAS,KiCtlElC,MAAe,OjC22Ef,AAAY,KAAY,KiC12ExB,MAAc,OjCg/Ed,AAAW,KAAY,KiC9+EvB,EAAkB,MAAqB,OAAc,MjC8wErD,AAAyB,KAAY,EAAS,QiC7wE9C,EAAY,MAAsB,OAAc,qBAChD,EAAe,MAAsB,OAAc,qBACnD,EAAW,MAAsB,OAAc,MjC6zE/C,AAA0B,KAAY,EAAS,QiC3zE/C,EAAuB,iBACvB,EAAsB,MjCypEtB,AAAoB,WiCvpEpB,AAAoC,EAAqB,OACzD,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QACjB,EAAY,EAAK,QAEjB,AAAkC,EAAoB,OACtD,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAChB,EAAW,EAAK,KAEhB,MAAc,WAAiB,mBAC/B,MAAmB,MjCkiCnB,KiCliCoC,IAAa,yBAEjD,MAAc,WAAyB,OjC2jEvC,AAAW,KAAY,EAAQ,KiC1jE/B,MAAkB,MjCmiClB,KiCniC2C,IAAY,MjCmjCvD,KAkiCA,AAAc,KAAY,EAAQ,EAAM,UkC9tD5C,MAEA,AAAgB,EAAsB,UACtC,AAAc,QACd,AAAc,QACd,AAAY,QACZ,AAAc,QACd,AAAW,QACX,AAAa,QACb,AAAW,aSzdP,AAAI,EAAY,QAAU,EAAY,YAClC,EAEJ,EAAS,KACT,EAAS,KAET,OAAY,IAAG,IAAG,IAAU,I3C6kF5B,AAAS,KAAY,EAAG,EAAG,EAAO,QkCtkEtC,EAAK,QACL,AAAO,AAAI,GAAM,KAAK,AAAI,GAAM,0Gb/ehC,AAAI,EAAc,MAAuB,MAAc,EAAqB,kBAC5E,AAAiB,EAAiB,KAClC,AAAa,AAA8B,EAAY,MACvD,AAAY,EAA2B,EAAG,KAC1C,EAAc,KACd,EAAiB,KACjB,EAAkB,KAClB,EAAe,UAmDf,AAAS,KAAkB,EAAgB,IAAe,KACtD,GAAgB,AACX,EAAyB,EAA0B,OAX5D,AAAI,EAAc,AAAK,QACrB,AAAI,EAAQ,KAAG,EAAqB,mBACpC,AAAW,EAAyB,EAAQ,GAAG,KAC/C,EAAe,EAAQ,OAEzB,EAAY,EAAO,QAvCnB,AAAW,EAAyB,EAAW,KAC/C,EAAe,UiB2If,AAAY,AAAkB,OAC9B,AAAW,OACX,AAAa,EAAa,OAC1B,AAAa,IACR,AAAQ,QAAG,EAAI,WAClB,AAAY,AAA0B,EAAQ,EAAW,EApK7D,OAqKI,AAAI,AAAE,KAAmB,MACvB,EAAO,cAAY,UAHG,AAAE,YAM5B,EAAgB,KAChB,KjB3JA,AAAO,UAuBP,AAAI,EAAc,AAAK,QAAc,EAAqB,mBAC1D,AAAY,AAAQ,KAAkB,EAAgB,SAClD,GAAkB,EAChB,AAAC,IAAiB,AAChB,AAAC,KAA0B,EAAgB,oBAGnD,Ua2qBA,AAAc,KAAY,QAC1B,AAAc,KAAY,QAE1B,AAAS,KAAY,EAAK,MAC1B,AAAS,KAAY,EAAK,MAE1B,AAAgB,EAAc,EAAK,GAAK,EAAK,O/B6sB7C,AAAyB,O+B5sBzB,AAAU,IAEV,AAAI,EAAO,QAIP,AAAI,EAAM,QACN,EAAO,SAEP,AAAM,QAIV,AAAI,EAAM,QACN,AAAM,QAGV,EAAO,KACP,EAAM,KACN,EAAM,KAEN,EAAY,KACZ,EAAY,KAEZ,OAAY,EAAK,OACjB,OAAY,EAAK,OAEjB,AAAI,KAAY,MACZ,OAAY,QACT,AAAI,KAAW,QAClB,OAAY,SAEhB,AAAI,KAAY,MACZ,OAAY,QACT,AAAI,KAAW,QAClB,OAAY,kBA/FpB,AAAc,KAAY,QAC1B,AAAc,KAAY,QAE1B,AAAS,KAAmB,EAAK,MACjC,AAAS,KAAmB,EAAK,MAEjC,AAAgB,EAAc,EAAK,GAAK,EAAK,O/BkwB7C,AAAyB,O+BjwBzB,AAAU,IAEV,AAAI,EAAO,QAIP,AAAI,EAAM,QACN,EAAO,SAEP,AAAM,QAIV,AAAI,EAAM,QACN,AAAM,QAGV,EAAO,KACP,EAAM,KACN,EAAM,KAEN,EAAmB,KACnB,EAAmB,KAEnB,OAAmB,EAAK,OACxB,OAAmB,EAAK,OAExB,AAAI,KAAmB,MACnB,OAAmB,QAChB,AAAI,KAAkB,QACzB,OAAmB,SAEvB,AAAI,KAAmB,MACnB,OAAmB,QAChB,AAAI,KAAkB,QACzB,OAAmB,ab9rB3B,AAAO,UAuBP,AAAI,EAAc,AAAK,QAAc,EAAqB,mBAC1D,AAAY,AAAQ,KAAkB,EAAgB,SAClD,GAAkB,EAChB,AAAC,IAAiB,AAChB,AAAC,KAA0B,EAAgB,oBAGnD,yBAiBA,AAAS,KAAkB,EAAgB,IAAe,KACtD,GAAgB,AACX,EAAyB,EAA0B,OAX5D,AAAI,EAAc,AAAK,QACrB,AAAI,EAAQ,KAAG,EAAqB,mBACpC,AAAW,EAAyB,EAAQ,GAAG,KAC/C,EAAe,EAAQ,OAEzB,EAAY,EAAO,QAvCnB,AAAW,EAAyB,EAAW,KAC/C,EAAe,QALf,AAAO,UAuBP,AAAI,EAAc,AAAK,QAAc,EAAqB,mBAC1D,AAAY,AAAQ,KAAkB,EAAgB,SAClD,GAAkB,EAChB,AAAC,IAAiB,AAChB,AAAC,KAA0B,EAAgB,oBAGnD,yBAiBA,AAAS,KAAkB,EAAgB,IAAe,KACtD,GAAgB,AACX,EAAyB,EAA0B,OAX5D,AAAI,EAAc,AAAK,QACrB,AAAI,EAAQ,KAAG,EAAqB,mBACpC,AAAW,EAAyB,EAAQ,GAAG,KAC/C,EAAe,EAAQ,OAEzB,EAAY,EAAO,QAvCnB,AAAW,EAAyB,EAAW,KAC/C,EAAe,WaovBf,AAAsB,QAEjB,AAAa,QAAG,EAAI,WACrB,AAAe,GAAY,OAE3B,AAAwB,EAAQ,EAAI,KAEpC,AAAI,OACA,GAEJ,AAAyB,EAAQ,EAAI,KAErC,EAAW,QACX,EAAW,QACX,EAAY,QACZ,EAAY,SAbwB,AAAE,YAgBrC,AAAa,QAAG,EAAI,eACrB,AAAa,GAAS,OAEtB,OAAU,KAAU,OACpB,OAAU,KAAU,OAEpB,AAAI,KAAU,MACV,OAAU,QACP,AAAI,KAAS,QAChB,OAAU,SAEd,AAAI,KAAU,MACV,OAAU,QACP,AAAI,KAAS,QAChB,OAAU,SAGd,AAAI,AAAI,EAAI,OAAU,IAAS,MAC3B,GAAS,EAAK,GAAS,MAAkB,SACzC,eACA,AAAE,SApBgC,AAAE,YAwBvC,AAAa,QAAG,EAAI,eACrB,AAAe,GAAW,OAE1B,OAAY,KAAY,OACxB,OAAY,KAAY,OAExB,AAAI,KAAY,MACZ,OAAY,QACT,AAAI,KAAW,QAClB,OAAY,SAEhB,AAAI,KAAY,MACZ,OAAY,QACT,AAAI,KAAW,QAClB,OAAY,SAGhB,AAAI,AAAI,EAAI,OAAY,IAAS,MAC7B,GAAW,EAAK,GAAW,MAAoB,SAC/C,eACA,AAAE,SApBkC,AAAE,iBA4B9C,AAAc,AAAI,EAAI,OAItB,IAAO,EAAM,SACT,AAAe,GAAY,MAAM,MACjC,EAAM,KACN,GAAU,YAGd,AAAI,EAAK,KACL,AAAe,GAAU,MAAM,MAC/B,GAAU,WjChRV,AAAO,KAAiB,AAAI,AAAQ,EAAW,OAAkB,cA3CjE,AAAuB,EAA4B,OAEnD,AAAO,GAAiB,WAwQ5B,AAAgB,AAAI,EAAI,MAAM,SAC9B,AAAI,EAAO,OACP,AAAO,OACJ,AAAI,EAAO,KACd,AAAO,MAEX,OASA,AAAgB,AAAI,EAAK,SACzB,AAAI,EAAO,OACP,AAAO,OACJ,AAAI,EAAO,OACd,AAAO,QAEX,UExTA,AAAS,AAAM,AAAiB,GAAM,MACtC,AAAS,IACT,EAAM,SAEN,AAAI,EAAM,SACR,AAAI,AAAM,OAAI,AAAO,IACrB,AAAI,SAAU,SACd,AAAO,AAAsB,EAAG,KAGlC,AAAI,EAAK,SACP,AAAI,EAAK,SAAY,AAAO,IAC5B,AAAK,KAEL,AAAI,AAAiB,KACrB,AAAI,EAAK,SACP,AAAI,EAAK,SACP,AAAK,IACL,AAAI,AAAC,SAAM,GAAI,UAAQ,SAAM,OAE7B,AAAK,IACL,AAAI,AAAC,EAAI,UAAQ,EAAI,eAGvB,AAAI,EAAK,SACP,AAAK,IACL,AAAI,AAAC,EAAI,UAAQ,SAAM,SAAM,QAE7B,AAAK,IACL,AAAI,SAAO,QAIjB,AAAI,EAAI,KACR,AAAQ,EAAI,KACZ,AAAS,EAAK,SAAM,EAAK,SAAM,EAAK,SAAM,EAAK,SAAM,EAAK,SAAM,EAAI,sBACpE,AAAS,EAAK,SAAM,EAAK,SAAM,EAAK,SAAM,EAAK,SAAM,EAAI,oBACzD,AAAS,EAAK,EAAK,MACnB,AAAI,EAAK,KAAG,AAAO,EAAI,KACvB,YAAQ,MACD,OACA,OACA,OACA,QAHG,EAAE,AAAI,SAAW,AAAC,EAAK,UAAW,MAAI,KACtC,EAAE,AAAI,SAAW,AAAC,EAAK,UAAW,MAAI,KACtC,EAAE,AAAI,SAAW,AAAC,EAAK,UAAW,MAAI,KACtC,EAAE,AAAI,SAAW,AAAC,EAAK,UAAW,MAAI,KACrC,EAEX,AAA6B,EAAG,aAiBhC,AAAI,AAAM,UAAM,AAAM,QAAI,AAAO,EAAI,KACrC,AAAQ,AAAiB,KACzB,AAAS,AAAM,EAAK,MACpB,AAAS,KACT,AAAI,AAAiB,KACrB,AAAS,AAAM,EAAK,MACpB,AAAS,KACT,AAAI,AAAC,EAAK,OAAa,GAAO,KAAG,AAAO,AAAK,OAC7C,AAAQ,AAAC,AAAC,EAAM,GAAM,GAAM,AAAC,EAAM,GAAM,MACzC,AAAK,EAAK,SACV,AAAK,EAAK,SACV,AAAI,AAAC,EAAK,GAAO,KACf,UAAQ,MACD,OACA,OACA,OACA,SAFG,AAAQ,IACR,AAAQ,KACR,AAAO,AAAC,OAGpB,AAAI,AAAC,EAAK,GAAO,KAAG,AAAO,EAAI,KAAI,AAAC,IAAK,WAAI,GAAK,aAClD,AAAI,EAAM,SACR,AAAI,EAAM,SACR,AAAQ,EAAI,KAAI,GAAI,IAAK,WAAI,GAAK,aAClC,AAAO,EAAI,KAAI,AAAC,IAAI,KAEpB,AAAQ,EAAI,KAAI,IAAK,YACrB,AAAO,EAAI,KAAI,AAAC,IAAI,OAIxB,AAAI,EAAM,GAAM,IAAM,QAAM,EAAM,UAAY,AAAO,EAAI,KAAI,AAAC,IAAK,WAAI,GAAK,aAC5E,AAAI,AAAC,EAAI,KAAM,EAAM,GAAM,IAAM,SAAI,AAAI,YACpC,AAAI,AAAK,AAAiB,EAAI,UACnC,UAAQ,MACD,OACA,OACA,OACA,QAHG,AAAQ,IACR,AAAO,AAAC,KACR,AAAO,GAAM,EAAI,aACjB,AAAO,AAAC,EAAI,UAAS,MAE/B,SF8NA,AAAI,EAAM,QAAO,EAAM,YACnB,AAAO,IAGX,AAAiB,AAAW,GAAI,QAChC,AAAI,EAAQ,YACR,EAAS,SAAM,QAGnB,AAAc,AAAI,EAAQ,KAAY,aACtC,AAAI,OAAK,OACL,AAAK,OAET,AAAE,OACF,YiCeA,AAAI,GAAa,KACb,EAGJ,AAAc,AAAI,EAAI,MACtB,AAAI,EAAK,GAAM,MACX,EAGJ,AAAI,EAAK,GAAM,MACX,AAAI,EAAU,8BAAgB,UAAW,QACrC,EAAU,8BAAgB,M/BwhClC,AAAwB,I+BxhCqB,YACrC,GAIR,AAAqB,KACrB,AAAU,iCACV,AAAU,iCAEV,AAAyB,EAAe,OACxC,AAAiB,OAEjB,AAAU,EAAK,MAEf,AAAqB,GAAgC,OACrD,AAAgB,EAAK,EAAG,KAExB,AAAW,EAAK,AAAqB,oCACrC,AAAW,EAAK,AAAqB,oCACrC,AAAW,EAAK,AAAsB,oCACtC,AAAW,EAAK,AAAsB,oCACtC,AAAW,EAAK,AAAyB,8BAAe,oCAExD,AAAe,yEAzbN,UACA,UACC,UACA,UACC,OACG,UACL,U/B5HX,EAAK,EAAK,MACV,EAAK,aACL,EAAK,EAAK,MACV,EAAK,aACL,EAAK,EAAK,MACV,KAIA,EAAK,SACL,AAAK,AAAC,EAAK,EAAK,IAAQ,EAAI,MAC5B,EAAK,EAAI,AAAC,EAAK,EAAK,IAAO,EAAI,QAC/B,AAAO,EAAK,EAAK,OAw+Bf,AAAgB,KAChB,AAAmB,AAAY,QAC/B,AAAmB,AAAY,AAAC,YAChC,AAAmB,AAAW,SAC9B,AAAmB,AAAW,SAC9B,AACE,GAAoB,KAAK,GAAoB,SAC7C,GAAoB,SAAK,GAAoB,gCAoxC/C,AAAI,AAAC,MAA0B,AAAiB,KALhD,AAAsB,MAOtB,AAAS,KACT,AAAS,KACT,AAAS,AAAU,EAAK,OAAY,GAAK,KAEzC,EAAM,KACN,AAAmB,AAAU,EAAI,GAAM,GAAM,EAAM,OACnD,AAAmB,AAAU,EAAI,MAEjC,AAAO,AAAiB,AAAC,EAAK,GAAM,GAAO,KAAO,WkB59ElD,AAAa,OACb,AAAgB,EAAS,KACzB,AAAW,EAAyB,EAAW,KAC3C,GAAgB,EAClB,AAAa,KAAkB,EAAiB,IAAe,KAC/D,AAAO,EAAyB,EAA0B,KAI5D,EAAe,KACf,uEaqSS,UACA,UACC,UACA,UACC,OACG,UACL,YbrTT,AAAa,OACb,AAAgB,EAAS,KACzB,AAAW,EAAyB,EAAW,KAC3C,GAAgB,EAClB,AAAa,KAAkB,EAAiB,IAAe,KAC/D,AAAO,EAAyB,EAA0B,KAI5D,EAAe,KACf,OaqUA,AAAQ,EAAI,KACZ,AAAI,AAAI,GAAK,GAAoB,SAC7B,AAAI,EAAI,QACJ,EAAK,OAEL,EAAK,QAGb,AAAO,EAAI,cH/UP,AAAW,gCAEX,MAAc,O/B62Ed,AAAW,KAAY,K+B52EvB,MAAc,M/B27Bd,K+B37B+B,mBAC/B,MAAc,M/B87Bd,K+B97BuC,O/Bq9DvC,AAAW,KAAY,EAAQ,K+Bn9D/B,MAA2B,O/BwmE3B,AAAwB,KAAY,K+BrmEpC,MAAuB,OAAiB,IAAG,M/B6wC3C,M+B7wCqD,IAAQ,IAAG,I/B44EhE,AAAoB,KAAY,EAAM,EAAM,EAAK,EAAY,EAAQ,K+B14ErE,MAAa,OAAW,IAAG,I/B6yE3B,AAAU,KAAY,EAAU,EAAG,K+B5yEnC,MAAa,OAAc,gBAC3B,MAAa,OAAU,AAAI,EAAI,MAAW,Q/B6xE1C,AAAU,KAAY,EAAU,K+B3xEhC,MAAgB,M/B2zBhB,K+B3zB8B,IAAG,M/BmvCjC,K+BnvCmD,I/BulEnD,AAAa,KAAY,EAAM,EAAO,EAAK,aGnR/C,AAAS,AAAiB,KAC1B,AAAS,IACT,EAAM,SAEN,AAAI,EAAM,SACR,AAAI,AAAM,OAAI,AAAO,IACrB,AAAI,KAAU,QACd,AAAO,AAAiB,EAAG,KAG7B,AAAI,EAAK,SACP,AAAI,EAAK,SAAY,AAAO,IAC5B,AAAK,KAEL,AAAI,AAAiB,KACrB,AAAI,EAAK,SACP,AAAI,EAAK,SACP,AAAK,IACL,AAAI,AAAC,KAAM,GAAI,MAAQ,KAAM,OAE7B,AAAK,IACL,AAAI,AAAC,EAAI,MAAQ,EAAI,WAGvB,AAAI,EAAK,SACP,AAAK,IACL,AAAI,AAAC,EAAI,MAAQ,KAAM,KAAM,QAE7B,AAAK,IACL,AAAI,KAAO,QAIjB,AAAI,EAAI,KACR,AAAQ,EAAI,KACZ,AAAS,EAAK,KAAM,EAAK,KAAM,EAAI,YACnC,AAAS,EAAK,KAAM,EAAI,UACxB,AAAS,EAAK,EAAK,MACnB,AAAI,EAAK,KAAG,AAAO,EAAI,KACvB,YAAQ,MACD,OACA,OACA,OACA,QAHG,EAAE,AAAI,KAAW,AAAC,EAAK,MAAW,MAAI,KACtC,EAAE,AAAI,KAAW,AAAC,EAAK,MAAW,MAAI,KACtC,EAAE,AAAI,KAAW,AAAC,EAAK,MAAW,MAAI,KACtC,EAAE,AAAI,KAAW,AAAC,EAAK,MAAW,MAAI,KACrC,EAEX,AAAwB,EAAG,WAiB3B,AAAI,AAAM,UAAM,AAAM,QAAI,AAAO,EAAI,KACrC,AAAS,AAAiB,KAC1B,AAAS,AAAiB,KAC1B,AAAI,EAAM,SAAY,AAAO,AAAK,OAClC,AAAQ,AAAO,AAAC,EAAM,GAAM,GAAM,AAAC,EAAM,GAAM,MAC/C,EAAM,SACN,EAAM,SACN,AAAI,EAAM,KACR,UAAQ,MACD,OACA,OACA,OACA,SAFG,AAAQ,IACR,AAAQ,OACR,AAAO,AAAC,SAGpB,AAAI,EAAM,KAAG,AAAO,EAAI,KAAI,AAAC,MAAK,OAAI,KAAK,SAC3C,AAAI,EAAM,SACR,AAAI,EAAM,SACR,AAAa,EAAI,KAAI,KAAI,MAAK,OAAI,KAAK,SACvC,AAAO,EAAI,KAAI,AAAC,IAAI,KAEpB,AAAa,EAAI,KAAI,MAAK,QAC1B,AAAO,EAAI,KAAI,AAAC,IAAI,OAGxB,AAAI,EAAM,EAAM,IAAM,QAAM,EAAM,UAAY,AAAO,EAAI,KAAI,AAAC,MAAK,OAAI,KAAK,SAE5E,AAAI,AAAC,EAAI,KAAM,EAAM,EAAM,IAAM,SAAI,AAAI,QACpC,AAAI,AAAK,AAAiB,EAAI,UACnC,UAAQ,MACD,OACA,OACA,OACA,QAHG,AAAQ,IACR,AAAO,AAAC,KACR,AAAO,KAAM,EAAI,SACjB,AAAO,AAAC,EAAI,MAAS,QAE/B,I+B/kEA,AAAW,EAAQ,AAAI,EAAQ,SbiC/B,AAAI,EAAc,AAAK,QAAc,EAAqB,mBAC1D,AAAY,AAAQ,KAAkB,EAAgB,SAClD,GAAkB,EAChB,AAAC,IAAiB,AAChB,AAAC,KAA0B,EAAgB,oBAGnD,UM+II,AAAW,gCAEX,AAAa,OAGb,MAAc,iBAEd,MAAc,WAAiB,mBAE/B,MAA2B,iBAG3B,MAAuB,OAAuB,IAAG,YAAU,IAAQ,IAAG,wBAEtE,MAAc,WAAyB,mBAEvC,MAAa,OAAoB,OAAS,OAAS,uBAEnD,MAAa,OAAiB,IAAG,kBACjC,MAAa,OAAoB,gBACjC,MAAa,OAA0B,gBACvC,MAAa,OAAyB,gBAGtC,MAAmB,M3By4BnB,K2Bz4BoC,OAAe,yBACnD,MAAkB,WAAyB,OAAoB,yBAE/D,MAAgB,WAAc,UAA2B,WAAkB,oBAG3E,MAAc,O3BozEd,AAAW,KAAY,K2BlzEvB,MAA2B,O3BijE3B,AAAwB,KAAY,K2B9iEpC,MAAuB,OAAuB,IAAG,M3BstCjD,M2BttC2D,IAAQ,IAAG,I3Bq1EtE,AAAoB,KAAY,EAAM,EAAM,EAAK,EAAY,EAAQ,K2Bn1ErE,MAAc,WAAyB,O3Bu5DvC,AAAW,KAAY,EAAQ,K2Bp5D/B,MAAa,OAAoB,OAAK,OAAK,O3BiwE3C,AAAU,KAAY,EAAU,EAAG,EAAG,K2B/vEtC,MAAa,OAAiB,IAAG,I3BivEjC,AAAU,KAAY,EAAU,EAAG,K2BhvEnC,MAAa,OAAoB,gBACjC,MAAa,OAAgB,AAAI,EAAE,GAAI,KAAQ,MAAM,IAAW,Q3BiuEhE,AAAU,KAAY,EAAU,K2B9tEhC,MAAkB,M3Bs3BlB,K2Bt3B2C,OAAoB,M3B04B/D,KA8hCA,AAAc,KAAY,EAAQ,EAAM,K2Bt6DxC,MAAgB,M3B4vBhB,K2B5vB8B,UAA2B,M3BorCzD,K2BprC2E,I3BwhE3E,AAAa,KAAY,EAAM,EAAO,EAAK,a4BzuE3C,AAAW,gCAEX,AAAa,OAEb,EAAK,EAAK,KACV,EAAK,EAAK,KACV,EAAK,EAAK,KACV,EAAK,EAAK,KAEV,MAAc,O5By+Ed,AAAW,KAAY,K4Bv+EvB,MAAc,WAAiB,O5BilE/B,AAAW,KAAY,EAAQ,K4B/kE/B,MAA2B,O5BouE3B,AAAwB,KAAY,K4BjuEpC,MAAuB,OAAiB,IAAG,M5By4C3C,M4Bz4CqD,IAAQ,IAAG,I5BwgFhE,AAAoB,KAAY,EAAM,EAAM,EAAK,EAAY,EAAQ,K4BtgFrE,MAAa,OAAc,OAAS,OAAS,O5Bu7E7C,AAAU,KAAY,EAAU,EAAG,EAAG,K4Bt7EtC,MAAa,OAAU,AAAI,EAAE,GAAI,KAAQ,MAAM,IAAW,Q5B05E1D,AAAU,KAAY,EAAU,K4Bv5EhC,MAAmB,M5B2iCnB,K4B3iCoC,IAAM,M5BmkC1C,KA8hCA,AAAc,KAAY,EAAQ,EAAM,K4B/lExC,MAAc,M5By6Bd,K4Bz6BwB,IAAG,I5B8sE3B,AAAW,KAAY,EAAM,EAAO,WIxhEpC,AAAW,gCAEX,AAAI,AAAC,MAAc,OJonBnB,AAAkB,QInnBd,EAGJ,MAAc,OJ8xEd,AAAW,KAAY,KI5xEvB,MAAiB,MJg9CjB,MAyaA,AAAc,KAAY,KIx3D1B,MAAe,YAAe,OJ84D9B,AAAY,KAAY,EAAQ,KI74DhC,MAAiB,YAAe,MJk5ChC,MIl5CuD,0BACvD,MAAiB,YAAe,MJq5ChC,MIr5CuD,MJ63CvD,MA80BA,AAAc,KAAY,EAAQ,EAAO,KItsEzC,AAAI,AAAC,QACD,MAAe,MJg0DnB,MIh0D2C,gBACvC,MAAe,MJm0DnB,MIn0DsD,IJ+oEtD,AAAY,KAAY,EAAO,KI9oE3B,MAAc,MJy5ClB,MIz5CiC,IAAG,YAAQ,MJosC5C,MIpsCoD,MJoqCpD,KIpqCsE,OJ4rEtE,AAAW,KAAY,EAAQ,EAAO,EAAgB,EAAQ,EAAK,KI1rE/D,MAAa,OAAgB,IJitEjC,AAAU,KAAY,EAAU,KI/sE5B,EAAqB,MAGzB,MAA2B,iBAC3B,MAA2B,OJwgE3B,AAAwB,KAAY,KItgEpC,MAAc,MJs1Bd,KIt1B+B,mBAG/B,MAAuB,OAAiB,IAAG,YAAU,IAAQ,IAAI,wBACjE,MAAuB,OAAiB,IAAG,MJ0qC3C,MI1qCqD,IAAQ,IAAI,IJyyEjE,AAAoB,KAAY,EAAM,EAAM,EAAK,EAAY,EAAQ,KIvyErE,MAAc,MJo1Bd,KIp1BuC,OJ22DvC,AAAW,KAAY,EAAQ,aIr2D/B,AAAI,AAAC,QACD,EAGJ,AAAW,gCAEX,MAAa,OAAyB,OAAS,OAAS,uBACxD,MAAa,OAAqB,OAAU,OAAU,OJ2sEtD,AAAU,KAAY,EAAU,EAAG,EAAG,aIxmEtC,AAAI,AAAC,QACD,EAGJ,AAAW,gCAGX,AAAI,EAAW,MACX,EAAK,KAAa,MAAM,OACrB,AAAI,EAAW,MAClB,EAAK,KAAa,QAEtB,AAAI,EAAW,MACX,EAAK,KAAc,MAAM,OACtB,AAAI,EAAW,MAClB,EAAK,KAAc,QAGvB,MAAa,OAAW,IAAG,IJwkE3B,AAAU,KAAY,EAAU,EAAG,KIvkEnC,MAAa,OAAc,IJyjE3B,AAAU,KAAY,EAAU,KItjEhC,MAAmB,MJ0sBnB,KI1sBoC,OAAe,yBACnD,MAAmB,MJ6sBnB,KI7sB4C,OAAc,MJiuB1D,KA8hCA,AAAc,KAAY,EAAQ,EAAM,KI7vDxC,MAAgB,MJmlBhB,KInlB8B,UAAqB,MJmhCnD,KInhCsE,IJ+2DtE,AAAa,KAAY,EAAM,EAAO,EAAK,akC9wD/C,AAAsB,QAEtB,AAAI,EAAiB,KACjB,EAGC,AAAa,QAAG,EAAI,WACrB,AAAe,GAAY,OAE3B,AAAU,AAAe,KAAU,OACnC,AAAU,AAAe,KAAU,OAEnC,EAAuB,KACvB,EAAuB,KACvB,EAAmB,AAAiB,EAAG,EAAG,WAE1C,AAAI,AAAC,QACD,GAGJ,AAAiB,OACjB,AAAI,EAAQ,GAAoB,SAC5B,EAAS,OAEb,AAAiB,OACjB,AAAI,EAAQ,GAAoB,SAC5B,EAAS,OAEb,AAAyB,AAAY,EAAO,OAE5C,AAAwB,AAAM,KAAM,AAAC,EAAQ,GAAQ,EAAQ,IAAU,KAAY,QAAY,KAAK,UAEpG,GACI,GAAY,QACZ,EAAG,EAAG,KAAM,EAAa,EAAY,KAEzC,GAAuB,GAAY,QAAc,EAAG,EAAG,EAAI,KAAY,OAAK,EAAI,KAAY,OAAK,MA9B7D,AAAE,YAiC1C,MAEK,AAAa,QAAG,EAAI,WACrB,AAAe,GAAY,OAE3B,AAAI,KAAoB,QAAQ,AAAC,SAC7B,GAGJ,GAAuB,GAAgB,QAAe,MAEtD,GACI,GAA6B,GAC7B,KAAsB,KAAuB,MAC7C,KAAK,iCAAyB,iCAZE,AAAE,oBLjdtC,AAAW,gCAEX,MAAc,O7B67Ed,AAAW,KAAY,K6B57EvB,MAAc,M7B2gCd,K6B3gC+B,mBAC/B,MAAc,M7B8gCd,K6B9gCuC,O7BqiEvC,AAAW,KAAY,EAAQ,K6BniE/B,MAA2B,O7BwrE3B,AAAwB,KAAY,K6BrrEpC,MAAuB,OAAiB,IAAG,M7B61C3C,M6B71CqD,IAAQ,IAAG,I7B49EhE,AAAoB,KAAY,EAAM,EAAM,EAAK,EAAY,EAAQ,K6B19ErE,MAAa,OAAc,OAAS,OAAS,O7B24E7C,AAAU,KAAY,EAAU,EAAG,EAAG,K6B14EtC,MAAa,OAAW,IAAG,I7B43E3B,AAAU,KAAY,EAAU,EAAG,K6B33EnC,MAAa,OAAc,gBAC3B,MAAa,OAAc,gBAC3B,MAAa,OAAU,AAAI,EAAE,GAAK,MAAW,Q7B22E7C,AAAU,KAAY,EAAU,K6Bz2EhC,MAAgB,M7By4BhB,K6Bz4B8B,IAAG,M7Bi0CjC,K6Bj0CmD,I7BqqEnD,AAAa,KAAY,EAAM,EAAO,EAAK,akC/rD/C,AAAc,QAEd,AAAmB,AAAI,EAAI,MAAU,QAEhC,AAAa,QAAG,EAAI,WACrB,AAAa,GAAS,OAEtB,AAAU,AAAe,KAAQ,OACjC,AAAU,AAAe,KAAQ,OAEjC,AAAI,AAAC,AAAiB,EAAG,EAAG,WACxB,GAGJ,GACI,GAAY,QACZ,EAAG,EAAG,KAAK,KAAc,GAAO,MAZR,AAAE,oBJ7f9B,AAAW,gCAEX,MAAc,O9B+7Ed,AAAW,KAAY,K8B97EvB,MAAc,M9B6gCd,K8B7gC+B,mBAC/B,MAAc,M9BghCd,K8BhhCuC,O9BuiEvC,AAAW,KAAY,EAAQ,K8BriE/B,MAA2B,O9B0rE3B,AAAwB,KAAY,K8BvrEpC,MAAuB,OAAiB,IAAG,M9B+1C3C,M8B/1CqD,IAAQ,IAAG,I9B89EhE,AAAoB,KAAY,EAAM,EAAM,EAAK,EAAY,EAAQ,K8B59ErE,MAAa,OAAc,OAAS,OAAS,O9B64E7C,AAAU,KAAY,EAAU,EAAG,EAAG,K8B54EtC,MAAa,OAAW,IAAG,I9B83E3B,AAAU,KAAY,EAAU,EAAG,K8B73EnC,MAAa,OAAc,gBAC3B,MAAa,OAAc,gBAC3B,MAAa,OAAU,AAAI,AAAC,EAAI,KAAQ,GAAI,KAAQ,MAAM,IAAW,Q9B62ErE,AAAU,KAAY,EAAU,K8B32EhC,MAAgB,M9B24BhB,K8B34B8B,IAAG,M9Bm0CjC,K8Bn0CmD,I9BuqEnD,AAAa,KAAY,EAAM,EAAO,EAAK,akCptD/C,AAAc,QAEd,AAAmB,AAAI,EAAI,MAAU,QAEhC,AAAa,QAAG,EAAI,WACrB,AAAe,GAAW,OAE1B,AAAU,AAAe,KAAU,OACnC,AAAU,AAAe,KAAU,OAEnC,AAAI,AAAC,AAAiB,EAAG,EAAG,WACxB,GAGJ,GACI,GAAY,QACZ,EAAG,EAAG,KAAM,KAAgB,GAAO,MAZX,AAAE,oBDhf9B,AAAW,gCAEX,MAAc,OjCu8Ed,AAAW,KAAY,KiCt8EvB,MAAc,MjCqhCd,KiCrhC+B,mBAC/B,MAAc,MjCwhCd,KiCxhCuC,OjC+iEvC,AAAW,KAAY,EAAQ,KiC7iE/B,MAA2B,OjCksE3B,AAAwB,KAAY,KiC/rEpC,MAAuB,OAAiB,IAAG,MjCu2C3C,MiCv2CqD,IAAQ,IAAG,IjCs+EhE,AAAoB,KAAY,EAAM,EAAM,EAAK,EAAY,EAAQ,KiCp+ErE,MAAa,OAAW,IAAG,IjCu4E3B,AAAU,KAAY,EAAU,EAAG,KiCt4EnC,MAAa,OAAc,gBAC3B,MAAa,OAAU,AAAI,EAAE,GAAK,MAAW,QjCu3E7C,AAAU,KAAY,EAAU,KiCr3EhC,MAAgB,MjCq5BhB,KiCr5B8B,IAAG,MjC60CjC,KiC70CmD,IjCirEnD,AAAa,KAAY,EAAM,EAAO,EAAK,iBG+c/C,AAAS,AAAiB,KAC1B,AAAW,EAAM,KACjB,EAAM,SAEN,AAAI,EAAM,SACR,AAAI,EAAK,SACP,AAAO,IAET,AAAO,EAAU,KAAG,+IAGlB,EAAmB,IAAG,EACxB,AAAI,EAAM,SACR,AAAI,EAAM,SACR,AAAO,EAAW,IAAO,GAAI,WAAS,GAAI,aAAS,+IAEnD,AAAO,EAAW,IAAO,GAAI,WAAS,GAAI,aAAS,iJAGvD,AAAI,EAAM,SACR,AAAI,EAAM,SACR,AAAO,EAAW,IAAO,GAAI,WAAS,GAAI,aAAS,+IAEnD,AAAO,EAAW,IAAO,GAAI,WAAS,GAAI,aAAS,kJAMzD,AAAI,EAAM,SAAY,AAAO,EAAI,KAGjC,AAAQ,EAAS,IAAG,IAAI,IAngC1B,AAAI,EAAI,SACN,AAAQ,AAAQ,GAAI,aACpB,AAAa,GAAI,EAAI,WAAQ,EAAI,cACjC,AAAO,MAGT,AAAQ,EAAiB,IAAG,IAvC5B,AAAa,AAAC,EAAK,GAAM,MACzB,AAAa,AAAM,EAAS,MAC5B,AAAa,IAAe,EAAU,GAAK,MAE3C,AAAS,AAAU,OACnB,AAAS,AAAU,OAGnB,AAAI,EAAQ,KACV,AAAS,AAAU,OACnB,AAAM,EAAO,GAAK,MAClB,EAAM,EAAO,EAAQ,QAErB,AAAK,EAAO,EAAK,OAGnB,AAAS,AAAC,EAAO,GAAK,IAAW,EAAM,MACvC,AAAoB,AAAC,EAAI,MAAc,SACvC,AAAc,EAAW,GAAM,EAAW,GAAM,MAChD,AAAa,EAAW,KACxB,AAAQ,AAAO,EAAW,GAAO,EAAM,OACvC,AAAa,AAAc,SAAO,IAAK,OACvC,KAkBA,AAAc,EAAC,GAAG,EAAG,MA6/BnB,AAAQ,KACR,EAAiB,IAAG,EAAI,KA98B1B,AAAQ,EAAI,KACZ,AAAQ,SAAK,EAAI,aACjB,AAAQ,SAAK,EAAI,aACjB,AAAQ,EAAI,KACZ,AAAQ,EAAI,KACZ,AAAQ,SAAK,EAAI,aAEjB,AAAI,AAAC,EAAI,EAAI,IAAK,AAAC,EAAI,GAAM,EAAI,EAAI,QACrC,AAAa,IAAM,MAAK,IAAI,a6BnwDtB,AAAW,gCAEX,MAAc,OhC+9Ed,AAAW,KAAY,KgC99EvB,MAAc,MhC6iCd,KgC7iC+B,OhCwkE/B,AAAW,KAAY,EAAQ,KgCtkE/B,MAA2B,OhC2tE3B,AAAwB,KAAY,KgCxtEpC,MAAuB,OAAiB,IAAG,MhCg4C3C,MgCh4CqD,IAAQ,IAAG,IhC+/EhE,AAAoB,KAAY,EAAM,EAAM,EAAK,EAAY,EAAQ,KgC7/ErE,MAAa,OAAc,OAAS,OAAS,OhC86E7C,AAAU,KAAY,EAAU,EAAG,EAAG,KgC76EtC,MAAa,OAAW,IAAG,IhC+5E3B,AAAU,KAAY,EAAU,EAAG,KgC95EnC,MAAa,OAAc,gBAC3B,MAAa,OAAc,gBAC3B,MAAa,OAAU,AAAI,AAAC,EAAI,KAAQ,GAAI,KAAQ,MAAM,IAAW,QhC84ErE,AAAU,KAAY,EAAU,KgC54EhC,MAAc,MhC46Bd,KgC56B4B,IAAG,IhCqsE/B,AAAW,KAAY,EAAM,EAAO,akCvqDxC,AAAsB,QAEtB,AAAI,EAAiB,KACjB,EAGC,AAAa,QAAG,EAAI,WACrB,AAAe,GAAY,OAE3B,AAAI,UAAoB,QACpB,GAGJ,AAAa,AAAe,KAAU,OACtC,AAAa,AAAe,KAAU,OACtC,AAAkB,EAAW,EAAI,GAAI,EAAI,M/BgmE7C,AAAyB,M+B7lErB,AAAmB,KAAY,AAAM,KAAY,EAAO,OAAO,KAAK,KAAY,YAEhF,AAAmB,AAAY,EAAG,OAElC,AAAI,EAAI,KACJ,AAAI,EAAI,AAAC,MAEL,AAAI,OACJ,AAAI,AAAU,QAGd,AAAI,AAAU,EAAQ,GAAW,YACjC,AAAI,SAGR,AAAI,EAAI,AAAC,MAEL,AAAI,AAAC,AAAU,EAAQ,GAAW,aAClC,AAAI,QAGJ,AAAI,OACJ,AAAI,AAAC,AAAU,UAKvB,AAAI,EAAI,KAAO,SACX,AAAI,KAAO,SACR,AAAI,EAAI,KAAM,SACjB,AAAI,KAAM,UAEd,AAAI,EAAI,KAAO,SACX,AAAI,KAAO,SACR,AAAI,EAAI,KAAM,SACjB,AAAI,KAAM,UAGd,GACI,GAAY,QACZ,EAAG,EAAG,EAAO,EAAO,MApDY,AAAE,iBS7mBtC,K3C+xEA,AAAM,akBtuDZ,AAAW,EAA2B,EAAU,MAChD,AAAW,EAA2B,EAAU,MAC5C,EAAmB,IAAG,AACpB,EAAO,KAAK,AAAE,AAAC,EAAO,GAAM,EAAO,WACrC,IACE,AAAI,AAAU,KAAS,AAAU,QAAO,GACxC,EAAQ,KACR,EAAQ,KACR,EAAQ,KACD,EAAO,YAGpB,IAAO,oBACL,AAAQ,AAAe,OACvB,AAAQ,AAAe,OACvB,AAAI,EAAK,KAAG,AAAO,EAAI,KACvB,EAAQ,KACR,EAAQ,UAEV,OCzgBE,AAAI,EAAS,KAAO,AAAO,IAC3B,AAAI,EAAS,QAAQ,EAAU,MAAM,AAAO,IAC5C,AAAiB,MACjB,AAAI,EAAc,OAAc,AAAO,IAEvC,AAAQ,AAAY,EAAM,EAAG,EAAO,EAAG,SAUvC,AAAQ,AAAU,EAAM,ceoBxB,AAAI,GAAa,KACb,EAIJ,AAAgB,AAAI,EAAI,MACxB,AAAI,EAAK,IAAS,MACd,EAGJ,AAAuB,IACvB,AAAwB,IAExB,AAAsB,QACjB,AAAa,QAAG,EAAI,WACrB,AAAe,GAAY,OAE3B,AAAI,KAAe,iCACf,GAIJ,AAAI,AAAiB,KAAsB,KAAsB,UAC7D,AAAa,IACb,AAAI,EAAe,AAAI,QACnB,AAAe,AAAI,UAXS,AAAE,YAgB1C,AAAoB,MAEpB,AAAI,IACA,AAAkB,AAAI,8BAAmB,KACzC,AAAI,EAAO,KACP,AAAQ,OAER,AAAQ,QAKhB,AAAI,GAAc,OACd,AAAgB,KAChB,AAAa,KACb,EAGJ,AAAqB,AAAI,EAAI,MAC7B,AAAI,EAAU,GAAQ,MAClB,EAGJ,AAAI,GAAgB,QAChB,AAAe,MACf,AAAoB,KACpB,AAAU,KACV,AAAa,WnCrHjB,AAAW,KAAqB,SAwHlC,AAAI,GAGJ,AAAgB,KAGhB,AAAS,KACT,AAAW,OACX,IAAO,EAAQ,SACT,GAAO,AAAO,KAAc,oBAChC,AAAgB,EAA0B,GAAgB,KAC1D,AAAO,YAIT,AAAY,AAAK,MACjB,AAAS,KACT,AAAO,OACP,IAAO,EAAQ,SACT,GAAO,AAAO,KAAc,oBAChC,AAAgB,EAA0B,GAAgB,KAC1D,AAAO,YAIT,AAAW,KACX,AAAO,OACP,IAAO,EAAQ,SACT,GAAO,AAAO,KAAc,qBAChC,AAAc,OACd,AAAI,EAA0B,MAC5B,EAAqB,IACrB,EAAY,KAEZ,GAAS,QACT,AAAI,GACJ,AAAO,EAA0B,OAEnC,AAAO,SAET,EAAqB,IACrB,EAAY,IAGZ,AAAY,KACZ,AAAU,KACV,AAAQ,KAER,AAAI,GACJ,AAAI,amCitBF,GAA+B,EAAU,KACzC,MAGA,AAAa,GAAyB,OAEtC,AAAc,GAAgB,IAAgB,MAAM,QACpD,AAAc,GAAgB,IAAgB,MAAM,QAEpD,AAA2B,AAAiB,EAAI,EAhbD,UAkb/C,AAAc,SAEd,AAAY,KACZ,AAAI,GAAU,KAAM,GAAe,YAC/B,AAAY,GAAe,UAE/B,AAAI,GAAa,KACb,2BAAgB,QAChB,2BAAgB,QAEhB,AAAI,IACA,AAAiB,EAAW,EAAK,GAAK,EAAK,YAE3C,AAAI,EAAM,QAEN,2BAAgB,EAAU,MAAQ,MAClC,2BAAgB,EAAU,MAAQ,QAI1C,2BAAqB,MAGzB,AAAQ,KAER,AAAa,KAEC,OAAa,OAC3B,AAAI,GAAa,KACb,AAAK,gCACL,AAAK,gCAEL,AAAkB,AAAI,EAAI,MAC1B,AAAI,EAAY,GAAM,MAClB,AAAS,gCACT,AAAS,gCAET,AAAI,EAAM,QAAO,EAAM,cAInB,AAAiB,EAAW,EAAK,GAAK,EAAK,YAC3C,AAAgB,KAAe,KAC/B,EAAM,KACN,EAAM,KAEN,AAAI,GAAqB,KACrB,AAAa,OACb,EAAU,8BAAgB,MAC1B,EAAU,8BAAgB,MAC1B,EAAS,iCACT,EAAS,iCACT,EAAS,KACT,EAAY,iCACZ,EAAc,GAAiB,MAAU,SACzC,GAAc,OAEd,AAAe,OACf,EAAY,8BAAgB,MAC5B,EAAY,8BAAgB,MAC5B,EAAW,iCACX,EAAW,iCACX,EAAW,KACX,EAAc,iCACd,EAAgB,GAAiB,MAAU,SAC3C,GAAgB,OAGpB,SACA,AAAI,GAAqB,KACrB,AAAoB,OAI5B,AAAwB,OAIhC,AAAiB,AAAe,KAAK,OACrC,AAAiB,AAAe,KAAK,OACrC,GAAiB,AAAC,GAAU,AAAC,GAAU,KAAK,KAE5C,AAAc,EAAG,EAAI,KACrB,AAAY,EAAG,EAAI,KACnB,AAAc,EAAG,EAAI,KAGrB,AAAI,AAAiB,EAAU,EAAU,UACrC,GAAiB,EAAU,EAAU,KAAY,MAGrD,AAAa,EAAG,EAAI,KAEpB,AAAI,IACA,GACI,GACA,EACA,EACA,KAAK,KACL,MAGR,MAEA,AAAI,GAAa,KACb,2BAAqB,MAGzB,AAAY,EAAG,EAAI,KAGnB,QnCr+BA,AAAW,OACX,AAAI,EAAQ,KACN,GAAO,AAAO,KAAa,KAAQ,EAA0B,yBACjE,EAEF,AAAW,OACP,GAAO,AAAO,mBAClB,EAAY,IACZ,EAAY,SAuEd,AAAI,IACF,AAAU,AAAmB,EAAM,KACnC,AAAI,KAAa,KACC,gBAElB,KACA,EAAW,GAAU,KAEvB,OAMA,AAAI,AAAC,KAAK,EACV,AAAU,AAAmB,EAAM,KACnC,AAAI,KAAa,KACC,gBAElB,KACA,EAAW,GAAW,UAhCtB,AAAI,AAAC,KAAK,EACV,AAAU,AAAmB,EAAM,KACnC,AAAI,GACJ,AAAI,KAAa,MACf,KACA,EAAW,GAAS,AAAK,gqCsB4WzB,AAAI,GASJ,AAAQ,AAAkB,KAAc,kBATxC,AAAI,GASJ,AAAQ,AAAkB,KAAc,wCuB5fxC,AAAQ,KAAW,0CvBmff,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,uVATpC,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,qBiBtTxC,AAAQ,AAAkB,KAAe,KACzC,AAAc,AAAkB,OAC5B,OAAkB,IAAgB,EACpC,AAAU,IACV,AAAU,EAAM,AAAO,KAAqB,SAC5C,IAAO,EAAM,SACX,AAAY,IACZ,AAAI,AAAE,KAAmB,MACnB,GAAgB,EAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,MAElB,GAAgB,EAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,OAGxB,EAAO,EAzMb,YA4ME,AAAQ,EAAS,oBjBqRb,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,kIATpC,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,0CATpC,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,oBATpC,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,oHiBtTxC,AAAQ,AAAkB,KAAe,KACzC,AAAc,AAAkB,OAC5B,OAAkB,IAAgB,EACpC,AAAU,IACV,AAAU,EAAM,AAAO,KAAqB,SAC5C,IAAO,EAAM,SACX,AAAY,IACZ,AAAI,AAAE,KAAmB,MACvB,AAAI,GAMA,GAAgB,EAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,OAGxB,EAAO,EAzMb,YA4ME,AAAQ,EAAS,oBjBqRb,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,2CiBtTxC,AAAQ,AAAkB,KAAe,KACzC,AAAc,AAAkB,OAC5B,OAAkB,IAAgB,EACpC,AAAU,IACV,AAAU,EAAM,AAAO,KAAqB,SAC5C,IAAO,EAAM,SACX,AAAY,IACZ,AAAI,AAAE,KAAmB,MACvB,AAAI,GAMA,GAAgB,EAClB,AAAU,AAAkB,OACxB,GAEG,AAAQ,EAAK,OAGxB,EAAO,EAzMb,YA4ME,AAAQ,EAAS,wHjBqRb,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,oBATpC,GAAgB,EAClB,AAAU,OACV,AAAU,EAAO,AAAO,KAAgB,MACxC,IAAO,EAAM,SACX,AAAU,AAAY,OACtB,AAAI,IAAK,AAAQ,EAAK,MACtB,EAAO,WAGX,AAAQ,AAAkB,KAAc,4BuB5fxC,AAAQ,KAAW","sourceRoot":"./client.wasm","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n//  Memory manager block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                            MM info                              -4\n// >ptr\n//                               ...                              \n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n//  Garbage collector object layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                      Memory manager block                       -20\n// \n//                             GC info                             -16\n// \n//                             GC info                             -12\n// \n//                             RT id                               -8\n// \n//                             RT size                             -4\n// >ptr\n//                               ...                              \n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n//  Block size interpretation (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//  |                    FL                        SB = SL + AL    usize\n// \n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n//  Block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//             \n//                           size                             LF  info   overhead\n// >ptr           \n//                         if free:  prev                          usize\n//    \n//                         if free: next                          \n//    \n//                              ...                                   >= 0\n//    \n//                         if free: back                          \n//  >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n//  Root layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//           \n//         0        |           flMap                            S \n//       \n//                            slMap[0] S                             \n//      \n//                            slMap[1]                               \n//   u32 \n//                            slMap[22]                              \n//     usize\n//                             head[0]                             \n//       \n//                               ...                               \n//       \n//                            head[367]                            \n//       \n//                              tail                               \n//    SIZE   \n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export var ROOT: Root;\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  var head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  var size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  var prev = block.prev;\n  var next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  var fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    const invRound = inv - SL_BITS;\n    let requestSize = size < halfMaxSize\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\n      : size;\n    fl = inv - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  var slMap = GETSL(root, fl) & (~0 << sl);\n  var head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  var blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, end: usize): bool {\n  if (DEBUG) assert(start <= end); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  var tail = GETTAIL(root);\n  var tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  var size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  var leftSize = size - 2 * BLOCK_OVERHEAD;\n  var left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\n  if (size < halfMaxSize) { // don't round last fl\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\n    size += (1 << (invRound - clz<usize>(size))) - 1;\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  var pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  var pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size >= BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  var rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  var pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  var root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  var memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, <Block>block);\n  prepareBlock(root, <Block>block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return <Block>block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  var payloadSize = prepareSize(size);\n  var blockInfo = block.mmInfo;\n  var blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  var right = GETRIGHT(block);\n  var rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  var newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  var block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE } from \"./common\";\nimport { onvisit, oncollect } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === TCMS: A Two-Color Mark & Sweep garbage collector ===\n\n//  Colors \n//  Color        Meaning                                         \n// \n//  WHITE*       Unreachable                                     \n//  BLACK*       Reachable                                       \n//  TRANSPARENT  Manually pinned (always reachable)              \n// \n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy var white = 0;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy var total: usize = 0;\n\n// @ts-ignore: decorator\n@lazy var fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy var pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n//  Managed object layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                       Memory manager block                     \n// \n//                               next                          C  = nextWithColor\n// \n//                               prev                             \n// \n//                               rtId                             \n// \n//                               rtSize                           \n// >ptr\n//                                ...                             \n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    let next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    let prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  var obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white);\n  total += obj.size;\n  return changetype<usize>(obj) + TOTAL_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  var oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  if (oldPtr < __heap_base) { // move to heap for simplicity\n    let newPtr = __new(size, oldObj.rtId);\n    memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n    return newPtr;\n  }\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  total -= oldObj.size;\n  var newPtr = __realloc(oldPtr - OBJECT_OVERHEAD, OBJECT_OVERHEAD + size) + OBJECT_OVERHEAD;\n  var newObj = changetype<Object>(newPtr - TOTAL_OVERHEAD);\n  newObj.rtSize = <u32>size;\n\n  // Replace with new object\n  newObj.next.prev = newObj;\n  newObj.prev.next = newObj;\n\n  total += newObj.size;\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // nop\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.unlink(); // from fromSpace\n    obj.linkTo(toSpace, i32(!white));\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  var obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  obj.unlink(); // from pinSpace\n  obj.linkTo(fromSpace, white);\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC at\", 1, total);\n\n  // Mark roots (add to toSpace)\n  __visit_globals(VISIT_SCAN);\n\n  // Mark direct members of pinned objects (add to toSpace)\n  var pn = pinSpace;\n  var iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);\n    iter = iter.next;\n  }\n\n  // Mark what's reachable from toSpace\n  var black = i32(!white);\n  var to = toSpace;\n  iter = to.next;\n  while (iter != to) {\n    if (DEBUG) assert(iter.color == black);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, VISIT_SCAN);\n    iter = iter.next;\n  }\n\n  // Sweep what's left in fromSpace\n  var from = fromSpace;\n  iter = from.next;\n  while (iter != from) {\n    if (DEBUG) assert(iter.color == white);\n    let newNext = iter.next;\n    if (changetype<usize>(iter) < __heap_base) {\n      iter.nextWithColor = 0; // may become linked again\n      iter.prev = changetype<Object>(0);\n    } else {\n      total -= iter.size;\n      if (isDefined(__finalize)) __finalize(changetype<usize>(iter) + TOTAL_OVERHEAD);\n      __free(changetype<usize>(iter) + BLOCK_OVERHEAD);\n    }\n    iter = newNext;\n  }\n  from.nextWithColor = changetype<usize>(from);\n  from.prev = from;\n\n  // Flip spaces and colors\n  fromSpace = to;\n  toSpace = from;\n  white = black;\n\n  if (TRACE) trace(\"GC done at\", 1, total);\n  if (RTRACE) oncollect(total);\n}\n","type WebGLContextAttributes = i32;\r\n\r\nexport type GLenum = u32;\r\nexport type GLboolean = bool;\r\nexport type GLbitfield = u32;\r\nexport type GLbyte = i8;\r\nexport type GLshort = i16;\r\nexport type GLint = i32;\r\nexport type GLsizei = i32;\r\nexport type GLintptr = i32; //i64;\r\nexport type GLsizeiptr = i32; //i64;\r\nexport type GLubyte = u8;\r\nexport type GLushort = u16;\r\nexport type GLuint = u32;\r\nexport type GLfloat = f32;\r\nexport type GLclampf = f32;\r\nexport type GLuint64 = u32; //u64;\r\nexport type GLint64 = i32; //i64;\r\n\r\nexport type WebGLUniformLocation = i32;\r\nexport type TexImageSource = i32;\r\nexport type Int32List = i32;\r\nexport type Uint32List = i32;\r\nexport type Float32List = i32;\r\nexport type WebGLQuery = i32;\r\nexport type WebGLSampler = i32;\r\nexport type WebGLSync = i32;\r\nexport type WebGLTransformFeedback = i32;\r\nexport type ImageData = i32;\r\nexport type DOMString = string;\r\nexport type HTMLImageElement = externref;\r\nexport type HTMLVideoElement = externref;\r\nexport type WebGLVertexArrayObject = i32;\r\n\r\n// == debug function not part of WebGL\r\nexport declare function logi32(arg: i32): void;\r\nexport declare function logf32(arg: f32): void;\r\n// == Not a part of WebGL, but there must be a way to create and load images\r\n// export type ImageData = i32;\r\nexport declare function createImage(image_location: string): ImageData;\r\nexport declare function imageReady(image_id: ImageData): bool;\r\n\r\n// === WebGLContextAttributes ===\r\nexport const ALPHA_DEFAULT = true;\r\nexport const FALSE: GLboolean = false;\r\n\r\n//export declare function activateTexture(gl: WebGLContextAttributes, texture: WebGLTexture): void;\r\n\r\nexport declare function getAlpha(gl: WebGLContextAttributes): GLboolean;\r\nexport declare function setAlpha(gl: WebGLContextAttributes, value: GLboolean): void;\r\n\r\nexport const DEPTH_DEFAULT = true;\r\nexport declare function getDepth(gl: WebGLContextAttributes): GLboolean;\r\nexport declare function setDepth(gl: WebGLContextAttributes, value: GLboolean): void;\r\n\r\nexport const STENCIL_DEFAULT = false;\r\nexport declare function getStencil(gl: WebGLContextAttributes): GLboolean;\r\nexport declare function setStencil(gl: WebGLContextAttributes, value: GLboolean): void;\r\n\r\nexport const ANTIALIAS_DEFAULT = true;\r\nexport declare function getAntialias(gl: WebGLContextAttributes): GLboolean;\r\nexport declare function setAntialias(gl: WebGLContextAttributes, value: GLboolean): void;\r\n\r\nexport const PREMULTIPLIED_ALPHA_DEFAULT = true;\r\nexport declare function getPremultipliedAlpha(gl: WebGLContextAttributes): GLboolean;\r\nexport declare function setPremultipliedAlpha(gl: WebGLContextAttributes, value: GLboolean): void;\r\n\r\nexport const PRESERVE_DRAWING_BUFFER_DEFAULT = false;\r\nexport declare function getPreserveDrawingBuffer(gl: WebGLContextAttributes): GLboolean;\r\nexport declare function setPreserveDrawingBuffer(gl: WebGLContextAttributes, value: GLboolean): void;\r\n\r\n// === WebGLActiveInfo ===\r\n\r\ntype WebGLActiveInfo = externref;\r\n\r\nexport declare function getSize(gl: WebGLActiveInfo): GLint;\r\nexport declare function getType(gl: WebGLActiveInfo): GLenum;\r\nexport declare function getName(gl: WebGLActiveInfo): string;\r\n\r\n// === WebGLShaderPrecisionFormat ===\r\n\r\ntype WebGLShaderPrecisionFormat = externref;\r\n\r\nexport declare function getRangeMin(gl: WebGLShaderPrecisionFormat): GLint;\r\nexport declare function getRangeMax(gl: WebGLShaderPrecisionFormat): GLint;\r\nexport declare function getPrecision(gl: WebGLShaderPrecisionFormat): GLint;\r\n\r\n// === WebGLRenderingContextId ===\r\n\r\nexport type WebGLRenderingContextId = i32;\r\n\r\n/* ClearBufferMask */\r\nexport const DEPTH_BUFFER_BIT: GLenum = 0x00000100;\r\nexport const STENCIL_BUFFER_BIT: GLenum = 0x00000400;\r\nexport const COLOR_BUFFER_BIT: GLenum = 0x00004000;\r\n\r\n/* BeginMode */\r\nexport const POINTS: GLenum = 0x0000;\r\nexport const LINES: GLenum = 0x0001;\r\nexport const LINE_LOOP: GLenum = 0x0002;\r\nexport const LINE_STRIP: GLenum = 0x0003;\r\nexport const TRIANGLES: GLenum = 0x0004;\r\nexport const TRIANGLE_STRIP: GLenum = 0x0005;\r\nexport const TRIANGLE_FAN: GLenum = 0x0006;\r\n\r\n/* AlphaFunction (not supported in ES20) */\r\n/*      NEVER */\r\n/*      LESS */\r\n/*      EQUAL */\r\n/*      LEQUAL */\r\n/*      GREATER */\r\n/*      NOTEQUAL */\r\n/*      GEQUAL */\r\n/*      ALWAYS */\r\n\r\n/* BlendingFactorDest */\r\nexport const ZERO: GLenum = 0;\r\nexport const ONE: GLenum = 1;\r\nexport const SRC_COLOR: GLenum = 0x0300;\r\nexport const ONE_MINUS_SRC_COLOR: GLenum = 0x0301;\r\nexport const SRC_ALPHA: GLenum = 0x0302;\r\nexport const ONE_MINUS_SRC_ALPHA: GLenum = 0x0303;\r\nexport const DST_ALPHA: GLenum = 0x0304;\r\nexport const ONE_MINUS_DST_ALPHA: GLenum = 0x0305;\r\n\r\n/* BlendingFactorSrc */\r\n/*      ZERO */\r\n/*      ONE */\r\nexport const DST_COLOR: GLenum = 0x0306;\r\nexport const ONE_MINUS_DST_COLOR: GLenum = 0x0307;\r\nexport const SRC_ALPHA_SATURATE: GLenum = 0x0308;\r\n/*      SRC_ALPHA */\r\n/*      ONE_MINUS_SRC_ALPHA */\r\n/*      DST_ALPHA */\r\n/*      ONE_MINUS_DST_ALPHA */\r\n\r\n/* BlendEquationSeparate */\r\nexport const FUNC_ADD: GLenum = 0x8006;\r\nexport const BLEND_EQUATION: GLenum = 0x8009;\r\nexport const BLEND_EQUATION_RGB: GLenum = 0x8009;\r\nexport const BLEND_EQUATION_ALPHA: GLenum = 0x883D;\r\n\r\n/* BlendSubtract */\r\nexport const FUNC_SUBTRACT: GLenum = 0x800A;\r\nexport const FUNC_REVERSE_SUBTRACT: GLenum = 0x800B;\r\n\r\n/* Separate Blend Functions */\r\nexport const BLEND_DST_RGB: GLenum = 0x80C8;\r\nexport const BLEND_SRC_RGB: GLenum = 0x80C9;\r\nexport const BLEND_DST_ALPHA: GLenum = 0x80CA;\r\nexport const BLEND_SRC_ALPHA: GLenum = 0x80CB;\r\nexport const CONSTANT_COLOR: GLenum = 0x8001;\r\nexport const ONE_MINUS_CONSTANT_COLOR: GLenum = 0x8002;\r\nexport const CONSTANT_ALPHA: GLenum = 0x8003;\r\nexport const ONE_MINUS_CONSTANT_ALPHA: GLenum = 0x8004;\r\nexport const BLEND_COLOR: GLenum = 0x8005;\r\n\r\n/* Buffer Objects */\r\nexport const ARRAY_BUFFER: GLenum = 0x8892;\r\nexport const ELEMENT_ARRAY_BUFFER: GLenum = 0x8893;\r\nexport const ARRAY_BUFFER_BINDING: GLenum = 0x8894;\r\nexport const ELEMENT_ARRAY_BUFFER_BINDING: GLenum = 0x8895;\r\n\r\nexport const STREAM_DRAW: GLenum = 0x88E0;\r\nexport const STATIC_DRAW: GLenum = 0x88E4;\r\nexport const DYNAMIC_DRAW: GLenum = 0x88E8;\r\n\r\nexport const BUFFER_SIZE: GLenum = 0x8764;\r\nexport const BUFFER_USAGE: GLenum = 0x8765;\r\n\r\nexport const CURRENT_VERTEX_ATTRIB: GLenum = 0x8626;\r\n\r\n/* CullFaceMode */\r\nexport const FRONT: GLenum = 0x0404;\r\nexport const BACK: GLenum = 0x0405;\r\nexport const FRONT_AND_BACK: GLenum = 0x0408;\r\n\r\n/* DepthFunction */\r\n/*      NEVER */\r\n/*      LESS */\r\n/*      EQUAL */\r\n/*      LEQUAL */\r\n/*      GREATER */\r\n/*      NOTEQUAL */\r\n/*      GEQUAL */\r\n/*      ALWAYS */\r\n\r\n/* EnableCap */\r\n/* TEXTURE_2D */\r\nexport const CULL_FACE: GLenum = 0x0B44;\r\nexport const BLEND: GLenum = 0x0BE2;\r\nexport const DITHER: GLenum = 0x0BD0;\r\nexport const STENCIL_TEST: GLenum = 0x0B90;\r\nexport const DEPTH_TEST: GLenum = 0x0B71;\r\nexport const SCISSOR_TEST: GLenum = 0x0C11;\r\nexport const POLYGON_OFFSET_FILL: GLenum = 0x8037;\r\nexport const SAMPLE_ALPHA_TO_COVERAGE: GLenum = 0x809E;\r\nexport const SAMPLE_COVERAGE: GLenum = 0x80A0;\r\n\r\n/* ErrorCode */\r\nexport const NO_ERROR: GLenum = 0;\r\nexport const INVALID_ENUM: GLenum = 0x0500;\r\nexport const INVALID_VALUE: GLenum = 0x0501;\r\nexport const INVALID_OPERATION: GLenum = 0x0502;\r\nexport const OUT_OF_MEMORY: GLenum = 0x0505;\r\n\r\n/* FrontFaceDirection */\r\nexport const CW: GLenum = 0x0900;\r\nexport const CCW: GLenum = 0x0901;\r\n\r\n/* GetPName */\r\nexport const LINE_WIDTH: GLenum = 0x0B21;\r\nexport const ALIASED_POINT_SIZE_RANGE: GLenum = 0x846D;\r\nexport const ALIASED_LINE_WIDTH_RANGE: GLenum = 0x846E;\r\nexport const CULL_FACE_MODE: GLenum = 0x0B45;\r\nexport const FRONT_FACE: GLenum = 0x0B46;\r\nexport const DEPTH_RANGE: GLenum = 0x0B70;\r\nexport const DEPTH_WRITEMASK: GLenum = 0x0B72;\r\nexport const DEPTH_CLEAR_VALUE: GLenum = 0x0B73;\r\nexport const DEPTH_FUNC: GLenum = 0x0B74;\r\nexport const STENCIL_CLEAR_VALUE: GLenum = 0x0B91;\r\nexport const STENCIL_FUNC: GLenum = 0x0B92;\r\nexport const STENCIL_FAIL: GLenum = 0x0B94;\r\nexport const STENCIL_PASS_DEPTH_FAIL: GLenum = 0x0B95;\r\nexport const STENCIL_PASS_DEPTH_PASS: GLenum = 0x0B96;\r\nexport const STENCIL_REF: GLenum = 0x0B97;\r\nexport const STENCIL_VALUE_MASK: GLenum = 0x0B93;\r\nexport const STENCIL_WRITEMASK: GLenum = 0x0B98;\r\nexport const STENCIL_BACK_FUNC: GLenum = 0x8800;\r\nexport const STENCIL_BACK_FAIL: GLenum = 0x8801;\r\nexport const STENCIL_BACK_PASS_DEPTH_FAIL: GLenum = 0x8802;\r\nexport const STENCIL_BACK_PASS_DEPTH_PASS: GLenum = 0x8803;\r\nexport const STENCIL_BACK_REF: GLenum = 0x8CA3;\r\nexport const STENCIL_BACK_VALUE_MASK: GLenum = 0x8CA4;\r\nexport const STENCIL_BACK_WRITEMASK: GLenum = 0x8CA5;\r\nexport const VIEWPORT: GLenum = 0x0BA2;\r\nexport const SCISSOR_BOX: GLenum = 0x0C10;\r\n/*      SCISSOR_TEST */\r\nexport const COLOR_CLEAR_VALUE: GLenum = 0x0C22;\r\nexport const COLOR_WRITEMASK: GLenum = 0x0C23;\r\nexport const UNPACK_ALIGNMENT: GLenum = 0x0CF5;\r\nexport const PACK_ALIGNMENT: GLenum = 0x0D05;\r\nexport const MAX_TEXTURE_SIZE: GLenum = 0x0D33;\r\nexport const MAX_VIEWPORT_DIMS: GLenum = 0x0D3A;\r\nexport const SUBPIXEL_BITS: GLenum = 0x0D50;\r\nexport const RED_BITS: GLenum = 0x0D52;\r\nexport const GREEN_BITS: GLenum = 0x0D53;\r\nexport const BLUE_BITS: GLenum = 0x0D54;\r\nexport const ALPHA_BITS: GLenum = 0x0D55;\r\nexport const DEPTH_BITS: GLenum = 0x0D56;\r\nexport const STENCIL_BITS: GLenum = 0x0D57;\r\nexport const POLYGON_OFFSET_UNITS: GLenum = 0x2A00;\r\n/*      POLYGON_OFFSET_FILL */\r\nexport const POLYGON_OFFSET_FACTOR: GLenum = 0x8038;\r\nexport const TEXTURE_BINDING_2D: GLenum = 0x8069;\r\nexport const SAMPLE_BUFFERS: GLenum = 0x80A8;\r\nexport const SAMPLES: GLenum = 0x80A9;\r\nexport const SAMPLE_COVERAGE_VALUE: GLenum = 0x80AA;\r\nexport const SAMPLE_COVERAGE_INVERT: GLenum = 0x80AB;\r\n\r\n/* GetTextureParameter */\r\n/*      TEXTURE_MAG_FILTER */\r\n/*      TEXTURE_MIN_FILTER */\r\n/*      TEXTURE_WRAP_S */\r\n/*      TEXTURE_WRAP_T */\r\n\r\nexport const COMPRESSED_TEXTURE_FORMATS: GLenum = 0x86A3;\r\n\r\n/* HintMode */\r\nexport const DONT_CARE: GLenum = 0x1100;\r\nexport const FASTEST: GLenum = 0x1101;\r\nexport const NICEST: GLenum = 0x1102;\r\n\r\n/* HintTarget */\r\nexport const GENERATE_MIPMAP_HINT: GLenum = 0x8192;\r\n\r\n/* DataType */\r\nexport const BYTE: GLenum = 0x1400;\r\nexport const UNSIGNED_BYTE: GLenum = 0x1401;\r\nexport const SHORT: GLenum = 0x1402;\r\nexport const UNSIGNED_SHORT: GLenum = 0x1403;\r\nexport const INT: GLenum = 0x1404;\r\nexport const UNSIGNED_INT: GLenum = 0x1405;\r\nexport const FLOAT: GLenum = 0x1406;\r\n\r\n/* PixelFormat */\r\nexport const DEPTH_COMPONENT: GLenum = 0x1902;\r\nexport const ALPHA: GLenum = 0x1906;\r\nexport const RGB: GLenum = 0x1907;\r\nexport const RGBA: GLenum = 0x1908;\r\nexport const LUMINANCE: GLenum = 0x1909;\r\nexport const LUMINANCE_ALPHA: GLenum = 0x190A;\r\n\r\n/* PixelType */\r\n/*      UNSIGNED_BYTE */\r\nexport const UNSIGNED_SHORT_4_4_4_4: GLenum = 0x8033;\r\nexport const UNSIGNED_SHORT_5_5_5_1: GLenum = 0x8034;\r\nexport const UNSIGNED_SHORT_5_6_5: GLenum = 0x8363;\r\n\r\n/* Shaders */\r\nexport const FRAGMENT_SHADER: GLenum = 0x8B30;\r\nexport const VERTEX_SHADER: GLenum = 0x8B31;\r\nexport const MAX_VERTEX_ATTRIBS: GLenum = 0x8869;\r\nexport const MAX_VERTEX_UNIFORM_VECTORS: GLenum = 0x8DFB;\r\nexport const MAX_VARYING_VECTORS: GLenum = 0x8DFC;\r\nexport const MAX_COMBINED_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4D;\r\nexport const MAX_VERTEX_TEXTURE_IMAGE_UNITS: GLenum = 0x8B4C;\r\nexport const MAX_TEXTURE_IMAGE_UNITS: GLenum = 0x8872;\r\nexport const MAX_FRAGMENT_UNIFORM_VECTORS: GLenum = 0x8DFD;\r\nexport const SHADER_TYPE: GLenum = 0x8B4F;\r\nexport const DELETE_STATUS: GLenum = 0x8B80;\r\nexport const LINK_STATUS: GLenum = 0x8B82;\r\nexport const VALIDATE_STATUS: GLenum = 0x8B83;\r\nexport const ATTACHED_SHADERS: GLenum = 0x8B85;\r\nexport const ACTIVE_UNIFORMS: GLenum = 0x8B86;\r\nexport const ACTIVE_ATTRIBUTES: GLenum = 0x8B89;\r\nexport const SHADING_LANGUAGE_VERSION: GLenum = 0x8B8C;\r\nexport const CURRENT_PROGRAM: GLenum = 0x8B8D;\r\n\r\n/* StencilFunction */\r\nexport const NEVER: GLenum = 0x0200;\r\nexport const LESS: GLenum = 0x0201;\r\nexport const EQUAL: GLenum = 0x0202;\r\nexport const LEQUAL: GLenum = 0x0203;\r\nexport const GREATER: GLenum = 0x0204;\r\nexport const NOTEQUAL: GLenum = 0x0205;\r\nexport const GEQUAL: GLenum = 0x0206;\r\nexport const ALWAYS: GLenum = 0x0207;\r\n\r\n/* StencilOp */\r\n/*      ZERO */\r\nexport const KEEP: GLenum = 0x1E00;\r\nexport const REPLACE: GLenum = 0x1E01;\r\nexport const INCR: GLenum = 0x1E02;\r\nexport const DECR: GLenum = 0x1E03;\r\nexport const INVERT: GLenum = 0x150A;\r\nexport const INCR_WRAP: GLenum = 0x8507;\r\nexport const DECR_WRAP: GLenum = 0x8508;\r\n\r\n/* StringName */\r\nexport const VENDOR: GLenum = 0x1F00;\r\nexport const RENDERER: GLenum = 0x1F01;\r\nexport const VERSION: GLenum = 0x1F02;\r\n\r\n/* TextureMagFilter */\r\nexport const NEAREST: GLenum = 0x2600;\r\nexport const LINEAR: GLenum = 0x2601;\r\n\r\n/* TextureMinFilter */\r\n/*      NEAREST */\r\n/*      LINEAR */\r\nexport const NEAREST_MIPMAP_NEAREST: GLenum = 0x2700;\r\nexport const LINEAR_MIPMAP_NEAREST: GLenum = 0x2701;\r\nexport const NEAREST_MIPMAP_LINEAR: GLenum = 0x2702;\r\nexport const LINEAR_MIPMAP_LINEAR: GLenum = 0x2703;\r\n\r\n/* TextureParameterName */\r\nexport const TEXTURE_MAG_FILTER: GLenum = 0x2800;\r\nexport const TEXTURE_MIN_FILTER: GLenum = 0x2801;\r\nexport const TEXTURE_WRAP_S: GLenum = 0x2802;\r\nexport const TEXTURE_WRAP_T: GLenum = 0x2803;\r\n\r\n/* TextureTarget */\r\nexport const TEXTURE_2D: GLenum = 0x0DE1;\r\nexport const TEXTURE: GLenum = 0x1702;\r\n\r\nexport const TEXTURE_CUBE_MAP: GLenum = 0x8513;\r\nexport const TEXTURE_BINDING_CUBE_MAP: GLenum = 0x8514;\r\nexport const TEXTURE_CUBE_MAP_POSITIVE_X: GLenum = 0x8515;\r\nexport const TEXTURE_CUBE_MAP_NEGATIVE_X: GLenum = 0x8516;\r\nexport const TEXTURE_CUBE_MAP_POSITIVE_Y: GLenum = 0x8517;\r\nexport const TEXTURE_CUBE_MAP_NEGATIVE_Y: GLenum = 0x8518;\r\nexport const TEXTURE_CUBE_MAP_POSITIVE_Z: GLenum = 0x8519;\r\nexport const TEXTURE_CUBE_MAP_NEGATIVE_Z: GLenum = 0x851A;\r\nexport const MAX_CUBE_MAP_TEXTURE_SIZE: GLenum = 0x851C;\r\n\r\n/* TextureUnit */\r\nexport const TEXTURE0: GLenum = 0x84C0;\r\nexport const TEXTURE1: GLenum = 0x84C1;\r\nexport const TEXTURE2: GLenum = 0x84C2;\r\nexport const TEXTURE3: GLenum = 0x84C3;\r\nexport const TEXTURE4: GLenum = 0x84C4;\r\nexport const TEXTURE5: GLenum = 0x84C5;\r\nexport const TEXTURE6: GLenum = 0x84C6;\r\nexport const TEXTURE7: GLenum = 0x84C7;\r\nexport const TEXTURE8: GLenum = 0x84C8;\r\nexport const TEXTURE9: GLenum = 0x84C9;\r\nexport const TEXTURE10: GLenum = 0x84CA;\r\nexport const TEXTURE11: GLenum = 0x84CB;\r\nexport const TEXTURE12: GLenum = 0x84CC;\r\nexport const TEXTURE13: GLenum = 0x84CD;\r\nexport const TEXTURE14: GLenum = 0x84CE;\r\nexport const TEXTURE15: GLenum = 0x84CF;\r\nexport const TEXTURE16: GLenum = 0x84D0;\r\nexport const TEXTURE17: GLenum = 0x84D1;\r\nexport const TEXTURE18: GLenum = 0x84D2;\r\nexport const TEXTURE19: GLenum = 0x84D3;\r\nexport const TEXTURE20: GLenum = 0x84D4;\r\nexport const TEXTURE21: GLenum = 0x84D5;\r\nexport const TEXTURE22: GLenum = 0x84D6;\r\nexport const TEXTURE23: GLenum = 0x84D7;\r\nexport const TEXTURE24: GLenum = 0x84D8;\r\nexport const TEXTURE25: GLenum = 0x84D9;\r\nexport const TEXTURE26: GLenum = 0x84DA;\r\nexport const TEXTURE27: GLenum = 0x84DB;\r\nexport const TEXTURE28: GLenum = 0x84DC;\r\nexport const TEXTURE29: GLenum = 0x84DD;\r\nexport const TEXTURE30: GLenum = 0x84DE;\r\nexport const TEXTURE31: GLenum = 0x84DF;\r\nexport const ACTIVE_TEXTURE: GLenum = 0x84E0;\r\n\r\n/* TextureWrapMode */\r\nexport const REPEAT: GLenum = 0x2901;\r\nexport const CLAMP_TO_EDGE: GLenum = 0x812F;\r\nexport const MIRRORED_REPEAT: GLenum = 0x8370;\r\n\r\n/* Uniform Types */\r\nexport const FLOAT_VEC2: GLenum = 0x8B50;\r\nexport const FLOAT_VEC3: GLenum = 0x8B51;\r\nexport const FLOAT_VEC4: GLenum = 0x8B52;\r\nexport const INT_VEC2: GLenum = 0x8B53;\r\nexport const INT_VEC3: GLenum = 0x8B54;\r\nexport const INT_VEC4: GLenum = 0x8B55;\r\nexport const BOOL: GLenum = 0x8B56;\r\nexport const BOOL_VEC2: GLenum = 0x8B57;\r\nexport const BOOL_VEC3: GLenum = 0x8B58;\r\nexport const BOOL_VEC4: GLenum = 0x8B59;\r\nexport const FLOAT_MAT2: GLenum = 0x8B5A;\r\nexport const FLOAT_MAT3: GLenum = 0x8B5B;\r\nexport const FLOAT_MAT4: GLenum = 0x8B5C;\r\nexport const SAMPLER_2D: GLenum = 0x8B5E;\r\nexport const SAMPLER_CUBE: GLenum = 0x8B60;\r\n\r\n/* Vertex Arrays */\r\nexport const VERTEX_ATTRIB_ARRAY_ENABLED: GLenum = 0x8622;\r\nexport const VERTEX_ATTRIB_ARRAY_SIZE: GLenum = 0x8623;\r\nexport const VERTEX_ATTRIB_ARRAY_STRIDE: GLenum = 0x8624;\r\nexport const VERTEX_ATTRIB_ARRAY_TYPE: GLenum = 0x8625;\r\nexport const VERTEX_ATTRIB_ARRAY_NORMALIZED: GLenum = 0x886A;\r\nexport const VERTEX_ATTRIB_ARRAY_POINTER: GLenum = 0x8645;\r\nexport const VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: GLenum = 0x889F;\r\n\r\n/* Shader Source */\r\nexport const COMPILE_STATUS: GLenum = 0x8B81;\r\n\r\n/* Shader Precision-Specified Types */\r\nexport const LOW_FLOAT: GLenum = 0x8DF0;\r\nexport const MEDIUM_FLOAT: GLenum = 0x8DF1;\r\nexport const HIGH_FLOAT: GLenum = 0x8DF2;\r\nexport const LOW_INT: GLenum = 0x8DF3;\r\nexport const MEDIUM_INT: GLenum = 0x8DF4;\r\nexport const HIGH_INT: GLenum = 0x8DF5;\r\n\r\n/* Framebuffer Object. */\r\nexport const FRAMEBUFFER: GLenum = 0x8D40;\r\nexport const RENDERBUFFER: GLenum = 0x8D41;\r\n\r\nexport const RGBA4: GLenum = 0x8056;\r\nexport const RGB5_A1: GLenum = 0x8057;\r\nexport const RGB565: GLenum = 0x8D62;\r\nexport const DEPTH_COMPONENT16: GLenum = 0x81A5;\r\nexport const STENCIL_INDEX: GLenum = 0x1901;\r\nexport const STENCIL_INDEX8: GLenum = 0x8D48;\r\nexport const DEPTH_STENCIL: GLenum = 0x84F9;\r\n\r\nexport const RENDERBUFFER_WIDTH: GLenum = 0x8D42;\r\nexport const RENDERBUFFER_HEIGHT: GLenum = 0x8D43;\r\nexport const RENDERBUFFER_INTERNAL_FORMAT: GLenum = 0x8D44;\r\nexport const RENDERBUFFER_RED_SIZE: GLenum = 0x8D50;\r\nexport const RENDERBUFFER_GREEN_SIZE: GLenum = 0x8D51;\r\nexport const RENDERBUFFER_BLUE_SIZE: GLenum = 0x8D52;\r\nexport const RENDERBUFFER_ALPHA_SIZE: GLenum = 0x8D53;\r\nexport const RENDERBUFFER_DEPTH_SIZE: GLenum = 0x8D54;\r\nexport const RENDERBUFFER_STENCIL_SIZE: GLenum = 0x8D55;\r\n\r\nexport const FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: GLenum = 0x8CD0;\r\nexport const FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: GLenum = 0x8CD1;\r\nexport const FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: GLenum = 0x8CD2;\r\nexport const FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: GLenum = 0x8CD3;\r\n\r\nexport const COLOR_ATTACHMENT0: GLenum = 0x8CE0;\r\nexport const DEPTH_ATTACHMENT: GLenum = 0x8D00;\r\nexport const STENCIL_ATTACHMENT: GLenum = 0x8D20;\r\nexport const DEPTH_STENCIL_ATTACHMENT: GLenum = 0x821A;\r\n\r\nexport const NONE: GLenum = 0;\r\n\r\nexport const FRAMEBUFFER_COMPLETE: GLenum = 0x8CD5;\r\nexport const FRAMEBUFFER_INCOMPLETE_ATTACHMENT: GLenum = 0x8CD6;\r\nexport const FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: GLenum = 0x8CD7;\r\nexport const FRAMEBUFFER_INCOMPLETE_DIMENSIONS: GLenum = 0x8CD9;\r\nexport const FRAMEBUFFER_UNSUPPORTED: GLenum = 0x8CDD;\r\n\r\nexport const FRAMEBUFFER_BINDING: GLenum = 0x8CA6;\r\nexport const RENDERBUFFER_BINDING: GLenum = 0x8CA7;\r\nexport const MAX_RENDERBUFFER_SIZE: GLenum = 0x84E8;\r\n\r\nexport const INVALID_FRAMEBUFFER_OPERATION: GLenum = 0x0506;\r\n\r\n/* WebGL-specific enums */\r\nexport const UNPACK_FLIP_Y_WEBGL: GLenum = 0x9240;\r\nexport const UNPACK_PREMULTIPLY_ALPHA_WEBGL: GLenum = 0x9241;\r\nexport const CONTEXT_LOST_WEBGL: GLenum = 0x9242;\r\nexport const UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;\r\nexport const BROWSER_DEFAULT_WEBGL: GLenum = 0x9244;\r\n\r\n//type HTMLCanvasElement = externref;\r\n\r\n//export declare function getCanvas(gl: WebGLRenderingContextId): HTMLCanvasElement;\r\nexport declare function getDrawingBufferWidth(gl: WebGLRenderingContextId): GLsizei;\r\nexport declare function getDrawingBufferHeight(gl: WebGLRenderingContextId): GLsizei;\r\n\r\nexport declare function getContextAttributes(gl: WebGLRenderingContextId): WebGLContextAttributes;\r\nexport declare function isContextLost(gl: WebGLRenderingContextId): bool;\r\n\r\ntype sequence<T> = externref;\r\n\r\nexport declare function getSupportedExtensions(gl: WebGLRenderingContextId): sequence<string>;\r\n\r\ntype object_ = externref;\r\n\r\nexport declare function getExtension(gl: WebGLRenderingContextId, name: string): void;\r\n\r\n// THIS WILL BE IN INDEX INTO A PROGRAM LIST KEPT IN THE JS\r\nexport type WebGLProgram = i32; //externref;\r\nexport type WebGLShader = i32;\r\nexport type WebGLBuffer = i32;\r\nexport type WebGLFramebuffer = i32;\r\nexport type WebGLRenderbuffer = i32;\r\nexport type WebGLTexture = i32;\r\n\r\nexport declare function activeTexture(gl: WebGLRenderingContextId, texture: GLenum): void;\r\nexport declare function createContextFromCanvas(canvas_id: string, context_type: string): WebGLRenderingContextId;\r\nexport declare function attachShader(gl: WebGLRenderingContextId, program: WebGLProgram, shader: WebGLShader): void;\r\n// export declare function bindAttribLocation(gl: WebGLRenderingContextId, program: WebGLProgram, index: GLuint, name: string): void;\r\nexport declare function bindBuffer(gl: WebGLRenderingContextId, target: GLenum, buffer: WebGLBuffer): void;\r\nexport declare function bindFramebuffer(gl: WebGLRenderingContextId, target: GLenum, framebuffer: WebGLFramebuffer): void;\r\nexport declare function bindRenderbuffer(gl: WebGLRenderingContextId, target: GLenum, renderbuffer: WebGLRenderbuffer): void;\r\nexport declare function bindTexture(gl: WebGLRenderingContextId, target: GLenum, texture: WebGLTexture): void;\r\nexport declare function blendColor(gl: WebGLRenderingContextId, red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;\r\nexport declare function blendEquation(gl: WebGLRenderingContextId, mode: GLenum): void;\r\nexport declare function blendEquationSeparate(gl: WebGLRenderingContextId, modeRGB: GLenum, modeAlpha: GLenum): void;\r\nexport declare function blendFunc(gl: WebGLRenderingContextId, sfactor: GLenum, dfactor: GLenum): void;\r\nexport declare function blendFuncSeparate(gl: WebGLRenderingContextId, srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void;\r\nexport declare function bufferData<T>(gl: WebGLRenderingContextId, target: GLenum, data: StaticArray<T>, usage: GLenum): void;\r\nexport declare function bufferSubData<T>(gl: WebGLRenderingContextId, target: GLenum, offset: GLintptr, data: Array<T>): void;\r\n\r\nexport declare function checkFramebufferStatus(gl: WebGLRenderingContextId, target: GLenum): GLenum;\r\nexport declare function clear(gl: WebGLRenderingContextId, mask: GLbitfield): void;\r\nexport declare function clearColor(gl: WebGLRenderingContextId, red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void;\r\nexport declare function clearDepth(gl: WebGLRenderingContextId, depth: GLclampf): void;\r\nexport declare function clearStencil(gl: WebGLRenderingContextId, s: GLint): void;\r\nexport declare function colorMask(gl: WebGLRenderingContextId, red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void;\r\nexport declare function compileShader(gl: WebGLRenderingContextId, shader: WebGLShader): void;\r\n\r\nexport declare function compressedTexImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView): void;\r\nexport declare function compressedTexSubImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView): void;\r\n\r\nexport declare function copyTexImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void;\r\nexport declare function copyTexSubImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\r\n\r\nexport declare function createBuffer(gl: WebGLRenderingContextId): WebGLBuffer;\r\nexport declare function createFramebuffer(gl: WebGLRenderingContextId): WebGLFramebuffer;\r\nexport declare function createProgram(gl: WebGLRenderingContextId): WebGLProgram;\r\nexport declare function createRenderbuffer(gl: WebGLRenderingContextId): WebGLRenderbuffer;\r\nexport declare function createShader(gl: WebGLRenderingContextId, typ: GLenum): WebGLShader;\r\nexport declare function createTexture(gl: WebGLRenderingContextId): WebGLTexture;\r\n\r\nexport declare function cullFace(gl: WebGLRenderingContextId, mode: GLenum): void;\r\n//...\r\n\r\nexport declare function deleteBuffer(gl: WebGLRenderingContextId, buffer: WebGLBuffer): void;\r\nexport declare function deleteFramebuffer(gl: WebGLRenderingContextId, framebuffer: WebGLFramebuffer): void;\r\nexport declare function deleteProgram(gl: WebGLRenderingContextId, program: WebGLProgram): void;\r\nexport declare function deleteRenderbuffer(gl: WebGLRenderingContextId, renderbuffer: WebGLRenderbuffer): void;\r\nexport declare function deleteShader(gl: WebGLRenderingContextId, shader: WebGLShader): void;\r\nexport declare function deleteTexture(gl: WebGLRenderingContextId, texture: WebGLTexture): void;\r\n\r\nexport declare function depthFunc(gl: WebGLRenderingContextId, func: GLenum): void;\r\nexport declare function depthMask(gl: WebGLRenderingContextId, flag: GLboolean): void;\r\nexport declare function depthRange(gl: WebGLRenderingContextId, zNear: GLclampf, zFar: GLclampf): void;\r\nexport declare function detachShader(gl: WebGLRenderingContextId, program: WebGLProgram, shader: WebGLShader): void;\r\nexport declare function disable(gl: WebGLRenderingContextId, cap: GLenum): void;\r\nexport declare function disableVertexAttribArray(gl: WebGLRenderingContextId, index: GLuint): void;\r\nexport declare function drawArrays(gl: WebGLRenderingContextId, mode: GLenum, first: GLint, count: GLsizei): void;\r\nexport declare function drawElements(gl: WebGLRenderingContextId, mode: GLenum, count: GLsizei, typ: GLenum, offset: GLintptr): void;\r\n\r\nexport declare function enable(gl: WebGLRenderingContextId, cap: GLenum): void;\r\nexport declare function enableVertexAttribArray(gl: WebGLRenderingContextId, index: GLuint): void;\r\nexport declare function finish(gl: WebGLRenderingContextId): void;\r\nexport declare function flush(gl: WebGLRenderingContextId): void;\r\nexport declare function framebufferRenderbuffer(gl: WebGLRenderingContextId, target: GLenum, attachment: GLenum,\r\n    renderbuffertarget: GLenum,\r\n    renderbuffer: WebGLRenderbuffer): void;\r\nexport declare function framebufferTexture2D(gl: WebGLRenderingContextId, target: GLenum, attachment: GLenum, textarget: GLenum,\r\n    texture: WebGLTexture, level: GLint): void;\r\nexport declare function frontFace(gl: WebGLRenderingContextId, mode: GLenum): void;\r\n\r\nexport declare function generateMipmap(gl: WebGLRenderingContextId, target: GLenum): void;\r\n\r\nexport declare function getActiveAttrib(gl: WebGLRenderingContextId, program: WebGLProgram, index: GLuint): WebGLActiveInfo;\r\nexport declare function getActiveUniform(gl: WebGLRenderingContextId, program: WebGLProgram, index: GLuint): WebGLActiveInfo;\r\nexport declare function getAttachedShaders(gl: WebGLRenderingContextId, program: WebGLProgram): sequence<WebGLShader>;\r\n\r\nexport declare function getAttribLocation(gl: WebGLRenderingContextId, program: WebGLProgram, name: string): GLint;\r\n\r\nexport declare function getBufferParameter(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum): externref; // any\r\nexport declare function getParameter(gl: WebGLRenderingContextId, pname: GLenum): externref; // any\r\n\r\nexport declare function getError(gl: WebGLRenderingContextId): GLenum;\r\n\r\nexport declare function getFramebufferAttachmentParameter(gl: WebGLRenderingContextId, target: GLenum, attachment: GLenum,\r\n    pname: GLenum): externref; // any\r\nexport declare function getProgramParameter(gl: WebGLRenderingContextId, program: WebGLProgram, pname: GLenum): bool; // any\r\nexport declare function getProgramInfoLog(gl: WebGLRenderingContextId, program: WebGLProgram): DOMString;\r\nexport declare function getRenderbufferParameter(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum): externref; // any\r\nexport declare function getShaderParameter(gl: WebGLRenderingContextId, shader: WebGLShader, pname: GLenum): bool; // any\r\nexport declare function getShaderPrecisionFormat(gl: WebGLRenderingContextId, shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat;\r\nexport declare function getShaderInfoLog(gl: WebGLRenderingContextId, shader: WebGLShader): DOMString;\r\n\r\nexport declare function getShaderSource(gl: WebGLRenderingContextId, shader: WebGLShader): DOMString;\r\n\r\nexport declare function getTexParameter(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum): externref; // any\r\n\r\nexport declare function getUniform(gl: WebGLRenderingContextId, program: WebGLProgram, location: WebGLUniformLocation): externref; // any\r\n\r\nexport declare function getUniformLocation(gl: WebGLRenderingContextId, program: WebGLProgram, name: string): WebGLUniformLocation;\r\n\r\nexport declare function getVertexAttrib(gl: WebGLRenderingContextId, index: GLuint, pname: GLenum): externref; // any\r\n\r\nexport declare function getVertexAttribOffset(gl: WebGLRenderingContextId, index: GLuint, pname: GLenum): GLsizeiptr;\r\n\r\nexport declare function hint(gl: WebGLRenderingContextId, target: GLenum, mode: GLenum): void;\r\nexport declare function isBuffer(gl: WebGLRenderingContextId, buffer: WebGLBuffer): GLboolean;\r\nexport declare function isEnabled(gl: WebGLRenderingContextId, cap: GLenum): GLboolean;\r\nexport declare function isFramebuffer(gl: WebGLRenderingContextId, framebuffer: WebGLFramebuffer): GLboolean;\r\nexport declare function isProgram(gl: WebGLRenderingContextId, program: WebGLProgram): GLboolean;\r\nexport declare function isRenderbuffer(gl: WebGLRenderingContextId, renderbuffer: WebGLRenderbuffer): GLboolean;\r\nexport declare function isShader(gl: WebGLRenderingContextId, shader: WebGLShader): GLboolean;\r\nexport declare function isTexture(gl: WebGLRenderingContextId, texture: WebGLTexture): GLboolean;\r\nexport declare function lineWidth(gl: WebGLRenderingContextId, width: GLfloat): void;\r\nexport declare function linkProgram(gl: WebGLRenderingContextId, program: WebGLProgram): void;\r\nexport declare function pixelStorei(gl: WebGLRenderingContextId, pname: GLenum, param: GLint): void;\r\nexport declare function polygonOffset(gl: WebGLRenderingContextId, factor: GLfloat, units: GLfloat): void;\r\n\r\nexport declare function readPixels(gl: WebGLRenderingContextId, x: GLint, y: GLint, width: GLsizei, height: GLsizei,\r\n    format: GLenum, typ: GLenum, pixels: ArrayBufferView): void;\r\n\r\nexport declare function renderbufferStorage(gl: WebGLRenderingContextId, target: GLenum, internalformat: GLenum,\r\n    width: GLsizei, height: GLsizei): void;\r\nexport declare function sampleCoverage(gl: WebGLRenderingContextId, value: GLclampf, invert: GLboolean): void;\r\nexport declare function scissor(gl: WebGLRenderingContextId, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\r\n\r\nexport declare function shaderSource(gl: WebGLRenderingContextId, shader: WebGLShader, source: string): void;\r\n\r\nexport declare function stencilFunc(gl: WebGLRenderingContextId, func: GLenum, ref: GLint, mask: GLuint): void;\r\nexport declare function stencilFuncSeparate(gl: WebGLRenderingContextId, face: GLenum, func: GLenum, ref: GLint, mask: GLuint): void;\r\nexport declare function stencilMask(gl: WebGLRenderingContextId, mask: GLuint): void;\r\nexport declare function stencilMaskSeparate(gl: WebGLRenderingContextId, face: GLenum, mask: GLuint): void;\r\nexport declare function stencilOp(gl: WebGLRenderingContextId, fail: GLenum, zfail: GLenum, zpass: GLenum): void;\r\nexport declare function stencilOpSeparate(gl: WebGLRenderingContextId, face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum): void;\r\n\r\nexport declare function texImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, internalformat: GLenum,\r\n    format: GLenum, typ: GLenum, image: ImageData): void;\r\n\r\nexport declare function texParameterf(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum, param: GLfloat): void;\r\nexport declare function texParameteri(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum, param: GLint): void;\r\n\r\nexport declare function texSubImage2D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,\r\n    format: GLenum, typ: GLenum, pixels: ImageData): void;\r\n\r\nexport declare function uniform1f(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLfloat): void;\r\nexport declare function uniform1fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLfloat>/*Float32Array*/): void;\r\n\r\nexport declare function uniform1i(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLint): void;\r\nexport declare function uniform1iv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLint>/*Int32Array*/): void;\r\n\r\nexport declare function uniform2f(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLfloat, y: GLfloat): void;\r\nexport declare function uniform2fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLfloat>/*Float32Array*/): void;\r\n\r\nexport declare function uniform2i(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLint, y: GLint): void;\r\nexport declare function uniform2iv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLint> /*Int32Array*/): void;\r\n\r\nexport declare function uniform3f(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat): void;\r\nexport declare function uniform3fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLfloat>/*Float32Array*/): void;\r\n\r\nexport declare function uniform3i(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint): void;\r\nexport declare function uniform3iv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLint>/*Int32Array*/): void;\r\n\r\nexport declare function uniform4f(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;\r\nexport declare function uniform4fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLfloat>/*JSFloat32Array*/): void;\r\n\r\nexport declare function uniform4i(gl: WebGLRenderingContextId, location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint, w: GLint): void;\r\nexport declare function uniform4iv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v: StaticArray<GLint>/*JSInt32Array*/): void;\r\n\r\nexport declare function uniformMatrix2fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\r\n    value: StaticArray<GLfloat>): void;\r\n/*\r\nexport declare function uniformMatrix2fv( gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\r\n    value: sequence<GLfloat>): void;\r\n*/\r\nexport declare function uniformMatrix3fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\r\n    value: StaticArray<GLfloat>): void;\r\n/*\r\nexport declare function uniformMatrix3fv( gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\r\n    value: sequence<GLfloat>): void;\r\n*/\r\nexport declare function uniformMatrix4fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\r\n    value: StaticArray<GLfloat>): void;\r\n/*\r\nexport declare function uniformMatrix4fv( gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean,\r\n    value: sequence<GLfloat>): void;\r\n*/\r\nexport declare function useProgram(gl: WebGLRenderingContextId, program: WebGLProgram): void;\r\nexport declare function validateProgram(gl: WebGLRenderingContextId, program: WebGLProgram): void;\r\n\r\nexport declare function vertexAttrib1f(gl: WebGLRenderingContextId, indx: GLuint, x: GLfloat): void;\r\nexport declare function vertexAttrib1fv(gl: WebGLRenderingContextId, indx: GLuint, values: StaticArray<GLfloat>): void;\r\n\r\nexport declare function vertexAttrib2f(gl: WebGLRenderingContextId, indx: GLuint, x: GLfloat, y: GLfloat): void;\r\nexport declare function vertexAttrib2fv(gl: WebGLRenderingContextId, indx: GLuint, values: StaticArray<GLfloat>): void;\r\n\r\nexport declare function vertexAttrib3f(gl: WebGLRenderingContextId, indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void;\r\nexport declare function vertexAttrib3fv(gl: WebGLRenderingContextId, indx: GLuint, values: StaticArray<GLfloat>): void;\r\n\r\nexport declare function vertexAttrib4f(gl: WebGLRenderingContextId, indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void;\r\nexport declare function vertexAttrib4fv(gl: WebGLRenderingContextId, indx: GLuint, values: StaticArray<GLfloat>): void;\r\n\r\nexport declare function vertexAttribPointer(gl: WebGLRenderingContextId, indx: GLint, size: GLint, typ: GLenum,\r\n    normalized: /*GLboolean*/GLint, stride: GLsizei, offset: GLintptr): void;\r\n\r\nexport declare function viewport(gl: WebGLRenderingContextId, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\r\n\r\n// ... WEBGL 2 ...\r\n/* Buffer objects */\r\nexport declare function copyBufferSubData(gl: WebGLRenderingContextId, readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr,\r\n    writeOffset: GLintptr, size: GLsizeiptr): void;\r\n\r\n// @ts-ignore\r\nexport declare function getBufferSubData(gl: WebGLRenderingContextId, target: GLenum, srcByteOffset: GLintptr, /*[AllowShared]*/ dstBuffer: ArrayBufferView, dstOffset: GLuint = 0, length: GLuint = 0): void;\r\n\r\n/* Framebuffer objects */\r\nexport declare function blitFramebuffer(gl: WebGLRenderingContextId, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint, dstX0: GLint, dstY0: GLint,\r\n    dstX1: GLint, dstY1: GLint, mask: GLbitfield, filter: GLenum): void;\r\nexport declare function framebufferTextureLayer(gl: WebGLRenderingContextId, target: GLenum, attachment: GLenum, texture: WebGLTexture, level: GLint,\r\n    layer: GLint): void;\r\nexport declare function invalidateFramebuffer(gl: WebGLRenderingContextId, target: GLenum, attachments: sequence<GLenum>): void;\r\nexport declare function invalidateSubFramebuffer(gl: WebGLRenderingContextId, target: GLenum, attachments: sequence<GLenum>,\r\n    x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\r\nexport declare function readBuffer(gl: WebGLRenderingContextId, src: GLenum): void;\r\n\r\n/* Renderbuffer objects */\r\nexport declare function getInternalformatParameter(gl: WebGLRenderingContextId, target: GLenum, internalformat: GLenum, pname: GLenum): externref; // any\r\nexport declare function renderbufferStorageMultisample(gl: WebGLRenderingContextId, target: GLenum, samples: GLsizei, internalformat: GLenum,\r\n    width: GLsizei, height: GLsizei): void;\r\n\r\n/* Texture objects */\r\nexport declare function texStorage2D(gl: WebGLRenderingContextId, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei,\r\n    height: GLsizei): void;\r\nexport declare function texStorage3D(gl: WebGLRenderingContextId, target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei,\r\n    height: GLsizei, depth: GLsizei): void;\r\n\r\nexport declare function texImage3D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei,\r\n    depth: GLsizei, border: GLint, format: GLenum, typ: GLenum, pboOffset: GLintptr): void;\r\n\r\nexport declare function texSubImage3D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint,\r\n    width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, typ: GLenum,\r\n    pboOffset: GLintptr): void;\r\n\r\nexport declare function copyTexSubImage3D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint,\r\n    x: GLint, y: GLint, width: GLsizei, height: GLsizei): void;\r\n\r\nexport declare function compressedTexImage3D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei,\r\n    height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr): void;\r\n\r\nexport declare function compressedTexSubImage3D(gl: WebGLRenderingContextId, target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,\r\n    zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei,\r\n    format: GLenum, imageSize: GLsizei, offset: GLintptr): void;\r\n\r\n/* Programs and shaders */\r\nexport declare function getFragDataLocation(gl: WebGLRenderingContextId, program: WebGLProgram, name: DOMString): GLint;\r\n\r\n/* Uniforms */\r\nexport declare function uniform1ui(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v0: GLuint): void;\r\nexport declare function uniform2ui(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v0: GLuint, v1: GLuint): void;\r\nexport declare function uniform3ui(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint): void;\r\nexport declare function uniform4ui(gl: WebGLRenderingContextId, location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void;\r\n\r\n// @ts-ignore\r\nexport declare function uniform1uiv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\r\n// @ts-ignore\r\nexport declare function uniform2uiv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\r\n// @ts-ignore\r\nexport declare function uniform3uiv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\r\n// @ts-ignore\r\nexport declare function uniform4uiv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\r\n// @ts-ignore\r\nexport declare function uniformMatrix3x2fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\r\n// @ts-ignore\r\nexport declare function uniformMatrix4x2fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\r\n\r\n// @ts-ignore\r\nexport declare function uniformMatrix2x3fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\r\n// @ts-ignore\r\nexport declare function uniformMatrix4x3fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\r\n\r\n// @ts-ignore\r\nexport declare function uniformMatrix2x4fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\r\n// @ts-ignore\r\nexport declare function uniformMatrix3x4fv(gl: WebGLRenderingContextId, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void;\r\n\r\n/* Vertex attribs */\r\nexport declare function vertexAttribI4i(gl: WebGLRenderingContextId, index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint): void;\r\nexport declare function vertexAttribI4iv(gl: WebGLRenderingContextId, index: GLuint, values: Int32List): void;\r\nexport declare function vertexAttribI4ui(gl: WebGLRenderingContextId, index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint): void;\r\nexport declare function vertexAttribI4uiv(gl: WebGLRenderingContextId, index: GLuint, values: Uint32List): void;\r\nexport declare function vertexAttribIPointer(gl: WebGLRenderingContextId, index: GLuint, size: GLint, typ: GLenum, stride: GLsizei, offset: GLintptr): void;\r\n\r\n/* Writing to the drawing buffer */\r\nexport declare function vertexAttribDivisor(gl: WebGLRenderingContextId, index: GLuint, divisor: GLuint): void;\r\nexport declare function drawArraysInstanced(gl: WebGLRenderingContextId, mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei): void;\r\nexport declare function drawElementsInstanced(gl: WebGLRenderingContextId, mode: GLenum, count: GLsizei, typ: GLenum, offset: GLintptr, instanceCount: GLsizei): void;\r\nexport declare function drawRangeElements(gl: WebGLRenderingContextId, mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, typ: GLenum, offset: GLintptr): void;\r\n\r\n/* Multiple Render Targets */\r\nexport declare function drawBuffers(gl: WebGLRenderingContextId, buffers: sequence<GLenum>): void;\r\n\r\n// @ts-ignore\r\nexport declare function clearBufferfv(gl: WebGLRenderingContextId, buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset: GLuint = 0): void;\r\n// @ts-ignore\r\nexport declare function clearBufferiv(gl: WebGLRenderingContextId, buffer: GLenum, drawbuffer: GLint, values: Int32List, srcOffset: GLuint = 0): void;\r\n// @ts-ignore\r\nexport declare function clearBufferuiv(gl: WebGLRenderingContextId, buffer: GLenum, drawbuffer: GLint, values: Uint32List, srcOffset: GLuint = 0): void;\r\n\r\nexport declare function clearBufferfi(gl: WebGLRenderingContextId, buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void;\r\n\r\n/* Query Objects */\r\nexport declare function createQuery(gl: WebGLRenderingContextId): WebGLQuery;\r\nexport declare function deleteQuery(gl: WebGLRenderingContextId, query: WebGLQuery): void;\r\n/*[WebGLHandlesContextLoss]*/\r\nexport declare function isQuery(gl: WebGLRenderingContextId, query: WebGLQuery): GLboolean;\r\nexport declare function beginQuery(gl: WebGLRenderingContextId, target: GLenum, query: WebGLQuery): void;\r\nexport declare function endQuery(gl: WebGLRenderingContextId, target: GLenum): void;\r\nexport declare function getQuery(gl: WebGLRenderingContextId, target: GLenum, pname: GLenum): WebGLQuery;\r\nexport declare function getQueryParameter(gl: WebGLRenderingContextId, query: WebGLQuery, pname: GLenum): externref; // any\r\n\r\n/* Sampler Objects */\r\nexport declare function createSampler(gl: WebGLRenderingContextId): WebGLSampler;\r\nexport declare function deleteSampler(gl: WebGLRenderingContextId, sampler: WebGLSampler): void;\r\n/*[WebGLHandlesContextLoss]*/\r\nexport declare function isSampler(gl: WebGLRenderingContextId, sampler: WebGLSampler): GLboolean;\r\nexport declare function bindSampler(gl: WebGLRenderingContextId, unit: GLuint, sampler: WebGLSampler): void;\r\nexport declare function samplerParameteri(gl: WebGLRenderingContextId, sampler: WebGLSampler, pname: GLenum, param: GLint): void;\r\nexport declare function samplerParameterf(gl: WebGLRenderingContextId, sampler: WebGLSampler, pname: GLenum, param: GLfloat): void;\r\nexport declare function getSamplerParameter(gl: WebGLRenderingContextId, sampler: WebGLSampler, pname: GLenum): externref; // any\r\n\r\n/* Sync objects */\r\nexport declare function fenceSync(gl: WebGLRenderingContextId, condition: GLenum, flags: GLbitfield): WebGLSync;\r\n/*[WebGLHandlesContextLoss]*/\r\nexport declare function isSync(gl: WebGLRenderingContextId, sync: WebGLSync): GLboolean;\r\nexport declare function deleteSync(gl: WebGLRenderingContextId, sync: WebGLSync): void;\r\nexport declare function clientWaitSync(gl: WebGLRenderingContextId, sync: WebGLSync, flags: GLbitfield, timeout: GLuint64): GLenum;\r\nexport declare function waitSync(gl: WebGLRenderingContextId, sync: WebGLSync, flags: GLbitfield, timeout: GLint64): void;\r\nexport declare function getSyncParameter(gl: WebGLRenderingContextId, sync: WebGLSync, pname: GLenum): externref; // any\r\n\r\n/* Transform Feedback */\r\nexport declare function createTransformFeedback(gl: WebGLRenderingContextId): WebGLTransformFeedback;\r\nexport declare function deleteTransformFeedback(gl: WebGLRenderingContextId, tf: WebGLTransformFeedback): void;\r\n/*[WebGLHandlesContextLoss]*/\r\nexport declare function isTransformFeedback(gl: WebGLRenderingContextId, tf: WebGLTransformFeedback): GLboolean;\r\nexport declare function bindTransformFeedback(gl: WebGLRenderingContextId, target: GLenum, tf: WebGLTransformFeedback): void;\r\nexport declare function beginTransformFeedback(gl: WebGLRenderingContextId, primitiveMode: GLenum): void;\r\nexport declare function endTransformFeedback(gl: WebGLRenderingContextId): void;\r\nexport declare function transformFeedbackVaryings(gl: WebGLRenderingContextId, program: WebGLProgram, varyings: sequence<DOMString>, bufferMode: GLenum): void;\r\nexport declare function getTransformFeedbackVarying(gl: WebGLRenderingContextId, program: WebGLProgram, index: GLuint): WebGLActiveInfo;\r\nexport declare function pauseTransformFeedback(gl: WebGLRenderingContextId): void;\r\nexport declare function resumeTransformFeedback(gl: WebGLRenderingContextId): void;\r\n\r\n/* Uniform Buffer Objects and Transform Feedback Buffers */\r\nexport declare function bindBufferBase(gl: WebGLRenderingContextId, target: GLenum, index: GLuint, buffer: WebGLBuffer): void;\r\nexport declare function bindBufferRange(gl: WebGLRenderingContextId, target: GLenum, index: GLuint, buffer: WebGLBuffer, offset: GLintptr, size: GLsizeiptr): void;\r\nexport declare function getIndexedParameter(gl: WebGLRenderingContextId, target: GLenum, index: GLuint): externref; // any\r\nexport declare function getUniformIndices(gl: WebGLRenderingContextId, program: WebGLProgram, uniformNames: sequence<DOMString>): sequence<GLuint>;\r\nexport declare function getActiveUniforms(gl: WebGLRenderingContextId, program: WebGLProgram, uniformIndices: sequence<GLuint>, pname: GLenum): externref; // any\r\nexport declare function getUniformBlockIndex(gl: WebGLRenderingContextId, program: WebGLProgram, uniformBlockName: DOMString): GLuint;\r\nexport declare function getActiveUniformBlockParameter(gl: WebGLRenderingContextId, program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum): externref; // any\r\nexport declare function getActiveUniformBlockName(gl: WebGLRenderingContextId, program: WebGLProgram, uniformBlockIndex: GLuint): DOMString;\r\nexport declare function uniformBlockBinding(gl: WebGLRenderingContextId, program: WebGLProgram, uniformBlockIndex: GLuint, uniformBlockBinding: GLuint): void;\r\n\r\n/* Vertex Array Objects */\r\nexport declare function createVertexArray(gl: WebGLRenderingContextId): WebGLVertexArrayObject;\r\nexport declare function deleteVertexArray(gl: WebGLRenderingContextId, vertexArray: WebGLVertexArrayObject): void;\r\n/*[WebGLHandlesContextLoss]*/\r\nexport declare function isVertexArray(gl: WebGLRenderingContextId, vertexArray: WebGLVertexArrayObject): GLboolean;\r\nexport declare function bindVertexArray(gl: WebGLRenderingContextId, array: WebGLVertexArrayObject): void;\r\n\r\n\r\n@final @unmanaged\r\nexport class WebGLRenderingContext {\r\n    gl_id: WebGLRenderingContextId;\r\n\r\n    @inline constructor(canvas_id: string, context_type: string) {\r\n        // constructor needs to create the gl_id\r\n        this.gl_id = createContextFromCanvas(canvas_id, context_type);\r\n    }\r\n\r\n    /*\r\n    @inline get ptr(): usize {\r\n        return changetype<usize>(this);\r\n    }\r\n    */\r\n\r\n    @inline createImage(image_location: string): ImageData {\r\n        return createImage(image_location);\r\n    }\r\n\r\n    @inline imageReady(image_id: ImageData): bool {\r\n        return imageReady(image_id);\r\n    }\r\n\r\n    @inline get ALPHA_DEFAULT(): bool {\r\n        return ALPHA_DEFAULT;\r\n    }\r\n\r\n    @inline get FALSE(): GLboolean {\r\n        return FALSE;\r\n    }\r\n\r\n    @inline getAlpha(): GLboolean {\r\n        return getAlpha(this.gl_id);\r\n    }\r\n\r\n    @inline setAlpha(value: GLboolean): void {\r\n        setAlpha(this.gl_id, value);\r\n    }\r\n\r\n    @inline get DEPTH_DEFAULT(): bool {\r\n        return DEPTH_DEFAULT;\r\n    }\r\n\r\n    @inline getDepth(): GLboolean {\r\n        return getDepth(this.gl_id);\r\n    }\r\n\r\n    @inline setDepth(value: GLboolean): void {\r\n        setDepth(this.gl_id, value);\r\n    }\r\n\r\n    @inline get STENCIL_DEFAULT(): bool {\r\n        return STENCIL_DEFAULT;\r\n    }\r\n\r\n    @inline getStencil(): GLboolean {\r\n        return getStencil(this.gl_id);\r\n    }\r\n\r\n    @inline setStencil(value: GLboolean): void {\r\n        setStencil(this.gl_id, value);\r\n    }\r\n\r\n    @inline get ANTIALIAS_DEFAULT(): bool {\r\n        return ANTIALIAS_DEFAULT;\r\n    }\r\n\r\n    @inline getAntialias(): GLboolean {\r\n        return getAntialias(this.gl_id);\r\n    }\r\n\r\n    @inline setAntialias(value: GLboolean): void {\r\n        setAntialias(this.gl_id, value);\r\n    }\r\n\r\n    @inline get PREMULTIPLIED_ALPHA_DEFAULT(): bool {\r\n        return PREMULTIPLIED_ALPHA_DEFAULT;\r\n    }\r\n\r\n    @inline getPremultipliedAlpha(): GLboolean {\r\n        return getPremultipliedAlpha(this.gl_id);\r\n    }\r\n\r\n    @inline setPremultipliedAlpha(value: GLboolean): void {\r\n        setPremultipliedAlpha(this.gl_id, value);\r\n    }\r\n\r\n    @inline get PRESERVE_DRAWING_BUFFER_DEFAULT(): bool {\r\n        return PRESERVE_DRAWING_BUFFER_DEFAULT;\r\n    }\r\n\r\n    @inline getPreserveDrawingBuffer(): GLboolean {\r\n        return getPreserveDrawingBuffer(this.gl_id);\r\n    }\r\n\r\n    @inline setPreserveDrawingBuffer(value: GLboolean): void {\r\n        setPreserveDrawingBuffer(this.gl_id, value);\r\n    }\r\n\r\n    @inline getSize(): GLint {\r\n    // @ts-ignore\r\n        return getSize(this.gl_id);\r\n    }\r\n\r\n    @inline getType(): GLenum {\r\n    // @ts-ignore\r\n        return getType(this.gl_id);\r\n    }\r\n\r\n    @inline getName(): string {\r\n    // @ts-ignore\r\n        return getName(this.gl_id);\r\n    }\r\n\r\n    @inline getRangeMin(): GLint {\r\n    // @ts-ignore\r\n        return getRangeMin(this.gl_id);\r\n    }\r\n\r\n    @inline getRangeMax(): GLint {\r\n    // @ts-ignore\r\n        return getRangeMax(this.gl_id);\r\n    }\r\n    @inline getPrecision(): GLint {\r\n    // @ts-ignore\r\n        return getPrecision(this.gl_id)\r\n    }\r\n\r\n    @inline get DEPTH_BUFFER_BIT(): GLenum {\r\n        return DEPTH_BUFFER_BIT;\r\n    }\r\n\r\n    @inline get STENCIL_BUFFER_BIT(): GLenum {\r\n        return STENCIL_BUFFER_BIT;\r\n    }\r\n\r\n    @inline get COLOR_BUFFER_BIT(): GLenum {\r\n        return COLOR_BUFFER_BIT;\r\n    }\r\n\r\n    @inline get POINTS(): GLenum {\r\n        return POINTS;\r\n    }\r\n\r\n    @inline get LINES(): GLenum {\r\n        return LINES;\r\n    }\r\n\r\n    @inline get LINE_LOOP(): GLenum {\r\n        return LINE_LOOP;\r\n    }\r\n\r\n    @inline get LINE_STRIP(): GLenum {\r\n        return LINE_STRIP;\r\n    }\r\n\r\n    @inline get TRIANGLES(): GLenum {\r\n        return TRIANGLES;\r\n    }\r\n\r\n    @inline get TRIANGLE_STRIP(): GLenum {\r\n        return TRIANGLE_STRIP;\r\n    }\r\n\r\n    @inline get TRIANGLE_FAN(): GLenum {\r\n        return TRIANGLE_FAN;\r\n    }\r\n\r\n    @inline get ZERO(): GLenum {\r\n        return ZERO;\r\n    }\r\n\r\n    @inline get ONE(): GLenum {\r\n        return ONE;\r\n    }\r\n\r\n    @inline get SRC_COLOR(): GLenum {\r\n        return SRC_COLOR;\r\n    }\r\n\r\n    @inline get ONE_MINUS_SRC_COLOR(): GLenum {\r\n        return ONE_MINUS_SRC_COLOR;\r\n    }\r\n\r\n    @inline get SRC_ALPHA(): GLenum {\r\n        return SRC_ALPHA;\r\n    }\r\n\r\n    @inline get ONE_MINUS_SRC_ALPHA(): GLenum {\r\n        return ONE_MINUS_SRC_ALPHA;\r\n    }\r\n\r\n    @inline get DST_ALPHA(): GLenum {\r\n        return DST_ALPHA;\r\n    }\r\n\r\n    @inline get ONE_MINUS_DST_ALPHA(): GLenum {\r\n        return ONE_MINUS_DST_ALPHA;\r\n    }\r\n\r\n    @inline get DST_COLOR(): GLenum {\r\n        return DST_COLOR;\r\n    }\r\n\r\n    @inline get ONE_MINUS_DST_COLOR(): GLenum {\r\n        return ONE_MINUS_DST_COLOR;\r\n    }\r\n\r\n    @inline get SRC_ALPHA_SATURATE(): GLenum {\r\n        return SRC_ALPHA_SATURATE;\r\n    }\r\n\r\n    @inline get FUNC_ADD(): GLenum {\r\n        return FUNC_ADD;\r\n    }\r\n\r\n    @inline get BLEND_EQUATION(): GLenum {\r\n        return BLEND_EQUATION;\r\n    }\r\n\r\n    @inline get BLEND_EQUATION_RGB(): GLenum {\r\n        return BLEND_EQUATION_RGB;\r\n    }\r\n\r\n    @inline get BLEND_EQUATION_ALPHA(): GLenum {\r\n        return BLEND_EQUATION_ALPHA;\r\n    }\r\n\r\n    @inline get FUNC_SUBTRACT(): GLenum {\r\n        return FUNC_SUBTRACT;\r\n    }\r\n\r\n    @inline get FUNC_REVERSE_SUBTRACT(): GLenum {\r\n        return FUNC_REVERSE_SUBTRACT;\r\n    }\r\n\r\n    @inline get BLEND_DST_RGB(): GLenum {\r\n        return BLEND_DST_RGB;\r\n    }\r\n\r\n    @inline get BLEND_SRC_RGB(): GLenum {\r\n        return BLEND_SRC_RGB;\r\n    }\r\n\r\n    @inline get BLEND_DST_ALPHA(): GLenum {\r\n        return BLEND_DST_ALPHA;\r\n    }\r\n\r\n    @inline get BLEND_SRC_ALPHA(): GLenum {\r\n        return BLEND_SRC_ALPHA;\r\n    }\r\n\r\n    @inline get CONSTANT_COLOR(): GLenum {\r\n        return CONSTANT_COLOR;\r\n    }\r\n\r\n    @inline get ONE_MINUS_CONSTANT_COLOR(): GLenum {\r\n        return ONE_MINUS_CONSTANT_COLOR;\r\n    }\r\n\r\n    @inline get CONSTANT_ALPHA(): GLenum {\r\n        return CONSTANT_ALPHA;\r\n    }\r\n\r\n    @inline get ONE_MINUS_CONSTANT_ALPHA(): GLenum {\r\n        return ONE_MINUS_CONSTANT_ALPHA;\r\n    }\r\n\r\n    @inline get BLEND_COLOR(): GLenum {\r\n        return BLEND_COLOR;\r\n    }\r\n\r\n    @inline get ARRAY_BUFFER(): GLenum {\r\n        return ARRAY_BUFFER;\r\n    }\r\n\r\n    @inline get ELEMENT_ARRAY_BUFFER(): GLenum {\r\n        return ELEMENT_ARRAY_BUFFER;\r\n    }\r\n\r\n    @inline get ARRAY_BUFFER_BINDING(): GLenum {\r\n        return ARRAY_BUFFER_BINDING;\r\n    }\r\n\r\n    @inline get ELEMENT_ARRAY_BUFFER_BINDING(): GLenum {\r\n        return ELEMENT_ARRAY_BUFFER_BINDING;\r\n    }\r\n\r\n    @inline get STREAM_DRAW(): GLenum {\r\n        return STREAM_DRAW;\r\n    }\r\n\r\n    @inline get STATIC_DRAW(): GLenum {\r\n        return STATIC_DRAW;\r\n    }\r\n\r\n    @inline get DYNAMIC_DRAW(): GLenum {\r\n        return DYNAMIC_DRAW;\r\n    }\r\n\r\n    @inline get BUFFER_SIZE(): GLenum {\r\n        return BUFFER_SIZE;\r\n    }\r\n\r\n    @inline get BUFFER_USAGE(): GLenum {\r\n        return BUFFER_USAGE;\r\n    }\r\n\r\n    @inline get CURRENT_VERTEX_ATTRIB(): GLenum {\r\n        return CURRENT_VERTEX_ATTRIB;\r\n    }\r\n\r\n    @inline get FRONT(): GLenum {\r\n        return FRONT;\r\n    }\r\n\r\n    @inline get BACK(): GLenum {\r\n        return BACK;\r\n    }\r\n\r\n    @inline get FRONT_AND_BACK(): GLenum {\r\n        return FRONT_AND_BACK;\r\n    }\r\n\r\n    @inline get CULL_FACE(): GLenum {\r\n        return CULL_FACE;\r\n    }\r\n\r\n    @inline get BLEND(): GLenum {\r\n        return BLEND;\r\n    }\r\n\r\n    @inline get DITHER(): GLenum {\r\n        return DITHER;\r\n    }\r\n\r\n    @inline get STENCIL_TEST(): GLenum {\r\n        return STENCIL_TEST;\r\n    }\r\n\r\n    @inline get DEPTH_TEST(): GLenum {\r\n        return DEPTH_TEST;\r\n    }\r\n\r\n    @inline get SCISSOR_TEST(): GLenum {\r\n        return SCISSOR_TEST;\r\n    }\r\n\r\n    @inline get POLYGON_OFFSET_FILL(): GLenum {\r\n        return POLYGON_OFFSET_FILL;\r\n    }\r\n\r\n    @inline get SAMPLE_ALPHA_TO_COVERAGE(): GLenum {\r\n        return SAMPLE_ALPHA_TO_COVERAGE;\r\n    }\r\n\r\n    @inline get SAMPLE_COVERAGE(): GLenum {\r\n        return SAMPLE_COVERAGE;\r\n    }\r\n\r\n    @inline get NO_ERROR(): GLenum {\r\n        return NO_ERROR;\r\n    }\r\n\r\n    @inline get INVALID_ENUM(): GLenum {\r\n        return INVALID_ENUM;\r\n    }\r\n\r\n    @inline get INVALID_VALUE(): GLenum {\r\n        return INVALID_VALUE;\r\n    }\r\n\r\n    @inline get INVALID_OPERATION(): GLenum {\r\n        return INVALID_OPERATION;\r\n    }\r\n\r\n    @inline get OUT_OF_MEMORY(): GLenum {\r\n        return OUT_OF_MEMORY;\r\n    }\r\n\r\n    @inline get CW(): GLenum {\r\n        return CW;\r\n    }\r\n\r\n    @inline get CCW(): GLenum {\r\n        return CCW;\r\n    }\r\n\r\n    @inline get LINE_WIDTH(): GLenum {\r\n        return LINE_WIDTH;\r\n    }\r\n\r\n    @inline get ALIASED_POINT_SIZE_RANGE(): GLenum {\r\n        return ALIASED_POINT_SIZE_RANGE;\r\n    }\r\n\r\n    @inline get ALIASED_LINE_WIDTH_RANGE(): GLenum {\r\n        return ALIASED_LINE_WIDTH_RANGE;\r\n    }\r\n\r\n    @inline get CULL_FACE_MODE(): GLenum {\r\n        return CULL_FACE_MODE;\r\n    }\r\n\r\n    @inline get FRONT_FACE(): GLenum {\r\n        return FRONT_FACE;\r\n    }\r\n\r\n    @inline get DEPTH_RANGE(): GLenum {\r\n        return DEPTH_RANGE;\r\n    }\r\n\r\n    @inline get DEPTH_WRITEMASK(): GLenum {\r\n        return DEPTH_WRITEMASK;\r\n    }\r\n\r\n    @inline get DEPTH_CLEAR_VALUE(): GLenum {\r\n        return DEPTH_CLEAR_VALUE;\r\n    }\r\n\r\n    @inline get DEPTH_FUNC(): GLenum {\r\n        return DEPTH_FUNC;\r\n    }\r\n\r\n    @inline get STENCIL_CLEAR_VALUE(): GLenum {\r\n        return STENCIL_CLEAR_VALUE;\r\n    }\r\n\r\n    @inline get STENCIL_FUNC(): GLenum {\r\n        return STENCIL_FUNC;\r\n    }\r\n\r\n    @inline get STENCIL_FAIL(): GLenum {\r\n        return STENCIL_FAIL;\r\n    }\r\n\r\n    @inline get STENCIL_PASS_DEPTH_FAIL(): GLenum {\r\n        return STENCIL_PASS_DEPTH_FAIL;\r\n    }\r\n\r\n    @inline get STENCIL_PASS_DEPTH_PASS(): GLenum {\r\n        return STENCIL_PASS_DEPTH_PASS;\r\n    }\r\n\r\n    @inline get STENCIL_REF(): GLenum {\r\n        return STENCIL_REF;\r\n    }\r\n\r\n    @inline get STENCIL_VALUE_MASK(): GLenum {\r\n        return STENCIL_VALUE_MASK;\r\n    }\r\n\r\n    @inline get STENCIL_WRITEMASK(): GLenum {\r\n        return STENCIL_WRITEMASK;\r\n    }\r\n\r\n    @inline get STENCIL_BACK_FUNC(): GLenum {\r\n        return STENCIL_BACK_FUNC;\r\n    }\r\n\r\n    @inline get STENCIL_BACK_FAIL(): GLenum {\r\n        return STENCIL_BACK_FAIL;\r\n    }\r\n\r\n    @inline get STENCIL_BACK_PASS_DEPTH_FAIL(): GLenum {\r\n        return STENCIL_BACK_PASS_DEPTH_FAIL;\r\n    }\r\n\r\n    @inline get STENCIL_BACK_PASS_DEPTH_PASS(): GLenum {\r\n        return STENCIL_BACK_PASS_DEPTH_PASS;\r\n    }\r\n\r\n    @inline get STENCIL_BACK_REF(): GLenum {\r\n        return STENCIL_BACK_REF;\r\n    }\r\n\r\n    @inline get STENCIL_BACK_VALUE_MASK(): GLenum {\r\n        return STENCIL_BACK_VALUE_MASK;\r\n    }\r\n\r\n    @inline get STENCIL_BACK_WRITEMASK(): GLenum {\r\n        return STENCIL_BACK_WRITEMASK;\r\n    }\r\n\r\n    @inline get VIEWPORT(): GLenum {\r\n        return VIEWPORT;\r\n    }\r\n\r\n    @inline get SCISSOR_BOX(): GLenum {\r\n        return SCISSOR_BOX;\r\n    }\r\n\r\n    @inline get COLOR_CLEAR_VALUE(): GLenum {\r\n        return COLOR_CLEAR_VALUE;\r\n    }\r\n\r\n    @inline get COLOR_WRITEMASK(): GLenum {\r\n        return COLOR_WRITEMASK;\r\n    }\r\n\r\n    @inline get UNPACK_ALIGNMENT(): GLenum {\r\n        return UNPACK_ALIGNMENT;\r\n    }\r\n\r\n    @inline get PACK_ALIGNMENT(): GLenum {\r\n        return PACK_ALIGNMENT;\r\n    }\r\n\r\n    @inline get MAX_TEXTURE_SIZE(): GLenum {\r\n        return MAX_TEXTURE_SIZE;\r\n    }\r\n\r\n    @inline get MAX_VIEWPORT_DIMS(): GLenum {\r\n        return MAX_VIEWPORT_DIMS;\r\n    }\r\n\r\n    @inline get SUBPIXEL_BITS(): GLenum {\r\n        return SUBPIXEL_BITS;\r\n    }\r\n\r\n    @inline get RED_BITS(): GLenum {\r\n        return RED_BITS;\r\n    }\r\n\r\n    @inline get GREEN_BITS(): GLenum {\r\n        return GREEN_BITS;\r\n    }\r\n\r\n    @inline get BLUE_BITS(): GLenum {\r\n        return BLUE_BITS;\r\n    }\r\n\r\n    @inline get ALPHA_BITS(): GLenum {\r\n        return ALPHA_BITS;\r\n    }\r\n\r\n    @inline get DEPTH_BITS(): GLenum {\r\n        return DEPTH_BITS;\r\n    }\r\n\r\n    @inline get STENCIL_BITS(): GLenum {\r\n        return STENCIL_BITS;\r\n    }\r\n\r\n    @inline get POLYGON_OFFSET_UNITS(): GLenum {\r\n        return POLYGON_OFFSET_UNITS;\r\n    }\r\n\r\n    @inline get POLYGON_OFFSET_FACTOR(): GLenum {\r\n        return POLYGON_OFFSET_FACTOR;\r\n    }\r\n\r\n    @inline get TEXTURE_BINDING_2D(): GLenum {\r\n        return TEXTURE_BINDING_2D;\r\n    }\r\n\r\n    @inline get SAMPLE_BUFFERS(): GLenum {\r\n        return SAMPLE_BUFFERS;\r\n    }\r\n\r\n    @inline get SAMPLES(): GLenum {\r\n        return SAMPLES;\r\n    }\r\n\r\n    @inline get SAMPLE_COVERAGE_VALUE(): GLenum {\r\n        return SAMPLE_COVERAGE_VALUE;\r\n    }\r\n\r\n    @inline get SAMPLE_COVERAGE_INVERT(): GLenum {\r\n        return SAMPLE_COVERAGE_INVERT;\r\n    }\r\n\r\n    @inline get COMPRESSED_TEXTURE_FORMATS(): GLenum {\r\n        return COMPRESSED_TEXTURE_FORMATS;\r\n    }\r\n\r\n    @inline get DONT_CARE(): GLenum {\r\n        return DONT_CARE;\r\n    }\r\n\r\n    @inline get FASTEST(): GLenum {\r\n        return FASTEST;\r\n    }\r\n\r\n    @inline get NICEST(): GLenum {\r\n        return NICEST;\r\n    }\r\n\r\n    @inline get GENERATE_MIPMAP_HINT(): GLenum {\r\n        return GENERATE_MIPMAP_HINT;\r\n    }\r\n\r\n    @inline get BYTE(): GLenum {\r\n        return BYTE;\r\n    }\r\n\r\n    @inline get UNSIGNED_BYTE(): GLenum {\r\n        return UNSIGNED_BYTE;\r\n    }\r\n\r\n    @inline get SHORT(): GLenum {\r\n        return SHORT;\r\n    }\r\n\r\n    @inline get UNSIGNED_SHORT(): GLenum {\r\n        return UNSIGNED_SHORT;\r\n    }\r\n\r\n    @inline get INT(): GLenum {\r\n        return INT;\r\n    }\r\n\r\n    @inline get UNSIGNED_INT(): GLenum {\r\n        return UNSIGNED_INT;\r\n    }\r\n\r\n    @inline get FLOAT(): GLenum {\r\n        return FLOAT;\r\n    }\r\n\r\n    @inline get DEPTH_COMPONENT(): GLenum {\r\n        return DEPTH_COMPONENT;\r\n    }\r\n\r\n    @inline get ALPHA(): GLenum {\r\n        return ALPHA;\r\n    }\r\n\r\n    @inline get RGB(): GLenum {\r\n        return RGB;\r\n    }\r\n\r\n    @inline get RGBA(): GLenum {\r\n        return RGBA;\r\n    }\r\n\r\n    @inline get LUMINANCE(): GLenum {\r\n        return LUMINANCE;\r\n    }\r\n\r\n    @inline get LUMINANCE_ALPHA(): GLenum {\r\n        return LUMINANCE_ALPHA;\r\n    }\r\n\r\n    @inline get UNSIGNED_SHORT_4_4_4_4(): GLenum {\r\n        return UNSIGNED_SHORT_4_4_4_4;\r\n    }\r\n\r\n    @inline get UNSIGNED_SHORT_5_5_5_1(): GLenum {\r\n        return UNSIGNED_SHORT_5_5_5_1;\r\n    }\r\n\r\n    @inline get UNSIGNED_SHORT_5_6_5(): GLenum {\r\n        return UNSIGNED_SHORT_5_6_5;\r\n    }\r\n\r\n    @inline get FRAGMENT_SHADER(): GLenum {\r\n        return FRAGMENT_SHADER;\r\n    }\r\n\r\n    @inline get VERTEX_SHADER(): GLenum {\r\n        return VERTEX_SHADER;\r\n    }\r\n\r\n    @inline get MAX_VERTEX_ATTRIBS(): GLenum {\r\n        return MAX_VERTEX_ATTRIBS;\r\n    }\r\n\r\n    @inline get MAX_VERTEX_UNIFORM_VECTORS(): GLenum {\r\n        return MAX_VERTEX_UNIFORM_VECTORS;\r\n    }\r\n\r\n    @inline get MAX_VARYING_VECTORS(): GLenum {\r\n        return MAX_VARYING_VECTORS;\r\n    }\r\n\r\n    @inline get MAX_COMBINED_TEXTURE_IMAGE_UNITS(): GLenum {\r\n        return MAX_COMBINED_TEXTURE_IMAGE_UNITS;\r\n    }\r\n\r\n    @inline get MAX_VERTEX_TEXTURE_IMAGE_UNITS(): GLenum {\r\n        return MAX_VERTEX_TEXTURE_IMAGE_UNITS;\r\n    }\r\n\r\n    @inline get MAX_TEXTURE_IMAGE_UNITS(): GLenum {\r\n        return MAX_TEXTURE_IMAGE_UNITS;\r\n    }\r\n\r\n    @inline get MAX_FRAGMENT_UNIFORM_VECTORS(): GLenum {\r\n        return MAX_FRAGMENT_UNIFORM_VECTORS;\r\n    }\r\n\r\n    @inline get SHADER_TYPE(): GLenum {\r\n        return SHADER_TYPE;\r\n    }\r\n\r\n    @inline get DELETE_STATUS(): GLenum {\r\n        return DELETE_STATUS;\r\n    }\r\n\r\n    @inline get LINK_STATUS(): GLenum {\r\n        return LINK_STATUS;\r\n    }\r\n\r\n    @inline get VALIDATE_STATUS(): GLenum {\r\n        return VALIDATE_STATUS;\r\n    }\r\n\r\n    @inline get ATTACHED_SHADERS(): GLenum {\r\n        return ATTACHED_SHADERS;\r\n    }\r\n\r\n    @inline get ACTIVE_UNIFORMS(): GLenum {\r\n        return ACTIVE_UNIFORMS;\r\n    }\r\n\r\n    @inline get ACTIVE_ATTRIBUTES(): GLenum {\r\n        return ACTIVE_ATTRIBUTES;\r\n    }\r\n\r\n    @inline get SHADING_LANGUAGE_VERSION(): GLenum {\r\n        return SHADING_LANGUAGE_VERSION;\r\n    }\r\n\r\n    @inline get CURRENT_PROGRAM(): GLenum {\r\n        return CURRENT_PROGRAM;\r\n    }\r\n\r\n    @inline get NEVER(): GLenum {\r\n        return NEVER;\r\n    }\r\n\r\n    @inline get LESS(): GLenum {\r\n        return LESS;\r\n    }\r\n\r\n    @inline get EQUAL(): GLenum {\r\n        return EQUAL;\r\n    }\r\n\r\n    @inline get LEQUAL(): GLenum {\r\n        return LEQUAL;\r\n    }\r\n\r\n    @inline get GREATER(): GLenum {\r\n        return GREATER;\r\n    }\r\n\r\n    @inline get NOTEQUAL(): GLenum {\r\n        return NOTEQUAL;\r\n    }\r\n\r\n    @inline get GEQUAL(): GLenum {\r\n        return GEQUAL;\r\n    }\r\n\r\n    @inline get ALWAYS(): GLenum {\r\n        return ALWAYS;\r\n    }\r\n\r\n    @inline get KEEP(): GLenum {\r\n        return KEEP;\r\n    }\r\n\r\n    @inline get REPLACE(): GLenum {\r\n        return REPLACE;\r\n    }\r\n\r\n    @inline get INCR(): GLenum {\r\n        return INCR;\r\n    }\r\n\r\n    @inline get DECR(): GLenum {\r\n        return DECR;\r\n    }\r\n\r\n    @inline get INVERT(): GLenum {\r\n        return INVERT;\r\n    }\r\n\r\n    @inline get INCR_WRAP(): GLenum {\r\n        return INCR_WRAP;\r\n    }\r\n\r\n    @inline get DECR_WRAP(): GLenum {\r\n        return DECR_WRAP;\r\n    }\r\n\r\n\r\n    @inline get VENDOR(): GLenum {\r\n        return VENDOR;\r\n    }\r\n\r\n    @inline get RENDERER(): GLenum {\r\n        return RENDERER;\r\n    }\r\n\r\n    @inline get VERSION(): GLenum {\r\n        return VERSION;\r\n    }\r\n\r\n    @inline get NEAREST(): GLenum {\r\n        return NEAREST;\r\n    }\r\n\r\n    @inline get LINEAR(): GLenum {\r\n        return LINEAR;\r\n    }\r\n\r\n    @inline get NEAREST_MIPMAP_NEAREST(): GLenum {\r\n        return NEAREST_MIPMAP_NEAREST;\r\n    }\r\n\r\n    @inline get LINEAR_MIPMAP_NEAREST(): GLenum {\r\n        return LINEAR_MIPMAP_NEAREST;\r\n    }\r\n\r\n    @inline get NEAREST_MIPMAP_LINEAR(): GLenum {\r\n        return NEAREST_MIPMAP_LINEAR;\r\n    }\r\n\r\n    @inline get LINEAR_MIPMAP_LINEAR(): GLenum {\r\n        return LINEAR_MIPMAP_LINEAR;\r\n    }\r\n\r\n    @inline get TEXTURE_MAG_FILTER(): GLenum {\r\n        return TEXTURE_MAG_FILTER;\r\n    }\r\n\r\n    @inline get TEXTURE_MIN_FILTER(): GLenum {\r\n        return TEXTURE_MIN_FILTER;\r\n    }\r\n\r\n    @inline get TEXTURE_WRAP_S(): GLenum {\r\n        return LINEAR;\r\n    }\r\n\r\n    @inline get TEXTURE_WRAP_T(): GLenum {\r\n        return TEXTURE_WRAP_T;\r\n    }\r\n\r\n    @inline get TEXTURE_2D(): GLenum {\r\n        return TEXTURE_2D;\r\n    }\r\n\r\n    @inline get TEXTURE(): GLenum {\r\n        return TEXTURE;\r\n    }\r\n\r\n    @inline get TEXTURE_CUBE_MAP(): GLenum {\r\n        return TEXTURE_CUBE_MAP;\r\n    }\r\n\r\n    @inline get TEXTURE_BINDING_CUBE_MAP(): GLenum {\r\n        return TEXTURE_BINDING_CUBE_MAP;\r\n    }\r\n\r\n    @inline get TEXTURE_CUBE_MAP_POSITIVE_X(): GLenum {\r\n        return TEXTURE_CUBE_MAP_POSITIVE_X;\r\n    }\r\n\r\n    @inline get TEXTURE_CUBE_MAP_NEGATIVE_X(): GLenum {\r\n        return TEXTURE_CUBE_MAP_NEGATIVE_X;\r\n    }\r\n\r\n    @inline get TEXTURE_CUBE_MAP_POSITIVE_Y(): GLenum {\r\n        return TEXTURE_CUBE_MAP_POSITIVE_Y;\r\n    }\r\n\r\n    @inline get TEXTURE_CUBE_MAP_NEGATIVE_Y(): GLenum {\r\n        return TEXTURE_CUBE_MAP_NEGATIVE_Y;\r\n    }\r\n\r\n    @inline get TEXTURE_CUBE_MAP_POSITIVE_Z(): GLenum {\r\n        return TEXTURE_CUBE_MAP_POSITIVE_Z;\r\n    }\r\n\r\n    @inline get TEXTURE_CUBE_MAP_NEGATIVE_Z(): GLenum {\r\n        return TEXTURE_CUBE_MAP_NEGATIVE_Z;\r\n    }\r\n\r\n    @inline get MAX_CUBE_MAP_TEXTURE_SIZE(): GLenum {\r\n        return MAX_CUBE_MAP_TEXTURE_SIZE;\r\n    }\r\n\r\n    @inline get TEXTURE0(): GLenum {\r\n        return TEXTURE0;\r\n    }\r\n    @inline get TEXTURE1(): GLenum {\r\n        return TEXTURE1;\r\n    }\r\n    @inline get TEXTURE2(): GLenum {\r\n        return TEXTURE2;\r\n    }\r\n    @inline get TEXTURE3(): GLenum {\r\n        return TEXTURE3;\r\n    }\r\n    @inline get TEXTURE4(): GLenum {\r\n        return TEXTURE4;\r\n    }\r\n    @inline get TEXTURE5(): GLenum {\r\n        return TEXTURE5;\r\n    }\r\n    @inline get TEXTURE6(): GLenum {\r\n        return TEXTURE6;\r\n    }\r\n    @inline get TEXTURE7(): GLenum {\r\n        return TEXTURE7;\r\n    }\r\n    @inline get TEXTURE8(): GLenum {\r\n        return TEXTURE8;\r\n    }\r\n    @inline get TEXTURE9(): GLenum {\r\n        return TEXTURE9;\r\n    }\r\n    //---\r\n\r\n    @inline get TEXTURE10(): GLenum {\r\n        return TEXTURE10;\r\n    }\r\n    @inline get TEXTURE11(): GLenum {\r\n        return TEXTURE11;\r\n    }\r\n    @inline get TEXTURE12(): GLenum {\r\n        return TEXTURE12;\r\n    }\r\n    @inline get TEXTURE13(): GLenum {\r\n        return TEXTURE13;\r\n    }\r\n    @inline get TEXTURE14(): GLenum {\r\n        return TEXTURE14;\r\n    }\r\n    @inline get TEXTURE15(): GLenum {\r\n        return TEXTURE15;\r\n    }\r\n    @inline get TEXTURE16(): GLenum {\r\n        return TEXTURE16;\r\n    }\r\n    @inline get TEXTURE17(): GLenum {\r\n        return TEXTURE17;\r\n    }\r\n    @inline get TEXTURE18(): GLenum {\r\n        return TEXTURE18;\r\n    }\r\n    @inline get TEXTURE19(): GLenum {\r\n        return TEXTURE19;\r\n    }\r\n    // --\r\n    @inline get TEXTURE20(): GLenum {\r\n        return TEXTURE20;\r\n    }\r\n    @inline get TEXTURE21(): GLenum {\r\n        return TEXTURE21;\r\n    }\r\n    @inline get TEXTURE22(): GLenum {\r\n        return TEXTURE22;\r\n    }\r\n    @inline get TEXTURE23(): GLenum {\r\n        return TEXTURE23;\r\n    }\r\n    @inline get TEXTURE24(): GLenum {\r\n        return TEXTURE24;\r\n    }\r\n    @inline get TEXTURE25(): GLenum {\r\n        return TEXTURE25;\r\n    }\r\n    @inline get TEXTURE26(): GLenum {\r\n        return TEXTURE26;\r\n    }\r\n    @inline get TEXTURE27(): GLenum {\r\n        return TEXTURE27;\r\n    }\r\n    @inline get TEXTURE28(): GLenum {\r\n        return TEXTURE28;\r\n    }\r\n    @inline get TEXTURE29(): GLenum {\r\n        return TEXTURE29;\r\n    }\r\n\r\n    @inline get TEXTURE30(): GLenum {\r\n        return TEXTURE30;\r\n    }\r\n    @inline get TEXTURE31(): GLenum {\r\n        return TEXTURE31;\r\n    }\r\n\r\n    @inline get ACTIVE_TEXTURE(): GLenum {\r\n        return ACTIVE_TEXTURE;\r\n    }\r\n\r\n    @inline get REPEAT(): GLenum {\r\n        return REPEAT;\r\n    }\r\n\r\n    @inline get CLAMP_TO_EDGE(): GLenum {\r\n        return CLAMP_TO_EDGE;\r\n    }\r\n\r\n    @inline get MIRRORED_REPEAT(): GLenum {\r\n        return MIRRORED_REPEAT;\r\n    }\r\n\r\n    @inline get FLOAT_VEC2(): GLenum {\r\n        return FLOAT_VEC2;\r\n    }\r\n\r\n    @inline get FLOAT_VEC3(): GLenum {\r\n        return FLOAT_VEC3;\r\n    }\r\n\r\n    @inline get FLOAT_VEC4(): GLenum {\r\n        return FLOAT_VEC4;\r\n    }\r\n\r\n    @inline get INT_VEC2(): GLenum {\r\n        return INT_VEC2;\r\n    }\r\n\r\n    @inline get INT_VEC3(): GLenum {\r\n        return INT_VEC3;\r\n    }\r\n\r\n    @inline get INT_VEC4(): GLenum {\r\n        return INT_VEC4;\r\n    }\r\n\r\n    @inline get BOOL(): GLenum {\r\n        return BOOL;\r\n    }\r\n\r\n    @inline get BOOL_VEC2(): GLenum {\r\n        return BOOL_VEC2;\r\n    }\r\n\r\n    @inline get BOOL_VEC3(): GLenum {\r\n        return REPEAT;\r\n    }\r\n\r\n    @inline get BOOL_VEC4(): GLenum {\r\n        return BOOL_VEC4;\r\n    }\r\n\r\n    @inline get FLOAT_MAT2(): GLenum {\r\n        return FLOAT_MAT2;\r\n    }\r\n\r\n    @inline get FLOAT_MAT3(): GLenum {\r\n        return FLOAT_MAT3;\r\n    }\r\n\r\n    @inline get FLOAT_MAT4(): GLenum {\r\n        return FLOAT_MAT4;\r\n    }\r\n\r\n    @inline get SAMPLER_2D(): GLenum {\r\n        return SAMPLER_2D;\r\n    }\r\n\r\n    @inline get SAMPLER_CUBE(): GLenum {\r\n        return SAMPLER_CUBE;\r\n    }\r\n\r\n    @inline get VERTEX_ATTRIB_ARRAY_ENABLED(): GLenum {\r\n        return VERTEX_ATTRIB_ARRAY_ENABLED;\r\n    }\r\n\r\n    @inline get VERTEX_ATTRIB_ARRAY_SIZE(): GLenum {\r\n        return VERTEX_ATTRIB_ARRAY_SIZE;\r\n    }\r\n\r\n    @inline get VERTEX_ATTRIB_ARRAY_STRIDE(): GLenum {\r\n        return VERTEX_ATTRIB_ARRAY_STRIDE;\r\n    }\r\n\r\n    @inline get VERTEX_ATTRIB_ARRAY_TYPE(): GLenum {\r\n        return VERTEX_ATTRIB_ARRAY_TYPE;\r\n    }\r\n\r\n    @inline get VERTEX_ATTRIB_ARRAY_NORMALIZED(): GLenum {\r\n        return VERTEX_ATTRIB_ARRAY_NORMALIZED;\r\n    }\r\n\r\n    @inline get VERTEX_ATTRIB_ARRAY_POINTER(): GLenum {\r\n        return VERTEX_ATTRIB_ARRAY_POINTER;\r\n    }\r\n\r\n    @inline get VERTEX_ATTRIB_ARRAY_BUFFER_BINDING(): GLenum {\r\n        return VERTEX_ATTRIB_ARRAY_BUFFER_BINDING;\r\n    }\r\n\r\n    @inline get COMPILE_STATUS(): GLenum {\r\n        return COMPILE_STATUS;\r\n    }\r\n\r\n    @inline get LOW_FLOAT(): GLenum {\r\n        return LOW_FLOAT;\r\n    }\r\n\r\n    @inline get MEDIUM_FLOAT(): GLenum {\r\n        return MEDIUM_FLOAT;\r\n    }\r\n\r\n    @inline get HIGH_FLOAT(): GLenum {\r\n        return HIGH_FLOAT;\r\n    }\r\n\r\n    @inline get LOW_INT(): GLenum {\r\n        return LOW_INT;\r\n    }\r\n\r\n    @inline get MEDIUM_INT(): GLenum {\r\n        return MEDIUM_INT;\r\n    }\r\n\r\n    @inline get HIGH_INT(): GLenum {\r\n        return HIGH_INT;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER(): GLenum {\r\n        return FRAMEBUFFER;\r\n    }\r\n\r\n    @inline get RENDERBUFFER(): GLenum {\r\n        return RENDERBUFFER;\r\n    }\r\n\r\n    @inline get RGBA4(): GLenum {\r\n        return RGBA4;\r\n    }\r\n\r\n    @inline get RGB5_A1(): GLenum {\r\n        return RGB5_A1;\r\n    }\r\n\r\n    @inline get RGB565(): GLenum {\r\n        return RGB565;\r\n    }\r\n\r\n    @inline get DEPTH_COMPONENT16(): GLenum {\r\n        return DEPTH_COMPONENT16;\r\n    }\r\n\r\n    @inline get STENCIL_INDEX(): GLenum {\r\n        return STENCIL_INDEX;\r\n    }\r\n\r\n    @inline get STENCIL_INDEX8(): GLenum {\r\n        return STENCIL_INDEX8;\r\n    }\r\n\r\n    @inline get DEPTH_STENCIL(): GLenum {\r\n        return DEPTH_STENCIL;\r\n    }\r\n\r\n    @inline get RENDERBUFFER_WIDTH(): GLenum {\r\n        return RENDERBUFFER_WIDTH;\r\n    }\r\n\r\n    @inline get RENDERBUFFER_HEIGHT(): GLenum {\r\n        return RENDERBUFFER_HEIGHT;\r\n    }\r\n\r\n    @inline get RENDERBUFFER_INTERNAL_FORMAT(): GLenum {\r\n        return RENDERBUFFER_INTERNAL_FORMAT;\r\n    }\r\n\r\n    @inline get RENDERBUFFER_RED_SIZE(): GLenum {\r\n        return RENDERBUFFER_RED_SIZE;\r\n    }\r\n\r\n    @inline get RENDERBUFFER_GREEN_SIZE(): GLenum {\r\n        return RENDERBUFFER_GREEN_SIZE;\r\n    }\r\n\r\n    @inline get RENDERBUFFER_BLUE_SIZE(): GLenum {\r\n        return RENDERBUFFER_BLUE_SIZE;\r\n    }\r\n\r\n    @inline get RENDERBUFFER_ALPHA_SIZE(): GLenum {\r\n        return RENDERBUFFER_ALPHA_SIZE;\r\n    }\r\n\r\n    @inline get RENDERBUFFER_DEPTH_SIZE(): GLenum {\r\n        return RENDERBUFFER_DEPTH_SIZE;\r\n    }\r\n\r\n    @inline get RENDERBUFFER_STENCIL_SIZE(): GLenum {\r\n        return RENDERBUFFER_STENCIL_SIZE;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE(): GLenum {\r\n        return FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER_ATTACHMENT_OBJECT_NAME(): GLenum {\r\n        return FRAMEBUFFER_ATTACHMENT_OBJECT_NAME;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL(): GLenum {\r\n        return FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE(): GLenum {\r\n        return FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE;\r\n    }\r\n\r\n    @inline get COLOR_ATTACHMENT0(): GLenum {\r\n        return COLOR_ATTACHMENT0;\r\n    }\r\n\r\n    @inline get DEPTH_ATTACHMENT(): GLenum {\r\n        return DEPTH_ATTACHMENT;\r\n    }\r\n\r\n    @inline get STENCIL_ATTACHMENT(): GLenum {\r\n        return STENCIL_ATTACHMENT;\r\n    }\r\n\r\n    @inline get DEPTH_STENCIL_ATTACHMENT(): GLenum {\r\n        return DEPTH_STENCIL_ATTACHMENT;\r\n    }\r\n\r\n    @inline get NONE(): GLenum {\r\n        return NONE;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER_COMPLETE(): GLenum {\r\n        return FRAMEBUFFER_COMPLETE;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER_INCOMPLETE_ATTACHMENT(): GLenum {\r\n        return FRAMEBUFFER_INCOMPLETE_ATTACHMENT;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT(): GLenum {\r\n        return FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER_INCOMPLETE_DIMENSIONS(): GLenum {\r\n        return FRAMEBUFFER_INCOMPLETE_DIMENSIONS;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER_UNSUPPORTED(): GLenum {\r\n        return FRAMEBUFFER_UNSUPPORTED;\r\n    }\r\n\r\n    @inline get FRAMEBUFFER_BINDING(): GLenum {\r\n        return FRAMEBUFFER_BINDING;\r\n    }\r\n\r\n    @inline get RENDERBUFFER_BINDING(): GLenum {\r\n        return RENDERBUFFER_BINDING;\r\n    }\r\n\r\n    @inline get MAX_RENDERBUFFER_SIZE(): GLenum {\r\n        return MAX_RENDERBUFFER_SIZE;\r\n    }\r\n\r\n    @inline get INVALID_FRAMEBUFFER_OPERATION(): GLenum {\r\n        return INVALID_FRAMEBUFFER_OPERATION;\r\n    }\r\n\r\n    @inline get UNPACK_FLIP_Y_WEBGL(): GLenum {\r\n        return UNPACK_FLIP_Y_WEBGL;\r\n    }\r\n\r\n    @inline get UNPACK_PREMULTIPLY_ALPHA_WEBGL(): GLenum {\r\n        return UNPACK_PREMULTIPLY_ALPHA_WEBGL;\r\n    }\r\n\r\n    @inline get CONTEXT_LOST_WEBGL(): GLenum {\r\n        return CONTEXT_LOST_WEBGL;\r\n    }\r\n\r\n    @inline get UNPACK_COLORSPACE_CONVERSION_WEBGL(): GLenum {\r\n        return UNPACK_COLORSPACE_CONVERSION_WEBGL;\r\n    }\r\n\r\n    @inline get BROWSER_DEFAULT_WEBGL(): GLenum {\r\n        return BROWSER_DEFAULT_WEBGL;\r\n    }\r\n\r\n    /*\r\n    @inline getDepth(): GLboolean {\r\n        getDepth(this.gl_id);\r\n    }\r\n    */\r\n\r\n    @inline getDrawingBufferWidth(): GLsizei {\r\n        return getDrawingBufferWidth(this.gl_id);\r\n    }\r\n    @inline getDrawingBufferHeight(): GLsizei {\r\n        return getDrawingBufferHeight(this.gl_id);\r\n    }\r\n\r\n    @inline getContextAttributes(): WebGLContextAttributes {\r\n        return getContextAttributes(this.gl_id);\r\n    }\r\n    @inline isContextLost(): bool {\r\n        return isContextLost(this.gl_id);\r\n    }\r\n\r\n    @inline getSupportedExtensions(): sequence<string> {\r\n        return getSupportedExtensions(this.gl_id);\r\n    }\r\n\r\n    @inline getExtension(name: string): void {\r\n        getExtension(this.gl_id, name);\r\n    }\r\n\r\n    @inline activeTexture(texture: GLenum): void {\r\n        activeTexture(this.gl_id, texture);\r\n    }\r\n\r\n    @inline static createContextFromCanvas(canvas_id: string, context_type: string): WebGLRenderingContext {\r\n    return new WebGLRenderingContext(canvas_id, context_type)\r\n    }\r\n\r\n    @inline attachShader(program: WebGLProgram, shader: WebGLShader): void {\r\n        attachShader(this.gl_id, program, shader);\r\n    }\r\n\r\n    // @inline bindAttribLocation(gl: WebGLRenderingContext, program: WebGLProgram, index: GLuint, name: string): void;\r\n    @inline bindBuffer(target: GLenum, buffer: WebGLBuffer): void {\r\n        bindBuffer(this.gl_id, target, buffer);\r\n    }\r\n    @inline bindFramebuffer(target: GLenum, framebuffer: WebGLFramebuffer): void {\r\n        bindFramebuffer(this.gl_id, target, framebuffer);\r\n    }\r\n    @inline bindRenderbuffer(target: GLenum, renderbuffer: WebGLRenderbuffer): void {\r\n        bindRenderbuffer(this.gl_id, target, renderbuffer);\r\n    }\r\n    @inline bindTexture(target: GLenum, texture: WebGLTexture): void {\r\n        bindTexture(this.gl_id, target, texture);\r\n    }\r\n    @inline blendColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void {\r\n        blendColor(this.gl_id, red, green, blue, alpha);\r\n    }\r\n    @inline blendEquation(mode: GLenum): void {\r\n        blendEquation(this.gl_id, mode);\r\n    }\r\n    @inline blendEquationSeparate(modeRGB: GLenum, modeAlpha: GLenum): void {\r\n        blendEquationSeparate(this.gl_id, modeRGB, modeAlpha);\r\n    }\r\n    @inline blendFunc(sfactor: GLenum, dfactor: GLenum): void {\r\n        blendFunc(this.gl_id, sfactor, dfactor);\r\n    }\r\n    @inline blendFuncSeparate(srcRGB: GLenum, dstRGB: GLenum, srcAlpha: GLenum, dstAlpha: GLenum): void {\r\n        blendFuncSeparate(this.gl_id, srcRGB, dstRGB, srcAlpha, dstAlpha);\r\n    }\r\n    @inline bufferData<T>(target: GLenum, data: StaticArray<T>, usage: GLenum): void {\r\n        bufferData<T>(this.gl_id, target, data, usage);\r\n    }\r\n    @inline bufferSubData<T>(target: GLenum, offset: GLintptr, data: Array<T>): void {\r\n        bufferSubData<T>(this.gl_id, target, offset, data)\r\n    }\r\n\r\n    @inline checkFramebufferStatus(target: GLenum): GLenum {\r\n        return checkFramebufferStatus(this.gl_id, target);\r\n    }\r\n    @inline clear(mask: GLbitfield): void {\r\n        clear(this.gl_id, mask)\r\n    }\r\n\r\n    @inline clearColor(red: GLclampf, green: GLclampf, blue: GLclampf, alpha: GLclampf): void {\r\n        clearColor(this.gl_id, red, green, blue, alpha);\r\n    }\r\n    @inline clearDepth(depth: GLclampf): void {\r\n        clearDepth(this.gl_id, depth);\r\n    }\r\n    @inline clearStencil(s: GLint): void {\r\n        clearStencil(this.gl_id, s);\r\n    }\r\n    @inline colorMask(red: GLboolean, green: GLboolean, blue: GLboolean, alpha: GLboolean): void {\r\n        colorMask(this.gl_id, red, green, blue, alpha);\r\n    }\r\n    @inline compileShader(shader: WebGLShader): void {\r\n        compileShader(this.gl_id, shader);\r\n    }\r\n\r\n    @inline compressedTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei, height: GLsizei, border: GLint, data: ArrayBufferView): void {\r\n        compressedTexImage2D(this.gl_id, target, level, internalformat, width, height, border, data);\r\n    }\r\n    @inline compressedTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, width: GLsizei, height: GLsizei, format: GLenum, data: ArrayBufferView): void {\r\n        compressedTexSubImage2D(this.gl_id, target, level, xoffset, yoffset, width, height, format, data);\r\n    }\r\n\r\n    @inline copyTexImage2D(target: GLenum, level: GLint, internalformat: GLenum, x: GLint, y: GLint, width: GLsizei, height: GLsizei, border: GLint): void {\r\n        copyTexImage2D(this.gl_id, target, level, internalformat, x, y, width, height, border);\r\n    }\r\n    @inline copyTexSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {\r\n        copyTexSubImage2D(this.gl_id, target, level, xoffset, yoffset, x, y, width, height);\r\n    }\r\n\r\n    @inline createBuffer(): WebGLBuffer {\r\n        return createBuffer(this.gl_id);\r\n    }\r\n\r\n    @inline createFramebuffer(): WebGLFramebuffer {\r\n        return createFramebuffer(this.gl_id);\r\n    }\r\n\r\n    @inline createProgram(): WebGLProgram {\r\n        return createProgram(this.gl_id);\r\n    }\r\n    @inline createRenderbuffer(): WebGLRenderbuffer {\r\n        return createRenderbuffer(this.gl_id);\r\n    }\r\n    @inline createShader(typ: GLenum): WebGLShader {\r\n        return createShader(this.gl_id, typ);\r\n    }\r\n\r\n    @inline createTexture(): WebGLTexture {\r\n        return createTexture(this.gl_id)\r\n    }\r\n\r\n    @inline cullFace(mode: GLenum): void {\r\n        cullFace(this.gl_id, mode);\r\n    }\r\n\r\n    @inline deleteBuffer(buffer: WebGLBuffer): void {\r\n        deleteBuffer(this.gl_id, buffer);\r\n    }\r\n\r\n    @inline deleteFramebuffer(framebuffer: WebGLFramebuffer): void {\r\n        deleteFramebuffer(this.gl_id, framebuffer);\r\n    }\r\n\r\n    @inline deleteProgram(program: WebGLProgram): void {\r\n        deleteProgram(this.gl_id, program);\r\n    }\r\n\r\n    @inline deleteRenderbuffer(renderbuffer: WebGLRenderbuffer): void {\r\n        deleteRenderbuffer(this.gl_id, renderbuffer);\r\n    }\r\n    @inline deleteShader(shader: WebGLShader): void {\r\n        deleteShader(this.gl_id, shader);\r\n    }\r\n    @inline deleteTexture(texture: WebGLTexture): void {\r\n        deleteTexture(this.gl_id, texture);\r\n    }\r\n\r\n    @inline depthFunc(func: GLenum): void {\r\n        depthFunc(this.gl_id, func);\r\n    }\r\n    @inline depthMask(flag: GLboolean): void {\r\n        depthMask(this.gl_id, flag);\r\n    }\r\n    @inline depthRange(zNear: GLclampf, zFar: GLclampf): void {\r\n        depthRange(this.gl_id, zNear, zFar);\r\n    }\r\n\r\n    @inline detachShader(program: WebGLProgram, shader: WebGLShader): void {\r\n        detachShader(this.gl_id, program, shader);\r\n    }\r\n    @inline disable(cap: GLenum): void {\r\n        disable(this.gl_id, cap);\r\n    }\r\n    @inline disableVertexAttribArray(index: GLuint): void {\r\n        disableVertexAttribArray(this.gl_id, index);\r\n    }\r\n    @inline drawArrays(mode: GLenum, first: GLint, count: GLsizei): void {\r\n        drawArrays(this.gl_id, mode, first, count)\r\n    }\r\n    @inline drawElements(mode: GLenum, count: GLsizei, typ: GLenum, offset: GLintptr): void {\r\n        drawElements(this.gl_id, mode, count, typ, offset);\r\n    }\r\n\r\n    @inline enable(cap: GLenum): void {\r\n        enable(this.gl_id, cap);\r\n    }\r\n\r\n    @inline enableVertexAttribArray(index: GLuint): void {\r\n        enableVertexAttribArray(this.gl_id, index);\r\n    }\r\n    @inline finish(): void {\r\n        finish(this.gl_id);\r\n    }\r\n    @inline flush(): void {\r\n        flush(this.gl_id);\r\n    }\r\n    @inline framebufferRenderbuffer(target: GLenum, attachment: GLenum, renderbuffertarget: GLenum, renderbuffer: WebGLRenderbuffer): void {\r\n        framebufferRenderbuffer(this.gl_id, target, attachment, renderbuffertarget, renderbuffer);\r\n    }\r\n    @inline framebufferTexture2D(target: GLenum, attachment: GLenum, textarget: GLenum, texture: WebGLTexture, level: GLint): void {\r\n        framebufferTexture2D(this.gl_id, target, attachment, textarget, texture, level);\r\n    }\r\n    @inline frontFace(mode: GLenum): void {\r\n        frontFace(this.gl_id, mode);\r\n    }\r\n\r\n    @inline generateMipmap(target: GLenum): void {\r\n        generateMipmap(this.gl_id, target)\r\n    }\r\n\r\n    @inline getActiveAttrib(program: WebGLProgram, index: GLuint): WebGLActiveInfo {\r\n        return getActiveAttrib(this.gl_id, program, index);\r\n    }\r\n    @inline getActiveUniform(program: WebGLProgram, index: GLuint): WebGLActiveInfo {\r\n        return getActiveUniform(this.gl_id, program, index);\r\n    }\r\n    @inline getAttachedShaders(program: WebGLProgram): sequence<WebGLShader> {\r\n        return getAttachedShaders(this.gl_id, program);\r\n    }\r\n\r\n    @inline getAttribLocation(program: WebGLProgram, name: string): GLint {\r\n        return getAttribLocation(this.gl_id, program, name);\r\n    }\r\n\r\n    @inline getBufferParameter(target: GLenum, pname: GLenum): externref {\r\n        return getBufferParameter(this.gl_id, target, pname);\r\n    }\r\n    @inline getParameter(pname: GLenum): externref {\r\n        return getParameter(this.gl_id, pname);\r\n    }\r\n\r\n    @inline getError(): GLenum {\r\n        return getError(this.gl_id);\r\n    }\r\n\r\n    @inline getFramebufferAttachmentParameter(target: GLenum, attachment: GLenum, pname: GLenum): externref {\r\n        return getFramebufferAttachmentParameter(this.gl_id, target, attachment, pname);\r\n    }\r\n    @inline getProgramParameter(program: WebGLProgram, pname: GLenum): bool {\r\n        return getProgramParameter(this.gl_id, program, pname);\r\n    }\r\n    @inline getProgramInfoLog(program: WebGLProgram): DOMString {\r\n        return getProgramInfoLog(this.gl_id, program);\r\n    }\r\n    @inline getRenderbufferParameter(target: GLenum, pname: GLenum): externref {\r\n        return getRenderbufferParameter(this.gl_id, target, pname);\r\n    }\r\n    @inline getShaderParameter(shader: WebGLShader, pname: GLenum): bool {\r\n        return getShaderParameter(this.gl_id, shader, pname);\r\n    }\r\n    @inline getShaderPrecisionFormat(shadertype: GLenum, precisiontype: GLenum): WebGLShaderPrecisionFormat {\r\n        return getShaderPrecisionFormat(this.gl_id, shadertype, precisiontype);\r\n    }\r\n\r\n    @inline getShaderInfoLog(shader: WebGLShader): DOMString {\r\n        return getShaderInfoLog(this.gl_id, shader);\r\n    }\r\n\r\n    @inline getShaderSource(shader: WebGLShader): DOMString {\r\n        return getShaderSource(this.gl_id, shader);\r\n    }\r\n\r\n    @inline getTexParameter(target: GLenum, pname: GLenum): externref {\r\n        return getTexParameter(this.gl_id, target, pname);\r\n    }\r\n\r\n    @inline getUniform(program: WebGLProgram, location: WebGLUniformLocation): externref {\r\n        return getUniform(this.gl_id, program, location);\r\n    }\r\n\r\n    @inline getUniformLocation(program: WebGLProgram, name: string): WebGLUniformLocation {\r\n        return getUniformLocation(this.gl_id, program, name);\r\n    }\r\n\r\n    @inline getVertexAttrib(index: GLuint, pname: GLenum): externref {\r\n        return getVertexAttrib(this.gl_id, index, pname);\r\n    }\r\n\r\n    @inline getVertexAttribOffset(index: GLuint, pname: GLenum): GLsizeiptr {\r\n        return getVertexAttribOffset(this.gl_id, index, pname);\r\n    }\r\n\r\n    @inline hint(target: GLenum, mode: GLenum): void {\r\n        hint(this.gl_id, target, mode);\r\n    }\r\n\r\n    @inline isBuffer(buffer: WebGLBuffer): GLboolean {\r\n        return isBuffer(this.gl_id, buffer);\r\n    }\r\n    @inline isEnabled(cap: GLenum): GLboolean {\r\n        return isEnabled(this.gl_id, cap);\r\n    }\r\n    @inline isFramebuffer(framebuffer: WebGLFramebuffer): GLboolean {\r\n        return isFramebuffer(this.gl_id, framebuffer);\r\n    }\r\n    @inline isProgram(program: WebGLProgram): GLboolean {\r\n        return isProgram(this.gl_id, program);\r\n    }\r\n    @inline isRenderbuffer(renderbuffer: WebGLRenderbuffer): GLboolean {\r\n        return isRenderbuffer(this.gl_id, renderbuffer);\r\n    }\r\n    @inline isShader(shader: WebGLShader): GLboolean {\r\n        return isShader(this.gl_id, shader);\r\n    }\r\n    @inline isTexture(texture: WebGLTexture): GLboolean {\r\n        return isTexture(this.gl_id, texture);\r\n    }\r\n    @inline lineWidth(width: GLfloat): void {\r\n        lineWidth(this.gl_id, width);\r\n    }\r\n    @inline linkProgram(program: WebGLProgram): void {\r\n        linkProgram(this.gl_id, program);\r\n    }\r\n    @inline pixelStorei(pname: GLenum, param: GLint): void {\r\n        pixelStorei(this.gl_id, pname, param);\r\n    }\r\n    @inline polygonOffset(factor: GLfloat, units: GLfloat): void {\r\n        polygonOffset(this.gl_id, factor, units);\r\n    }\r\n\r\n    @inline readPixels(x: GLint, y: GLint, width: GLsizei, height: GLsizei,\r\n        format: GLenum, typ: GLenum, pixels: ArrayBufferView): void {\r\n        readPixels(this.gl_id, x, y, width, height, format, typ, pixels);\r\n    }\r\n\r\n    @inline renderbufferStorage(target: GLenum, internalformat: GLenum, width: GLsizei, height: GLsizei): void {\r\n        renderbufferStorage(this.gl_id, target, internalformat, width, height);\r\n    }\r\n    @inline sampleCoverage(value: GLclampf, invert: GLboolean): void {\r\n        sampleCoverage(this.gl_id, value, invert);\r\n    }\r\n    @inline scissor(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {\r\n        scissor(this.gl_id, x, y, width, height);\r\n    }\r\n\r\n    @inline shaderSource(shader: WebGLShader, source: string): void {\r\n        shaderSource(this.gl_id, shader, source);\r\n    }\r\n\r\n    @inline stencilFunc(func: GLenum, ref: GLint, mask: GLuint): void {\r\n        stencilFunc(this.gl_id, func, ref, mask);\r\n    }\r\n    @inline stencilFuncSeparate(face: GLenum, func: GLenum, ref: GLint, mask: GLuint): void {\r\n        stencilFuncSeparate(this.gl_id, face, func, ref, mask);\r\n    }\r\n    @inline stencilMask(mask: GLuint): void {\r\n        stencilMask(this.gl_id, mask);\r\n    }\r\n    @inline stencilMaskSeparate(face: GLenum, mask: GLuint): void {\r\n        stencilMaskSeparate(this.gl_id, face, mask);\r\n    }\r\n    @inline stencilOp(fail: GLenum, zfail: GLenum, zpass: GLenum): void {\r\n        stencilOp(this.gl_id, fail, zfail, zpass);\r\n    }\r\n    @inline stencilOpSeparate(face: GLenum, fail: GLenum, zfail: GLenum, zpass: GLenum): void {\r\n        stencilOpSeparate(this.gl_id, face, fail, zfail, zpass);\r\n    }\r\n\r\n    @inline texImage2D(target: GLenum, level: GLint, internalformat: GLenum,\r\n        format: GLenum, typ: GLenum, image: ImageData): void {\r\n        texImage2D(this.gl_id, target, level, internalformat, format, typ, image);\r\n    }\r\n\r\n    @inline texParameterf(target: GLenum, pname: GLenum, param: GLfloat): void {\r\n        texParameterf(this.gl_id, target, pname, param);\r\n    }\r\n    @inline texParameteri(target: GLenum, pname: GLenum, param: GLint): void {\r\n        texParameteri(this.gl_id, target, pname, param);\r\n    }\r\n\r\n    @inline texSubImage2D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,\r\n        format: GLenum, typ: GLenum, pixels: ImageData): void {\r\n        texSubImage2D(this.gl_id, target, level, xoffset, yoffset, format, typ, pixels);\r\n    }\r\n\r\n    @inline uniform1f(location: WebGLUniformLocation, x: GLfloat): void {\r\n        uniform1f(this.gl_id, location, x);\r\n    }\r\n    @inline uniform1fv(location: WebGLUniformLocation, v: StaticArray<GLfloat>): void {\r\n        uniform1fv(this.gl_id, location, v);\r\n    }\r\n\r\n    @inline uniform1i(location: WebGLUniformLocation, x: GLint): void {\r\n        uniform1i(this.gl_id, location, x);\r\n    }\r\n    @inline uniform1iv(location: WebGLUniformLocation, v: StaticArray<GLint>): void {\r\n        uniform1iv(this.gl_id, location, v);\r\n    }\r\n\r\n    @inline uniform2f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat): void {\r\n        uniform2f(this.gl_id, location, x, y);\r\n    }\r\n    @inline uniform2fv(location: WebGLUniformLocation, v: StaticArray<GLfloat>): void {\r\n        uniform2fv(this.gl_id, location, v);\r\n    }\r\n\r\n    @inline uniform2i(location: WebGLUniformLocation, x: GLint, y: GLint): void {\r\n        uniform2i(this.gl_id, location, x, y);\r\n    }\r\n    @inline uniform2iv(location: WebGLUniformLocation, v: StaticArray<GLint>): void {\r\n        uniform2iv(this.gl_id, location, v);\r\n    }\r\n\r\n    @inline uniform3f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat): void {\r\n        uniform3f(this.gl_id, location, x, y, z);\r\n    }\r\n    @inline uniform3fv(location: WebGLUniformLocation, v: StaticArray<GLfloat>): void {\r\n        uniform3fv(this.gl_id, location, v);\r\n    }\r\n\r\n    @inline uniform3i(location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint): void {\r\n        uniform3i(this.gl_id, location, x, y, z);\r\n    }\r\n    @inline uniform3iv(location: WebGLUniformLocation, v: StaticArray<GLint>): void {\r\n        uniform3iv(this.gl_id, location, v);\r\n    }\r\n\r\n    @inline uniform4f(location: WebGLUniformLocation, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void {\r\n        uniform4f(this.gl_id, location, x, y, z, w);\r\n    }\r\n\r\n    @inline uniform4fv(location: WebGLUniformLocation, v: StaticArray<GLfloat>): void {\r\n        uniform4fv(this.gl_id, location, v);\r\n    }\r\n\r\n    @inline uniform4i(location: WebGLUniformLocation, x: GLint, y: GLint, z: GLint, w: GLint): void {\r\n        uniform4i(this.gl_id, location, x, y, z, w);\r\n    }\r\n\r\n    @inline uniform4iv(location: WebGLUniformLocation, v: StaticArray<GLint>): void {\r\n        uniform4iv(this.gl_id, location, v);\r\n    }\r\n\r\n    @inline uniformMatrix2fv(location: WebGLUniformLocation, transpose: GLboolean, value: StaticArray<GLfloat>): void {\r\n        uniformMatrix2fv(this.gl_id, location, transpose, value);\r\n    }\r\n\r\n    @inline uniformMatrix3fv(location: WebGLUniformLocation, transpose: GLboolean, value: StaticArray<GLfloat>): void {\r\n        uniformMatrix3fv(this.gl_id, location, transpose, value);\r\n    }\r\n\r\n    @inline uniformMatrix4fv(location: WebGLUniformLocation, transpose: GLboolean, value: StaticArray<GLfloat>): void {\r\n        uniformMatrix4fv(this.gl_id, location, transpose, value);\r\n    }\r\n    @inline useProgram(program: WebGLProgram): void {\r\n        useProgram(this.gl_id, program);\r\n    }\r\n    @inline validateProgram(program: WebGLProgram): void {\r\n        validateProgram(this.gl_id, program);\r\n    }\r\n\r\n    @inline vertexAttrib1f(indx: GLuint, x: GLfloat): void {\r\n        vertexAttrib1f(this.gl_id, indx, x);\r\n    }\r\n\r\n    @inline vertexAttrib1fv(indx: GLuint, values: StaticArray<GLfloat>): void {\r\n        vertexAttrib1fv(this.gl_id, indx, values);\r\n    }\r\n\r\n    @inline vertexAttrib2f(indx: GLuint, x: GLfloat, y: GLfloat): void {\r\n        vertexAttrib2f(this.gl_id, indx, x, y);\r\n    }\r\n\r\n    @inline vertexAttrib2fv(indx: GLuint, values: StaticArray<GLfloat>): void {\r\n        vertexAttrib2fv(this.gl_id, indx, values);\r\n    }\r\n\r\n    @inline vertexAttrib3f(indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat): void {\r\n        vertexAttrib3f(this.gl_id, indx, x, y, z);\r\n    }\r\n    @inline vertexAttrib3fv(indx: GLuint, values: StaticArray<GLfloat>): void {\r\n        vertexAttrib3fv(this.gl_id, indx, values);\r\n    }\r\n\r\n    @inline vertexAttrib4f(indx: GLuint, x: GLfloat, y: GLfloat, z: GLfloat, w: GLfloat): void {\r\n        vertexAttrib4f(this.gl_id, indx, x, y, z, w)\r\n    }\r\n    @inline vertexAttrib4fv(indx: GLuint, values: StaticArray<GLfloat>): void {\r\n        vertexAttrib4fv(this.gl_id, indx, values)\r\n    }\r\n\r\n    @inline vertexAttribPointer(indx: GLint, size: GLint, typ: GLenum,\r\n        normalized: GLint, stride: GLsizei, offset: GLintptr): void {\r\n        vertexAttribPointer(this.gl_id, indx, size, typ, normalized, stride, offset);\r\n    }\r\n\r\n    @inline viewport(x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {\r\n        viewport(this.gl_id, x, y, width, height);\r\n    }\r\n\r\n    @inline copyBufferSubData(readTarget: GLenum, writeTarget: GLenum, readOffset: GLintptr,\r\n        writeOffset: GLintptr, size: GLsizeiptr): void {\r\n        copyBufferSubData(this.gl_id, readTarget, writeTarget, readOffset, writeOffset, size);\r\n    }\r\n\r\n    @inline getBufferSubData(gl: WebGLRenderingContext, target: GLenum, srcByteOffset: GLintptr, dstBuffer: ArrayBufferView,\r\n        dstOffset: GLuint = 0, length: GLuint = 0): void {\r\n        getBufferSubData(this.gl_id, target, srcByteOffset, dstBuffer, dstOffset, length);\r\n    }\r\n\r\n    @inline blitFramebuffer(gl: WebGLRenderingContext, srcX0: GLint, srcY0: GLint, srcX1: GLint, srcY1: GLint,\r\n        dstX0: GLint, dstY0: GLint, dstX1: GLint, dstY1: GLint,\r\n        mask: GLbitfield, filter: GLenum): void {\r\n        blitFramebuffer(this.gl_id, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);\r\n    }\r\n    @inline framebufferTextureLayer(target: GLenum, attachment: GLenum, texture: WebGLTexture, level: GLint, layer: GLint): void {\r\n        framebufferTextureLayer(this.gl_id, target, attachment, texture, level, layer);\r\n    }\r\n    @inline invalidateFramebuffer(target: GLenum, attachments: sequence<GLenum>): void {\r\n        invalidateFramebuffer(this.gl_id, target, attachments);\r\n    }\r\n\r\n    @inline invalidateSubFramebuffer(target: GLenum, attachments: sequence<GLenum>,\r\n        x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {\r\n        invalidateSubFramebuffer(this.gl_id, target, attachments, x, y, width, height);\r\n    }\r\n    @inline readBuffer(src: GLenum): void {\r\n        readBuffer(this.gl_id, src);\r\n    }\r\n\r\n    @inline getInternalformatParameter(target: GLenum, internalformat: GLenum, pname: GLenum): externref {\r\n        return getInternalformatParameter(this.gl_id, target, internalformat, pname);\r\n    }\r\n    @inline renderbufferStorageMultisample(target: GLenum, samples: GLsizei, internalformat: GLenum,\r\n        width: GLsizei, height: GLsizei): void {\r\n        renderbufferStorageMultisample(this.gl_id, target, samples, internalformat, width, height);\r\n    }\r\n\r\n    @inline texStorage2D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei, height: GLsizei): void {\r\n        texStorage2D(this.gl_id, target, levels, internalformat, width, height);\r\n    }\r\n    @inline texStorage3D(target: GLenum, levels: GLsizei, internalformat: GLenum, width: GLsizei,\r\n        height: GLsizei, depth: GLsizei): void {\r\n        texStorage3D(this.gl_id, target, levels, internalformat, width, height, depth);\r\n    }\r\n\r\n    @inline texImage3D(target: GLenum, level: GLint, internalformat: GLint, width: GLsizei, height: GLsizei,\r\n        depth: GLsizei, border: GLint, format: GLenum, typ: GLenum, pboOffset: GLintptr): void {\r\n        texImage3D(this.gl_id, target, level, internalformat, width, height, depth, border, format, typ, pboOffset);\r\n    }\r\n\r\n    @inline texSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint,\r\n        width: GLsizei, height: GLsizei, depth: GLsizei, format: GLenum, typ: GLenum,\r\n        pboOffset: GLintptr): void {\r\n        texSubImage3D(this.gl_id, target, level, xoffset, yoffset, zoffset,\r\n            width, height, depth, format, typ, pboOffset);\r\n    }\r\n\r\n    @inline copyTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint, zoffset: GLint,\r\n        x: GLint, y: GLint, width: GLsizei, height: GLsizei): void {\r\n        copyTexSubImage3D(this.gl_id, target, level, xoffset, yoffset, zoffset, x, y, width, height);\r\n    }\r\n\r\n    @inline compressedTexImage3D(target: GLenum, level: GLint, internalformat: GLenum, width: GLsizei,\r\n        height: GLsizei, depth: GLsizei, border: GLint, imageSize: GLsizei, offset: GLintptr): void {\r\n        compressedTexImage3D(this.gl_id, target, level, internalformat, width, height,\r\n            depth, border, imageSize, offset);\r\n    }\r\n\r\n    @inline compressedTexSubImage3D(target: GLenum, level: GLint, xoffset: GLint, yoffset: GLint,\r\n        zoffset: GLint, width: GLsizei, height: GLsizei, depth: GLsizei,\r\n        format: GLenum, imageSize: GLsizei, offset: GLintptr): void {\r\n        compressedTexSubImage3D(this.gl_id, target, level, xoffset, yoffset, zoffset, width, height, depth,\r\n            format, imageSize, offset);\r\n    }\r\n\r\n    @inline getFragDataLocation(program: WebGLProgram, name: DOMString): GLint {\r\n        return getFragDataLocation(this.gl_id, program, name);\r\n    }\r\n\r\n    @inline uniform1ui(location: WebGLUniformLocation, v0: GLuint): void {\r\n        uniform1ui(this.gl_id, location, v0);\r\n    }\r\n    @inline uniform2ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint): void {\r\n        uniform2ui(this.gl_id, location, v0, v1);\r\n    }\r\n    @inline uniform3ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint): void {\r\n        uniform3ui(this.gl_id, location, v0, v1, v2);\r\n    }\r\n    @inline uniform4ui(location: WebGLUniformLocation, v0: GLuint, v1: GLuint, v2: GLuint, v3: GLuint): void {\r\n        uniform4ui(this.gl_id, location, v0, v1, v2, v3);\r\n    }\r\n\r\n    @inline uniform1uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0,\r\n        srcLength: GLuint = 0): void {\r\n        uniform1uiv(this.gl_id, location, data, srcOffset, srcLength);\r\n    }\r\n\r\n    @inline uniform2uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void {\r\n        uniform2uiv(this.gl_id, location, data, srcOffset, srcLength);\r\n    }\r\n    @inline uniform3uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0, srcLength: GLuint = 0): void {\r\n        uniform3uiv(this.gl_id, location, data, srcOffset, srcLength);\r\n    }\r\n    @inline uniform4uiv(location: WebGLUniformLocation, data: Uint32List, srcOffset: GLuint = 0,\r\n        srcLength: GLuint = 0): void {\r\n        uniform4uiv(this.gl_id, location, data, srcOffset, srcLength);\r\n    }\r\n    @inline uniformMatrix3x2fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\r\n        srcOffset: GLuint = 0, srcLength: GLuint = 0): void {\r\n        uniformMatrix3x2fv(this.gl_id, location, transpose, data, srcOffset, srcLength);\r\n    }\r\n    @inline uniformMatrix4x2fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\r\n        srcOffset: GLuint = 0, srcLength: GLuint = 0): void {\r\n        uniformMatrix4x2fv(this.gl_id, location, transpose, data, srcOffset, srcLength);\r\n    }\r\n\r\n    @inline uniformMatrix2x3fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\r\n        srcOffset: GLuint = 0, srcLength: GLuint = 0): void {\r\n        uniformMatrix2x3fv(this.gl_id, location, transpose, data, srcOffset, srcLength);\r\n    }\r\n    @inline uniformMatrix4x3fv(gl: WebGLRenderingContext, location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\r\n        srcOffset: GLuint = 0, srcLength: GLuint = 0): void {\r\n        uniformMatrix4x3fv(this.gl_id, location, transpose, data, srcOffset, srcLength);\r\n    }\r\n\r\n    @inline uniformMatrix2x4fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\r\n        srcOffset: GLuint = 0, srcLength: GLuint = 0): void {\r\n        uniformMatrix2x4fv(this.gl_id, location, transpose, data, srcOffset, srcLength);\r\n    }\r\n    @inline uniformMatrix3x4fv(location: WebGLUniformLocation, transpose: GLboolean, data: Float32List,\r\n        srcOffset: GLuint = 0, srcLength: GLuint = 0): void {\r\n        uniformMatrix3x4fv(this.gl_id, location, transpose, data,\r\n            srcOffset, srcLength);\r\n    }\r\n\r\n    /* Vertex attribs */\r\n    @inline vertexAttribI4i(index: GLuint, x: GLint, y: GLint, z: GLint, w: GLint): void {\r\n        vertexAttribI4i(this.gl_id, index, x, y, z, w)\r\n    }\r\n    @inline vertexAttribI4iv(index: GLuint, values: Int32List): void {\r\n        vertexAttribI4iv(this.gl_id, index, values);\r\n    }\r\n    @inline vertexAttribI4ui(index: GLuint, x: GLuint, y: GLuint, z: GLuint, w: GLuint): void {\r\n        vertexAttribI4ui(this.gl_id, index, x, y, z, w);\r\n    }\r\n    @inline vertexAttribI4uiv(index: GLuint, values: Uint32List): void {\r\n        vertexAttribI4uiv(this.gl_id, index, values);\r\n    }\r\n    @inline vertexAttribIPointer(index: GLuint, size: GLint, typ: GLenum, stride: GLsizei, offset: GLintptr): void {\r\n        vertexAttribIPointer(this.gl_id, index, size, typ, stride, offset)\r\n    }\r\n\r\n    @inline vertexAttribDivisor(index: GLuint, divisor: GLuint): void {\r\n        vertexAttribDivisor(this.gl_id, index, divisor);\r\n    }\r\n    @inline drawArraysInstanced(mode: GLenum, first: GLint, count: GLsizei, instanceCount: GLsizei): void {\r\n        drawArraysInstanced(this.gl_id, mode, first, count, instanceCount);\r\n    }\r\n    @inline drawElementsInstanced(mode: GLenum, count: GLsizei, typ: GLenum, offset: GLintptr, instanceCount: GLsizei): void {\r\n        drawElementsInstanced(this.gl_id, mode, count, typ, offset, instanceCount);\r\n    }\r\n    @inline drawRangeElements(mode: GLenum, start: GLuint, end: GLuint, count: GLsizei, typ: GLenum, offset: GLintptr): void {\r\n        drawRangeElements(this.gl_id, mode, start, end, count, typ, offset);\r\n    }\r\n\r\n    @inline drawBuffers(gl: WebGLRenderingContext, buffers: sequence<GLenum>): void {\r\n        drawBuffers(this.gl_id, buffers);\r\n    }\r\n\r\n    @inline clearBufferfv(buffer: GLenum, drawbuffer: GLint, values: Float32List, srcOffset: GLuint = 0): void {\r\n        clearBufferfv(this.gl_id, buffer, drawbuffer, values, srcOffset);\r\n    }\r\n    @inline clearBufferiv(buffer: GLenum, drawbuffer: GLint, values: Int32List,\r\n        srcOffset: GLuint = 0): void {\r\n        clearBufferiv(this.gl_id, buffer, drawbuffer, values, srcOffset);\r\n    }\r\n    @inline clearBufferuiv(buffer: GLenum, drawbuffer: GLint, values: Uint32List,\r\n        srcOffset: GLuint = 0): void {\r\n        clearBufferuiv(this.gl_id, buffer, drawbuffer, values, srcOffset);\r\n    }\r\n\r\n    @inline clearBufferfi(buffer: GLenum, drawbuffer: GLint, depth: GLfloat, stencil: GLint): void {\r\n        clearBufferfi(this.gl_id, buffer, drawbuffer, depth, stencil);\r\n    }\r\n\r\n    /* Query Objects */\r\n    @inline createQuery(): WebGLQuery {\r\n        return createQuery(this.gl_id);\r\n    }\r\n    @inline deleteQuery(query: WebGLQuery): void {\r\n        deleteQuery(this.gl_id, query);\r\n    }\r\n\r\n    @inline isQuery(query: WebGLQuery): GLboolean {\r\n        return isQuery(this.gl_id, query);\r\n    }\r\n    @inline beginQuery(target: GLenum, query: WebGLQuery): void {\r\n        beginQuery(this.gl_id, target, query);\r\n    }\r\n    @inline endQuery(target: GLenum): void {\r\n        endQuery(this.gl_id, target)\r\n    }\r\n    @inline getQuery(target: GLenum, pname: GLenum): WebGLQuery {\r\n        return getQuery(this.gl_id, target, pname);\r\n    }\r\n    @inline getQueryParameter(query: WebGLQuery, pname: GLenum): externref {\r\n        return getQueryParameter(this.gl_id, query, pname);\r\n    }\r\n\r\n    @inline createSampler(): WebGLSampler {\r\n        return createSampler(this.gl_id);\r\n    }\r\n\r\n    @inline deleteSampler(sampler: WebGLSampler): void {\r\n        deleteSampler(this.gl_id, sampler);\r\n    }\r\n\r\n    @inline isSampler(sampler: WebGLSampler): GLboolean {\r\n        return isSampler(this.gl_id, sampler);\r\n    }\r\n\r\n    @inline bindSampler(unit: GLuint, sampler: WebGLSampler): void {\r\n        bindSampler(this.gl_id, unit, sampler);\r\n    }\r\n    @inline samplerParameteri(sampler: WebGLSampler, pname: GLenum, param: GLint): void {\r\n        samplerParameteri(this.gl_id, sampler, pname, param);\r\n    }\r\n    @inline samplerParameterf(sampler: WebGLSampler, pname: GLenum, param: GLfloat): void {\r\n        samplerParameterf(this.gl_id, sampler, pname, param);\r\n    }\r\n    @inline getSamplerParameter(sampler: WebGLSampler, pname: GLenum): externref {\r\n        return getSamplerParameter(this.gl_id, sampler, pname);\r\n    }\r\n\r\n    /* Sync objects */\r\n    @inline fenceSync(condition: GLenum, flags: GLbitfield): WebGLSync {\r\n        return fenceSync(this.gl_id, condition, flags);\r\n    }\r\n    /*[WebGLHandlesContextLoss]*/\r\n    @inline isSync(sync: WebGLSync): GLboolean {\r\n        return isSync(this.gl_id, sync);\r\n    }\r\n\r\n    @inline deleteSync(sync: WebGLSync): void {\r\n        deleteSync(this.gl_id, sync);\r\n    }\r\n\r\n    @inline clientWaitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLuint64): GLenum {\r\n        return clientWaitSync(this.gl_id, sync, flags, timeout);\r\n    }\r\n    @inline waitSync(sync: WebGLSync, flags: GLbitfield, timeout: GLint64): void {\r\n        waitSync(this.gl_id, sync, flags, timeout);\r\n    }\r\n    @inline getSyncParameter(sync: WebGLSync, pname: GLenum): externref {\r\n        return getSyncParameter(this.gl_id, sync, pname);\r\n    }\r\n\r\n    @inline createTransformFeedback(): WebGLTransformFeedback {\r\n        return createTransformFeedback(this.gl_id);\r\n    }\r\n    @inline deleteTransformFeedback(tf: WebGLTransformFeedback): void {\r\n        deleteTransformFeedback(this.gl_id, tf);\r\n    }\r\n\r\n    @inline isTransformFeedback(tf: WebGLTransformFeedback): GLboolean {\r\n        return isTransformFeedback(this.gl_id, tf);\r\n    }\r\n    @inline bindTransformFeedback(target: GLenum, tf: WebGLTransformFeedback): void {\r\n        bindTransformFeedback(this.gl_id, target, tf);\r\n    }\r\n    @inline beginTransformFeedback(primitiveMode: GLenum): void {\r\n        beginTransformFeedback(this.gl_id, primitiveMode);\r\n    }\r\n\r\n    @inline endTransformFeedback(): void {\r\n        endTransformFeedback(this.gl_id);\r\n    }\r\n\r\n    @inline transformFeedbackVaryings(program: WebGLProgram, varyings: sequence<DOMString>, bufferMode: GLenum): void {\r\n        transformFeedbackVaryings(this.gl_id, program, varyings, bufferMode);\r\n    }\r\n    @inline getTransformFeedbackVarying(program: WebGLProgram, index: GLuint): WebGLActiveInfo {\r\n        return getTransformFeedbackVarying(this.gl_id, program, index);\r\n    }\r\n    @inline pauseTransformFeedback(): void {\r\n        pauseTransformFeedback(this.gl_id);\r\n    }\r\n\r\n    @inline resumeTransformFeedback(): void {\r\n        resumeTransformFeedback(this.gl_id);\r\n    }\r\n\r\n    @inline bindBufferBase(target: GLenum, index: GLuint, buffer: WebGLBuffer): void {\r\n        bindBufferBase(this.gl_id, target, index, buffer);\r\n    }\r\n    @inline bindBufferRange(target: GLenum, index: GLuint, buffer: WebGLBuffer,\r\n        offset: GLintptr, size: GLsizeiptr): void {\r\n        bindBufferRange(this.gl_id, target, index, buffer, offset, size);\r\n    }\r\n    @inline getIndexedParameter(target: GLenum, index: GLuint): externref {\r\n        return getIndexedParameter(this.gl_id, target, index);\r\n    }\r\n    @inline getUniformIndices(program: WebGLProgram, uniformNames: sequence<DOMString>): sequence<GLuint> {\r\n        return getUniformIndices(this.gl_id, program, uniformNames);\r\n    }\r\n    @inline getActiveUniforms(program: WebGLProgram, uniformIndices: sequence<GLuint>, pname: GLenum): externref {\r\n        return getActiveUniforms(this.gl_id, program, uniformIndices, pname);\r\n    }\r\n    @inline getUniformBlockIndex(program: WebGLProgram, uniformBlockName: DOMString): GLuint {\r\n        return getUniformBlockIndex(this.gl_id, program, uniformBlockName);\r\n    }\r\n    @inline getActiveUniformBlockParameter(program: WebGLProgram, uniformBlockIndex: GLuint, pname: GLenum): externref {\r\n        return getActiveUniformBlockParameter(this.gl_id, program, uniformBlockIndex, pname);\r\n    }\r\n    @inline getActiveUniformBlockName(program: WebGLProgram, uniformBlockIndex: GLuint): DOMString {\r\n        return getActiveUniformBlockName(this.gl_id, program, uniformBlockIndex);\r\n    }\r\n    @inline uniformBlockBinding(program: WebGLProgram, uniformBlockIndex: GLuint, _uniformBlockBinding: GLuint): void {\r\n        uniformBlockBinding(this.gl_id, program, uniformBlockIndex, _uniformBlockBinding);\r\n    }\r\n\r\n    @inline createVertexArray(): WebGLVertexArrayObject {\r\n        return createVertexArray(this.gl_id);\r\n    }\r\n    @inline deleteVertexArray(vertexArray: WebGLVertexArrayObject): void {\r\n        deleteVertexArray(this.gl_id, vertexArray);\r\n    }\r\n\r\n    @inline isVertexArray(vertexArray: WebGLVertexArrayObject): GLboolean {\r\n        return isVertexArray(this.gl_id, vertexArray);\r\n    }\r\n\r\n    @inline bindVertexArray(array: WebGLVertexArrayObject): void {\r\n        bindVertexArray(this.gl_id, array)\r\n    }\r\n\r\n}\r\n\r\n//const gl: WebGLRenderingContext = canvas.getContext(\"webgl\");\r\n//gl.compileShader(\".....\");\r\n","//------------------------------------------------------------------------------\r\n// Imports\r\n\r\nexport declare function consoleLog(message: string): void\r\nexport declare function getMilliseconds(): f64\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Netcode\r\n\r\nexport namespace Netcode {\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Constants\r\n\r\n// Width/height of map\r\nexport const kMapWidth: f32 = 32000.0;\r\n\r\n// Maximum number of teams\r\nexport const kMaxTeams: i32 = 5;\r\n\r\n/*\r\n    Maximum packet size = 1100 bytes before splitting,\r\n    since there are about 64 bytes of overhead from WebRTC,\r\n    and we want to conservatively fit within UDP/IPv6 frame MTU.\r\n*/\r\nexport const kMaxPacketBytes: i32 = 1100;\r\n\r\n\r\n/*\r\n    Unreliable packet formats:\r\n\r\n    All packets can be appended to eachother.\r\n\r\n    [UnreliableType.TimeSync(1 byte)]\r\n    [Local-24bit-SendTimestamp(3 bytes)]\r\n    [min_trip_send_ts24_trunc(3 bytes)] [min_trip_recv_ts24_trunc(3 bytes)]\r\n    [ClockDriftSlope(4 bytes)]\r\n    Sent once a second by both sides.  Used to establish time sync.\r\n    Includes a send timestamp for additional data points.\r\n    Includes the probe received from remote peer we estimate had the shorted trip time,\r\n    providing that probe's 24-bit send timestamp and 24-bit receive timestamp.\r\n    Includes our best estimate of the clock drift slope.\r\n\r\n    [UnreliableType.TimeSyncPong(1 byte)] [Timestamp from sender(3 bytes)] [Remote-23bit-SendTimestamp(3 bytes)]\r\n    Reply to TimeSync.  Used to test the time sync code.\r\n\r\n    [UnreliableType.ClientPosition(1 byte)] [Client-23bit-SendTimestamp(3 bytes)] [x(2 bytes)] [y(2 bytes)]\r\n    Sent by client to request a position change.\r\n    We use client time in the message to improve the time sync dataset.\r\n    Finger position relative to center: ((x or y) - 32768) / 32768 = -1..1\r\n*/\r\n\r\n/*\r\n    [UnreliableType.ServerPosition(1 byte)] [Server-23bit-PhysicsTimestamp(3 bytes)]\r\n    [Player Count(1 byte)] Repeated (LSB-first): {\r\n        [PlayerId(8 bits)]\r\n        [x(16 bits)] [y(16 bits)]\r\n        [vx(16 bits)] [vy(16 bits)]\r\n        [accel angle(16 bits)]\r\n        [last_shot_x(16 bits)] [last_shot_y(16 bits)]\r\n        [last_shot_vx(16 bits)] [last_shot_vy(16 bits)]\r\n    } (19 bytes per client)\r\n    Sent by server to update client position.\r\n\r\n    Size of the ship implies number of guns firing bullets.\r\n    Size=0 indicates dead player.\r\n    Maybe: As gun count increases, the guns don't change positions, only new guns are added.\r\n\r\n    Player (x, y) is in 1/2 pixel units.\r\n\r\n    Player velocity (vx, vy) is in 1/2 pixels per 100 milliseconds, 2s complement,\r\n    so ranging from -16 to 15.\r\n\r\n    Acceleration is -1, 0 or 1 in x,y.\r\n\r\n    Players all fire bullets when the server's timestamp is a multiple of 500.\r\n\r\n    Player fire direction is the same as their velocity.\r\n*/\r\n\r\nexport enum UnreliableType {\r\n    TimeSync = 0,\r\n    TimeSyncPong = 1,\r\n    ClientPosition = 2,\r\n    ServerPosition = 3,\r\n}\r\n\r\n/*\r\n    Reliable packet formats:\r\n\r\n    All packets can be appended to eachother.\r\n\r\n    [ReliableType.SetId(1 byte)] [PlayerId(1 byte)]\r\n    Server is assigning the client's info.\r\n\r\n\r\n    [ReliableType.ClientLogin(1 byte)]\r\n    [Name Length(1 byte)] [Name(NL bytes)]\r\n    [Password Length(1 byte)] [Password(PL bytes)]\r\n    Client is accessing a name.\r\n\r\n\r\n    [ReliableType.ServerLoginGood(1 byte)]\r\n    Player login accepted.\r\n\r\n    [ReliableType.ServerLoginBad(1 byte)] [Reason Length(2 bytes)] [Reason String(X bytes)]\r\n    Player login rejected and reason provided.\r\n\r\n\r\n    [ReliableType.SetPlayer(1 byte)] [PlayerId(1 byte)]\r\n    [Score(2 bytes)] [Wins(4 bytes)] [Losses(4 bytes)]\r\n    [Skin(1 byte)] [Team(1 byte)] [Name Length(1 byte)] [Name(X bytes)]\r\n    Add/update a player on the player list.\r\n\r\n    [ReliableType.RemovePlayer(1 byte)] [PlayerId(1 byte)]\r\n    Remove the player.\r\n\r\n    [ReliableType.PlayerKill(1 byte)]\r\n    [Killer PlayerId(1 byte)] [Killee PlayerId(1 byte)]\r\n    [Killer New Score(2 bytes)] [Killee New Score(2 bytes)]\r\n    Report a player kill.\r\n\r\n\r\n    [ReliableType.ChatRequest(1 byte)] [Message Length(2 bytes)] [Message(X bytes)]\r\n    Message to send to server.\r\n\r\n    [ReliableType.Chat(1 byte)] [PlayerId(1 byte)] [Message Length(2 bytes)] [Message(X bytes)]\r\n    Message received from server.\r\n    Does not support historical messages from before they logged in.\r\n*/\r\n\r\nexport enum ReliableType {\r\n    SetId = 0,\r\n\r\n    ClientLogin = 10,\r\n    ServerLoginGood = 11,\r\n    ServerLoginBad = 12,\r\n\r\n    SetPlayer = 20,\r\n    RemovePlayer = 21,\r\n    PlayerKill = 22,\r\n\r\n    ChatRequest = 30,\r\n    Chat = 31,\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Tools\r\n\r\nexport function Store24(ptr: usize, offset: usize, ts24: u32): void {\r\n    store<u16>(ptr + offset, u16(ts24));\r\n    store<u8>(ptr + offset + 2, u8(ts24 >> 16));\r\n}\r\n\r\nexport function Load24(ptr: usize, offset: usize): u32 {\r\n    let ts24: u32 = load<u16>(ptr + offset);\r\n    ts24 |= u32(load<u8>(ptr + offset + 2)) << 16;\r\n    return ts24;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Time Units\r\n\r\n// LSB = 1/4 of a millisecond\r\n\r\nexport class TimeConverter {\r\n    // For netcode we use timestamps relative to the connection open time, because\r\n    // we waste fewer mantissa bits on useless huge values.\r\n    netcode_start_msec: f64 = 0;\r\n\r\n    constructor(netcode_start_msec: f64) {\r\n        this.netcode_start_msec = netcode_start_msec;\r\n    }\r\n\r\n    // Convert to internal integer time units from floating point performance.now() units\r\n    MsecToTime(t_msec: f64): u64 {\r\n        return u64((t_msec - this.netcode_start_msec) * 4.0) & ~(u64(1) << 63);\r\n    }\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Message Combiner\r\n\r\n// Accumulates reliable messages to send together on a timer\r\nexport class MessageCombiner {\r\n    messages: Array<Uint8Array> = new Array<Uint8Array>(0);\r\n\r\n    constructor() {\r\n    }\r\n\r\n    Push(message: Uint8Array | null): void {\r\n        if (message != null) {\r\n            this.messages.push(message);\r\n        }\r\n    }\r\n\r\n    PopNextDatagram(): Uint8Array | null {\r\n        let datagram_bytes: i32 = 0;\r\n        let combined: Array<Uint8Array> | null = null;\r\n\r\n        while (this.messages.length > 0) {\r\n            const first_len: i32 = this.messages[0].length;\r\n\r\n            if (datagram_bytes + first_len > kMaxPacketBytes) {\r\n                break;\r\n            }\r\n\r\n            datagram_bytes += first_len;\r\n            if (combined == null) {\r\n                combined = new Array<Uint8Array>(0);\r\n            }\r\n            combined.push(this.messages.shift());\r\n        }\r\n\r\n        if (combined == null) {\r\n            return null;\r\n        }\r\n\r\n        let message: Uint8Array = new Uint8Array(datagram_bytes);\r\n        let offset: i32 = 0;\r\n        for (let i: i32 = 0; i < combined.length; ++i) {\r\n            message.set(combined[i], offset);\r\n            offset += combined[i].length;\r\n        }\r\n\r\n        return message;\r\n    }\r\n};\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Time Synchronization\r\n\r\n// x, y are 24-bit counters\r\n// Returns true if x <= y\r\nfunction TS24_IsLessOrEqual(x: u32, y: u32): bool {\r\n    let temp: u32 = (x - y) & 0xffffff;\r\n    return temp < 0x800000;\r\n}\r\n\r\n/*\r\n    The bits in the smaller counter were all truncated from the correct\r\n    value, so what needs to be determined now is all the higher bits.\r\n    Examples:\r\n    Recent    Smaller  =>  Expanded\r\n    ------    -------      --------\r\n    0x100     0xff         0x0ff\r\n    0x16f     0x7f         0x17f\r\n    0x17f     0x6f         0x16f\r\n    0x1ff     0xa0         0x1a0\r\n    0x1ff     0x01         0x201\r\n    The choice to make is between -1, 0, +1 for the next bit position.\r\n    Since we have no information about the high bits, it should be\r\n    sufficient to compare the recent low bits with the smaller value\r\n    in order to decide which one is correct:\r\n    00 - ff = -ff -> -1\r\n    6f - 7f = -10 -> 0\r\n    7f - 6f = +10 -> 0\r\n    ff - a0 = +5f -> 0\r\n    ff - 01 = +fe -> +1\r\n*/\r\nfunction TS23ExpandFromTruncatedWithBias(recent: u64, trunc23: u32): u64 {\r\n    const bias: u32 = 0x200000;\r\n    const msb: u32 = 0x400000;\r\n\r\n    let result: u64 = trunc23 | (recent & ~u64(0x7fffff));\r\n    const recent_low: u32 = u32(recent) & 0x7fffff;\r\n\r\n    // If recent - trunc would be negative:\r\n    if (recent_low < trunc23)\r\n    {\r\n        // If it is large enough to roll back a MSB:\r\n        const abs_diff: u32 = trunc23 - recent_low;\r\n        if (abs_diff >= (msb - bias)) {\r\n            result -= msb << 1;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // If it is large enough to roll ahead a MSB:\r\n        const abs_diff: u32 = recent_low - trunc23;\r\n        if (abs_diff > (msb + bias)) {\r\n            result += msb << 1;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n// Similar to above but for 24 bits instead of 23.\r\nfunction TS24ExpandFromTruncatedWithBias(recent: u64, trunc24: u32): u64 {\r\n    const bias: u32 = 0x400000;\r\n    const msb: u32 = 0x800000;\r\n\r\n    let result: u64 = trunc24 | (recent & ~u64(0xffffff));\r\n    const recent_low: u32 = u32(recent) & 0xffffff;\r\n\r\n    // If recent - trunc would be negative:\r\n    if (recent_low < trunc24)\r\n    {\r\n        // If it is large enough to roll back a MSB:\r\n        const abs_diff: u32 = trunc24 - recent_low;\r\n        if (abs_diff >= (msb - bias)) {\r\n            result -= msb << 1;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        // If it is large enough to roll ahead a MSB:\r\n        const abs_diff: u32 = recent_low - trunc24;\r\n        if (abs_diff > (msb + bias)) {\r\n            result += msb << 1;\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nclass SampleTrip {\r\n    local_ts: u64;\r\n    remote_ts: u64;\r\n\r\n    constructor(local_ts: u64 = 0, remote_ts: u64 = 0) {\r\n        this.local_ts = local_ts;\r\n        this.remote_ts = remote_ts;\r\n    }\r\n    Set(local_ts: u64 = 0, remote_ts: u64 = 0): void {\r\n        this.local_ts = local_ts;\r\n        this.remote_ts = remote_ts;\r\n    }\r\n    IsTimeoutExpired(now: u64, timeout: u64): bool {\r\n        return u64(now - this.local_ts) > timeout;\r\n    }\r\n    toString(): string {\r\n        return \"{ local_ts=\" + this.local_ts.toString() + \", remote_ts=\" + this.remote_ts.toString() + \" }\";\r\n    }\r\n}\r\n\r\n// Bound the slope estimates to a reasonable range\r\nconst kMaxSlope: f32 = 1.003; // +3000 ppm\r\nconst kMinSlope: f32 = 0.997; // -3000 ppm\r\n\r\nexport class TimeSync {\r\n    // Used to hallucinate the upper bits of peer timestamps\r\n    last_remote_ts: u64 = 0;\r\n\r\n    // incoming_min_trip: Remote send time, and local receive time (with lowest latency)\r\n    incoming_min_trip: SampleTrip = new SampleTrip(0, 0);\r\n    has_first_measurement: bool = false;\r\n\r\n    // Provided by peer\r\n    // outgoing_min_trip: Local send time, and remote receive time (with lowest latency)\r\n    outgoing_min_trip: SampleTrip = new SampleTrip(0, 0);\r\n    remote_slope: f32 = 1.0;\r\n    has_remote_sync: bool = false;\r\n\r\n    // X/Y intercept for remote timestamp drift correction to local tick rate\r\n    remote_dy: i64 = 0;\r\n    local_dx: i64 = 0;\r\n    has_transform: bool = false;\r\n\r\n    // incoming_min_trip recorded at regular intervals\r\n    drift_samples: Array<SampleTrip> = new Array<SampleTrip>(0);\r\n\r\n    // Calculated from samples\r\n    local_slope: f32 = 1.0;\r\n\r\n    // Average of local slope and inverse remote slope\r\n    consensus_slope: f32 = 1.0;\r\n    inv_consensus_slope: f32 = 1.0;\r\n    slope_uncertainty: f32 = 0.002;\r\n    has_slope_estimate: bool = false;\r\n\r\n    constructor() {\r\n    }\r\n\r\n    DumpState(): void {\r\n        consoleLog(\"local_slope = \" + this.local_slope.toString());\r\n        consoleLog(\"remote_slope = \" + this.remote_slope.toString());\r\n        consoleLog(\"consensus_slope = \" + this.consensus_slope.toString());\r\n        consoleLog(\"slope_uncertainty = \" + this.slope_uncertainty.toString());\r\n        consoleLog(\"drift_samples: \" + this.drift_samples.toString());\r\n        consoleLog(\"incoming_min_trip = \" + this.incoming_min_trip.toString());\r\n        consoleLog(\"outgoing_min_trip = \" + this.outgoing_min_trip.toString());\r\n        consoleLog(\"remote_dy = \" + this.remote_dy.toString());\r\n        consoleLog(\"local_dx = \" + this.local_dx.toString());\r\n    }\r\n\r\n    // Update how we transform from remote to local timestamps,\r\n    // based on the incoming_min_trip and outgoing_min_trip.\r\n    UpdateTransform(): void {\r\n        if (!this.has_remote_sync) {\r\n            // Cannot estimate OWD yet\r\n            this.local_dx = i64(this.incoming_min_trip.local_ts - this.incoming_min_trip.remote_ts);\r\n            this.remote_dy = 0;\r\n            return;\r\n        }\r\n\r\n        // Find which point is on left/right\r\n        let left: SampleTrip = this.incoming_min_trip;\r\n        let right: SampleTrip = this.outgoing_min_trip;\r\n        if (i64(right.local_ts - left.local_ts) < 0) {\r\n            left = this.outgoing_min_trip;\r\n            right = this.incoming_min_trip;\r\n        }\r\n\r\n        // Correct out the trip time\r\n        const dy = i32(right.remote_ts - left.remote_ts);\r\n        const dx = i32(right.local_ts - left.local_ts);\r\n        const owd_offset = (dx - i32(f32(dy) * this.inv_consensus_slope)) / 2;\r\n\r\n        // Use right point as reference point,\r\n        // because offsets to this point will be less affected by drift.\r\n        // Local = (Remote - remote_dy) / slope + local_dx\r\n        // Remote = (Local - local_dx) * slope + remote_dy\r\n        this.local_dx = right.local_ts - owd_offset;\r\n        this.remote_dy = right.remote_ts;\r\n    }\r\n\r\n    OnTimeSample(local_ts: u64, trunc_remote_ts24: u32): bool {\r\n        //consoleLog(\"OnTimeSample()\");\r\n\r\n        // Expand incoming timestamps to 64-bit, though the high bits will be hallucinated.\r\n        let remote_ts: u64 = TS24ExpandFromTruncatedWithBias(this.last_remote_ts, trunc_remote_ts24);\r\n\r\n        // Do not roll this backwards\r\n        if (i64(remote_ts - this.last_remote_ts) > 0) {\r\n            this.last_remote_ts = remote_ts;\r\n        }\r\n\r\n        // Handle first few data-points\r\n        if (!this.has_first_measurement || !this.has_remote_sync) {\r\n            this.has_first_measurement = true;\r\n        } else {\r\n            // Estimate the OWD for incoming_min_trip and new candidate point.\r\n            // Note: This takes drift slope into account\r\n            const old_send_ts = this.TransformRemoteToLocal(this.incoming_min_trip.remote_ts);\r\n            const old_owd = i64(this.incoming_min_trip.local_ts - old_send_ts);\r\n            const new_send_ts = this.TransformRemoteToLocal(remote_ts);\r\n            const new_owd = i64(local_ts - new_send_ts);\r\n\r\n            //consoleLog(\"old owd=\" + old_owd.toString() + \" new owd=\" + new_owd.toString() + \" slope=\" + this.consensus_slope.toString());\r\n\r\n            // If the new trip time looks worse:\r\n            // Note: old_owd > 0 check added because sometimes the timestamps are crazy\r\n            if (old_owd > 0 && new_owd > old_owd) {\r\n                const age = i32(local_ts - this.incoming_min_trip.local_ts);\r\n    \r\n                let window = 4 * 3_000;\r\n                if (this.has_slope_estimate) {\r\n                    // Use a longer window if we can estimate slope\r\n                    window = 4 * 10_000;\r\n                }\r\n\r\n                // If the previous min-trip is not aging:\r\n                if (age < window) {\r\n                    return false;\r\n                }\r\n\r\n                const uncertainty = i32(f32(age) * this.slope_uncertainty + 0.5);\r\n\r\n                // If uncertainty is low:\r\n                if (new_owd > old_owd + uncertainty) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Base transform on the new point\r\n        this.incoming_min_trip.Set(local_ts, remote_ts);\r\n        this.UpdateTransform();\r\n\r\n        return true;\r\n    }\r\n\r\n    // Peer provides, for the best probe we have sent so far:\r\n    // min_trip_send_ts24_trunc: Our 24-bit timestamp from the probe, from our clock.\r\n    // min_trip_recv_ts24_trunc: When they received the probe, from their clock.\r\n    OnPeerSync(local_ts: u64, trunc_remote_ts24: u32, min_trip_send_ts24_trunc: u32, min_trip_recv_ts24_trunc: u32, slope: f32): void {\r\n        this.outgoing_min_trip.local_ts = TS24ExpandFromTruncatedWithBias(local_ts, min_trip_send_ts24_trunc);\r\n        this.outgoing_min_trip.remote_ts = TS24ExpandFromTruncatedWithBias(this.last_remote_ts, min_trip_recv_ts24_trunc);\r\n\r\n        if (!isFinite(slope)) {\r\n            slope = 1.0;\r\n        } else if (slope > kMaxSlope) {\r\n            slope = kMaxSlope;\r\n        } else if (slope < kMinSlope) {\r\n            slope = kMinSlope;\r\n        }\r\n\r\n        this.remote_slope = slope;\r\n        this.has_remote_sync = true;\r\n\r\n        // Add sample after updating remote information\r\n        if (!this.OnTimeSample(local_ts, trunc_remote_ts24)) {\r\n            // Update transform even if the new sample isn't as good\r\n            this.UpdateTransform();\r\n        }\r\n\r\n        this.UpdateDrift();\r\n    }\r\n\r\n    UpdateDrift(): void {\r\n        const samples = this.drift_samples;\r\n\r\n        // If we have seen this sample:\r\n        if (samples.length > 0 && samples[samples.length - 1].local_ts == this.incoming_min_trip.local_ts) {\r\n            //consoleLog(\"Ignoring drift sample repeat\");\r\n            return;\r\n        }\r\n\r\n        let sample: SampleTrip = new SampleTrip(this.incoming_min_trip.local_ts, this.incoming_min_trip.remote_ts);\r\n        samples.push(sample);\r\n\r\n        if (samples.length >= 2)\r\n        {\r\n            const sample_i = samples[0];\r\n            const sample_j = samples[samples.length - 1];\r\n            const m = i32(sample_j.remote_ts - sample_i.remote_ts) / f64(i32(sample_j.local_ts - sample_i.local_ts));\r\n            //consoleLog(\"wide slope = \" + m.toString());\r\n        }\r\n\r\n        if (samples.length < 50) {\r\n            //consoleLog(\"Waiting for 50 samples: \" + samples.length.toString());\r\n            return;\r\n        }\r\n\r\n        if (samples.length > 100) {\r\n            samples.shift();\r\n        }\r\n\r\n        //const t0 = getMilliseconds();\r\n\r\n        let slopes: Array<f32> = new Array<f32>(0);\r\n\r\n        const sample_count = samples.length;\r\n        const split_i = sample_count / 2;\r\n        for (let i: i32 = 0; i < split_i; ++i) {\r\n            const sample_i = samples[i];\r\n\r\n            for (let j: i32 = i + sample_count / 2; j < sample_count; ++j) {\r\n                const sample_j = samples[j];\r\n\r\n                const m = i32(sample_j.remote_ts - sample_i.remote_ts) / f64(i32(sample_j.local_ts - sample_i.local_ts));\r\n                if (m >= kMinSlope && m <= kMaxSlope) {\r\n                    slopes.push(f32(m));\r\n                }\r\n            }\r\n        }\r\n\r\n        if (slopes.length < 50) {\r\n            //consoleLog(\"Too few slopes\");\r\n            return;\r\n        }\r\n\r\n        slopes.sort();\r\n        this.local_slope = slopes[slopes.length / 2];\r\n\r\n        this.slope_uncertainty = abs(this.local_slope - 1.0) * 2;\r\n        if (this.slope_uncertainty > kMaxSlope) {\r\n            this.slope_uncertainty = kMaxSlope;\r\n        }\r\n        if (this.slope_uncertainty < 0.00005) {\r\n            this.slope_uncertainty = 0.00005; // within 50 ppm\r\n        }\r\n\r\n        if (this.remote_slope == 1.0) {\r\n            this.consensus_slope = this.local_slope;\r\n        } else {\r\n            this.consensus_slope = (this.local_slope + this.remote_slope) * 0.5;\r\n        }\r\n        this.inv_consensus_slope = 1.0 / this.consensus_slope;\r\n\r\n        this.has_slope_estimate = true;\r\n\r\n        //const t1 = getMilliseconds();\r\n        //consoleLog(\"Updated slope estimate in \" + (t1 - t0).toString() + \" msec\");\r\n    }\r\n\r\n    // Takes in a 23-bit timestamp in peer's clock domain,\r\n    // and produces a full 64-bit timestamp in local clock domain.\r\n    PeerToLocalTime_FromTS23(peer_ts23: u32): u64 {\r\n        // Expand incoming timestamps to 64-bit, though the high bits will be hallucinated.\r\n        const remote_ts: u64 = TS23ExpandFromTruncatedWithBias(this.last_remote_ts, peer_ts23);\r\n\r\n        return this.TransformRemoteToLocal(remote_ts);\r\n    }\r\n\r\n    // Produces a 23-bit timestamp in peer's clock domain.\r\n    LocalToPeerTime_ToTS23(local_ts: u64): u32 {\r\n        // Convert local to remote, though the high bits will be hallucinated.\r\n        const remote_ts: u64 = this.TransformLocalToRemote(local_ts);\r\n\r\n        return u32(remote_ts) & 0x7fffff;\r\n    }\r\n\r\n    // Takes in a full 64-bit timestamp in local clock domain,\r\n    // and produces a truncated 23-bit timestamp in local clock domain.\r\n    TruncateLocalTime_ToTS23(local_ts: u64): u32 {\r\n        return u32(local_ts) & 0x7fffff;\r\n    }\r\n\r\n    // Takes in a 23-bit timestamp in local clock domain,\r\n    // and produces a full 64-bit timestamp in local clock domain.\r\n    // local_ts: A recent local 64-bit timestamp.\r\n    ExpandLocalTime_FromTS23(local_ts: u64, local_ts23: u32): u64 {\r\n        return TS23ExpandFromTruncatedWithBias(local_ts, local_ts23 & 0x7fffff);\r\n    }\r\n\r\n    MakeTimeSync(send_ts: u64): Uint8Array {\r\n        let buffer: Uint8Array = new Uint8Array(14);\r\n        let ptr: usize = buffer.dataStart;\r\n\r\n        store<u8>(ptr, Netcode.UnreliableType.TimeSync, 0);\r\n        // Send timestamp\r\n        Netcode.Store24(ptr, 1, u32(send_ts & 0xff_ff_ff));\r\n        // min_trip_send_ts24_trunc:\r\n        Netcode.Store24(ptr, 4, u32(this.incoming_min_trip.remote_ts) & 0xff_ff_ff);\r\n        // min_trip_recv_ts24_trunc:\r\n        Netcode.Store24(ptr, 7, u32(this.incoming_min_trip.local_ts) & 0xff_ff_ff);\r\n        // Our slope estimate\r\n        store<f32>(ptr, this.local_slope, 10);\r\n\r\n        return buffer;\r\n    }\r\n\r\n    TransformRemoteToLocal(remote_ts: u64): u64 {\r\n        return this.local_dx + i64(f64(i64(remote_ts - this.remote_dy)) * this.inv_consensus_slope);\r\n    }\r\n\r\n    // Note that only the low 23-bits are valid in the view of the remote computer because\r\n    // we only have a view of 24 bits of the remote timestamps, and we lose one bit from the\r\n    // division by 2 above.\r\n    TransformLocalToRemote(local_ts: u64): u64 {\r\n        return this.remote_dy + i64(f64(i64(local_ts - this.local_dx)) * this.consensus_slope);\r\n    }\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Common Serializers\r\n\r\n// peer_ping_ts24: Taken from TimeSync received message.\r\n// peer_pong_ts23: Local receive time converted to 23-bit remote timestamp.\r\nexport function MakeTimeSyncPong(peer_ping_ts24: u32, peer_pong_ts23: u32): Uint8Array {\r\n    let buffer: Uint8Array = new Uint8Array(7);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.UnreliableType.TimeSyncPong, 0);\r\n    Store24(ptr, 1, peer_ping_ts24);\r\n    Store24(ptr, 4, peer_pong_ts23);\r\n\r\n    return buffer;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Client Serializer\r\n\r\nexport function MakeChatRequest(m: string): Uint8Array | null {\r\n    let m_len: i32 = String.UTF8.byteLength(m, false);\r\n\r\n    if (m_len <= 0 || m_len >= 512) {\r\n        return null;\r\n    }\r\n\r\n    let buffer: Uint8Array = new Uint8Array(3 + m_len);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.ReliableType.ChatRequest, 0);\r\n    store<u16>(ptr, u16(m_len), 1);\r\n\r\n    // If dataStart stops working we can use this instead:\r\n    // changetype<usize>(buffer) + buffer.byteOffset\r\n\r\n    String.UTF8.encodeUnsafe(\r\n        changetype<usize>(m),\r\n        m.length,\r\n        ptr + 3,\r\n        false);\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function MakeClientLogin(name: string, password: string): Uint8Array | null {\r\n    let name_len: i32 = String.UTF8.byteLength(name, false);\r\n    let password_len: i32 = String.UTF8.byteLength(password, false);\r\n\r\n    if (name_len <= 0 || name_len >= 256) {\r\n        return null;\r\n    }\r\n    if (password_len <= 0 || password_len >= 256) {\r\n        return null;\r\n    }\r\n\r\n    let buffer: Uint8Array = new Uint8Array(3 + name_len + password_len);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.ReliableType.ClientLogin, 0);\r\n    store<u8>(ptr, u8(name_len), 1);\r\n\r\n    // If dataStart stops working we can use this instead:\r\n    // changetype<usize>(buffer) + buffer.byteOffset\r\n\r\n    String.UTF8.encodeUnsafe(\r\n        changetype<usize>(name),\r\n        name.length,\r\n        ptr + 2,\r\n        false);\r\n\r\n    store<u8>(ptr + name_len, u8(password_len), 2);\r\n\r\n    String.UTF8.encodeUnsafe(\r\n        changetype<usize>(password),\r\n        password.length,\r\n        ptr + 3 + name_len,\r\n        false);\r\n\r\n    return buffer;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Server Serializer\r\n\r\nexport function MakeSetId(id: u8): Uint8Array {\r\n    let buffer: Uint8Array = new Uint8Array(2);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.ReliableType.SetId, 0);\r\n    store<u8>(ptr, id, 1);\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function MakeServerLoginGood(): Uint8Array {\r\n    let buffer: Uint8Array = new Uint8Array(1);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.ReliableType.ServerLoginGood, 0);\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function MakeServerLoginBad(m: string): Uint8Array | null {\r\n    let m_len: i32 = String.UTF8.byteLength(m, false);\r\n\r\n    if (m_len <= 0 || m_len >= 512) {\r\n        return null;\r\n    }\r\n\r\n    let buffer: Uint8Array = new Uint8Array(3 + m_len);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.ReliableType.ServerLoginBad, 0);\r\n    store<u16>(ptr, u16(m_len), 1);\r\n\r\n    String.UTF8.encodeUnsafe(\r\n        changetype<usize>(m),\r\n        m.length,\r\n        ptr + 3,\r\n        false);\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function MakeSetPlayer(\r\n    id: u8,\r\n    score: u16,\r\n    wins: u32,\r\n    losses: u32,\r\n    skin: u8,\r\n    team: u8,\r\n    name: string): Uint8Array | null\r\n{\r\n    let name_len: i32 = String.UTF8.byteLength(name, false);\r\n\r\n    if (name_len <= 0 || name_len >= 256) {\r\n        return null;\r\n    }\r\n\r\n    let buffer: Uint8Array = new Uint8Array(15 + name_len);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.ReliableType.SetPlayer, 0);\r\n    store<u8>(ptr, id, 1);\r\n    store<u16>(ptr, score, 2);\r\n    store<u32>(ptr, wins, 4);\r\n    store<u32>(ptr, losses, 8);\r\n    store<u8>(ptr, skin, 12);\r\n    store<u8>(ptr, team, 13);\r\n    store<u8>(ptr, u8(name_len), 14);\r\n\r\n    String.UTF8.encodeUnsafe(\r\n        changetype<usize>(name),\r\n        name.length,\r\n        ptr + 15,\r\n        false);\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function MakeRemovePlayer(id: u8): Uint8Array {\r\n    let buffer: Uint8Array = new Uint8Array(2);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.ReliableType.RemovePlayer, 0);\r\n    store<u8>(ptr, id, 1);\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function MakePlayerKill(killer_id: u8, killee_id: u8, killer_score: u16, killee_score: u16): Uint8Array {\r\n    let buffer: Uint8Array = new Uint8Array(7);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.ReliableType.PlayerKill, 0);\r\n    store<u8>(ptr, killer_id, 1);\r\n    store<u8>(ptr, killee_id, 2);\r\n    store<u16>(ptr, killer_score, 3);\r\n    store<u16>(ptr, killee_score, 5);\r\n\r\n    return buffer;\r\n}\r\n\r\nexport function MakeChat(id: u8, m: string): Uint8Array | null {\r\n    let m_len: i32 = String.UTF8.byteLength(m, false);\r\n\r\n    if (m_len <= 0 || m_len >= 512) {\r\n        return null;\r\n    }\r\n\r\n    let buffer: Uint8Array = new Uint8Array(4 + m_len);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.ReliableType.Chat, 0);\r\n    store<u8>(ptr, id, 1);\r\n    store<u16>(ptr, u16(m_len), 2);\r\n\r\n    // If dataStart stops working we can use this instead:\r\n    // changetype<usize>(buffer) + buffer.byteOffset\r\n\r\n    String.UTF8.encodeUnsafe(\r\n        changetype<usize>(m),\r\n        m.length,\r\n        ptr + 4,\r\n        false);\r\n\r\n    return buffer;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Positioning\r\n\r\n// Breaks down after (x,y) > 32767 or < 0.\r\nexport function ConvertXto16(x: f32): u16 {\r\n    let temp: i32 = i32(x * 2.0 + 0.5);\r\n    if (temp > 65535) {\r\n        temp = 65535;\r\n    } else if (temp < 0) {\r\n        temp = 0;\r\n    }\r\n    return u16(temp);\r\n}\r\n\r\nexport function Convert16toX(x: u16): f32 {\r\n    return f32(x) * 0.5;\r\n}\r\n\r\n// Breaks down after |(vx,vy)| > 1.0\r\nexport function ConvertVXto16(vx: f32): i16 {\r\n    let temp: i32 = i32(vx * 32767.0);\r\n    if (temp > 32767) {\r\n        temp = 32767;\r\n    } else if (temp < -32767) {\r\n        temp = -32767;\r\n    }\r\n    return i16(temp);\r\n}\r\n\r\nconst inv_vx_factor: f32 = 1.0 / 32767.0;\r\n\r\nexport function Convert16toVX(vx: i16): f32 {\r\n    return vx * inv_vx_factor;\r\n}\r\n\r\nconst aa_factor: f32 = 65534.0 / (Mathf.PI * 2.0);\r\n\r\nexport function ConvertAccelto16(ax: f32, ay: f32): u16 {\r\n    if (ax == 0.0 && ay == 0.0) {\r\n        return 0;\r\n    }\r\n\r\n    let angle: f64 = Math.atan2(ay, ax);\r\n    if (angle < 0.0) {\r\n        angle += 2.0 * Math.PI;\r\n    }\r\n\r\n    let aa: u16 = u16(angle * aa_factor + 0.5);\r\n    if (aa > 65534) {\r\n        aa = 65534;\r\n    }\r\n    ++aa;\r\n    return aa;\r\n}\r\n\r\nexport class AccelXY {\r\n    ax: f32\r\n    ay: f32\r\n}\r\n\r\nexport const inv_aa_factor: f32 = (Mathf.PI * 2.0) / 65534.0;\r\n\r\n\r\n} // namespace Netcode\r\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  var kd = xd + shift;\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  var xd = <f64>x;\n  var ix = reinterpret<u32>(x);\n  var ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  var z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  var kd = <f64>(z + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = z - (kd - shift);\n  var s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFDEFEC65B963019), // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFDB0B6832D4FCA4), // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD7418B0A1FB77B), // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFD39DE91A6DCF7B), // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFD01D9BF3F2B631), // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC97C1D1B3B7AF0), // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFC2F9E393AF3C9F), // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB960CBBF788D5C), // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFAA6F9DB6475FCE), // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0x0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FB338CA9F24F53D), // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FC476A9543891BA), // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FCE840B4AC4E4D2), // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FD40645F0C6651C), // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD88E9C2C1B9FF8), // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FDCE0A44EB17BCC)  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  var top  = tmp & 0xFF800000;\n  var iz   = ux - top;\n  var k    = <i32>tmp >> 23;\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y  = A1 * r + A2;\n  var p  = A3 * r + y0;\n  var r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<f64>([\n  reinterpret<f64>(0x3FF661EC79F8F3BE), reinterpret<f64>(0xBFD57BF7808CAADE), // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  reinterpret<f64>(0x3FF571ED4AAF883D), reinterpret<f64>(0xBFD2BEF0A7C06DDB), // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  reinterpret<f64>(0x3FF49539F0F010B0), reinterpret<f64>(0xBFD01EAE7F513A67), // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  reinterpret<f64>(0x3FF3C995B0B80385), reinterpret<f64>(0xBFCB31D8A68224E9), // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  reinterpret<f64>(0x3FF30D190C8864A5), reinterpret<f64>(0xBFC6574F0AC07758), // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  reinterpret<f64>(0x3FF25E227B0B8EA0), reinterpret<f64>(0xBFC1AA2BC79C8100), // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  reinterpret<f64>(0x3FF1BB4A4A1A343F), reinterpret<f64>(0xBFBA4E76CE8C0E5E), // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  reinterpret<f64>(0x3FF12358F08AE5BA), reinterpret<f64>(0xBFB1973C5A611CCC), // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  reinterpret<f64>(0x3FF0953F419900A7), reinterpret<f64>(0xBFA252F438E10C1E), // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  reinterpret<f64>(0x3FF0000000000000), 0,                                    // 0x1p+0,                0,\n  reinterpret<f64>(0x3FEE608CFD9A47AC), reinterpret<f64>(0x3FAAA5AA5DF25984), // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  reinterpret<f64>(0x3FECA4B31F026AA0), reinterpret<f64>(0x3FBC5E53AA362EB4), // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  reinterpret<f64>(0x3FEB2036576AFCE6), reinterpret<f64>(0x3FC526E57720DB08), // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  reinterpret<f64>(0x3FE9C2D163A1AA2D), reinterpret<f64>(0x3FCBC2860D224770), // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  reinterpret<f64>(0x3FE886E6037841ED), reinterpret<f64>(0x3FD1058BC8A07EE1), // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  reinterpret<f64>(0x3FE767DCF5534862), reinterpret<f64>(0x3FD4043057B6EE09)  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  var ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ux - 0x3F330000;\n  var i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  var k   = <i32>tmp >> 23;\n  var iz  = ux - (tmp & 0x1FF << 23);\n\n  var invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  var z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  var r = z * invc - 1;\n  var y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  var r2 = r * r;\n  var y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  var e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ux - 0x3F330000;\n  var i    = <usize>((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  var top  = tmp & 0xFF800000;\n  var uz   = ux - top;\n  var k    = <i32>(<i32>top >> 23);\n\n  var invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  var logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  var z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  var r  = z * invc - 1;\n  var y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  var y = A0 * r + A1;\n  var p = A2 * r + A3;\n  var q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  var kd = <f64>(xd + shift);\n  var ki = reinterpret<u64>(kd);\n  var r  = xd - (kd - shift);\n  var t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  var signBias: u32 = 0;\n  var ix = reinterpret<u32>(x);\n  var iy = reinterpret<u32>(y);\n  var ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return iy >> 31 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (ix >> 31) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  var logx = log2f_inline(ix);\n  var ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  var scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  var y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7FF);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      return select<f64>(0, Infinity, ux >> 63);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  var z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // var kd = z + shift;\n  // var ki = reinterpret<u64>(kd) >> 16;\n  // var kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  var kd = z + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  var r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  var scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  var y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  var ux = reinterpret<u64>(x);\n  var abstop = <u32>(ux >> 52 & 0x7ff);\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (!(ux >> 63)) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  var kd = x + shift;\n  var ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  var r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  var idx = <usize>((ki & N_MASK) << 1);\n  var top = ki << (52 - EXP_TABLE_BITS);\n\n  var tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  var sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  var tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  var scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<f64>([\n  //            invc                  ,                logc\n  reinterpret<f64>(0x3FF724286BB1ACF8), reinterpret<f64>(0xBFE1095FEECDB000),\n  reinterpret<f64>(0x3FF6E1F766D2CCA1), reinterpret<f64>(0xBFE08494BD76D000),\n  reinterpret<f64>(0x3FF6A13D0E30D48A), reinterpret<f64>(0xBFE00143AEE8F800),\n  reinterpret<f64>(0x3FF661EC32D06C85), reinterpret<f64>(0xBFDEFEC5360B4000),\n  reinterpret<f64>(0x3FF623FA951198F8), reinterpret<f64>(0xBFDDFDD91AB7E000),\n  reinterpret<f64>(0x3FF5E75BA4CF026C), reinterpret<f64>(0xBFDCFFAE0CC79000),\n  reinterpret<f64>(0x3FF5AC055A214FB8), reinterpret<f64>(0xBFDC043811FDA000),\n  reinterpret<f64>(0x3FF571ED0F166E1E), reinterpret<f64>(0xBFDB0B67323AE000),\n  reinterpret<f64>(0x3FF53909590BF835), reinterpret<f64>(0xBFDA152F5A2DB000),\n  reinterpret<f64>(0x3FF5014FED61ADDD), reinterpret<f64>(0xBFD9217F5AF86000),\n  reinterpret<f64>(0x3FF4CAB88E487BD0), reinterpret<f64>(0xBFD8304DB0719000),\n  reinterpret<f64>(0x3FF49539B4334FEE), reinterpret<f64>(0xBFD74189F9A9E000),\n  reinterpret<f64>(0x3FF460CBDFAFD569), reinterpret<f64>(0xBFD6552BB5199000),\n  reinterpret<f64>(0x3FF42D664EE4B953), reinterpret<f64>(0xBFD56B23A29B1000),\n  reinterpret<f64>(0x3FF3FB01111DD8A6), reinterpret<f64>(0xBFD483650F5FA000),\n  reinterpret<f64>(0x3FF3C995B70C5836), reinterpret<f64>(0xBFD39DE937F6A000),\n  reinterpret<f64>(0x3FF3991C4AB6FD4A), reinterpret<f64>(0xBFD2BAA1538D6000),\n  reinterpret<f64>(0x3FF3698E0CE099B5), reinterpret<f64>(0xBFD1D98340CA4000),\n  reinterpret<f64>(0x3FF33AE48213E7B2), reinterpret<f64>(0xBFD0FA853A40E000),\n  reinterpret<f64>(0x3FF30D191985BDB1), reinterpret<f64>(0xBFD01D9C32E73000),\n  reinterpret<f64>(0x3FF2E025CAB271D7), reinterpret<f64>(0xBFCE857DA2FA6000),\n  reinterpret<f64>(0x3FF2B404CF13CD82), reinterpret<f64>(0xBFCCD3C8633D8000),\n  reinterpret<f64>(0x3FF288B02C7CCB50), reinterpret<f64>(0xBFCB26034C14A000),\n  reinterpret<f64>(0x3FF25E2263944DE5), reinterpret<f64>(0xBFC97C1C2F4FE000),\n  reinterpret<f64>(0x3FF234563D8615B1), reinterpret<f64>(0xBFC7D6023F800000),\n  reinterpret<f64>(0x3FF20B46E33EAF38), reinterpret<f64>(0xBFC633A71A05E000),\n  reinterpret<f64>(0x3FF1E2EEFDCDA3DD), reinterpret<f64>(0xBFC494F5E9570000),\n  reinterpret<f64>(0x3FF1BB4A580B3930), reinterpret<f64>(0xBFC2F9E424E0A000),\n  reinterpret<f64>(0x3FF19453847F2200), reinterpret<f64>(0xBFC162595AFDC000),\n  reinterpret<f64>(0x3FF16E06C0D5D73C), reinterpret<f64>(0xBFBF9C9A75BD8000),\n  reinterpret<f64>(0x3FF1485F47B7E4C2), reinterpret<f64>(0xBFBC7B575BF9C000),\n  reinterpret<f64>(0x3FF12358AD0085D1), reinterpret<f64>(0xBFB960C60FF48000),\n  reinterpret<f64>(0x3FF0FEF00F532227), reinterpret<f64>(0xBFB64CE247B60000),\n  reinterpret<f64>(0x3FF0DB2077D03A8F), reinterpret<f64>(0xBFB33F78B2014000),\n  reinterpret<f64>(0x3FF0B7E6D65980D9), reinterpret<f64>(0xBFB0387D1A42C000),\n  reinterpret<f64>(0x3FF0953EFE7B408D), reinterpret<f64>(0xBFAA6F9208B50000),\n  reinterpret<f64>(0x3FF07325CAC53B83), reinterpret<f64>(0xBFA47A954F770000),\n  reinterpret<f64>(0x3FF05197E40D1B5C), reinterpret<f64>(0xBF9D23A8C50C0000),\n  reinterpret<f64>(0x3FF03091C1208EA2), reinterpret<f64>(0xBF916A2629780000),\n  reinterpret<f64>(0x3FF0101025B37E21), reinterpret<f64>(0xBF7720F8D8E80000),\n  reinterpret<f64>(0x3FEFC07EF9CAA76B), reinterpret<f64>(0x3F86FE53B1500000),\n  reinterpret<f64>(0x3FEF4465D3F6F184), reinterpret<f64>(0x3FA11CCCE10F8000),\n  reinterpret<f64>(0x3FEECC079F84107F), reinterpret<f64>(0x3FAC4DFC8C8B8000),\n  reinterpret<f64>(0x3FEE573A99975AE8), reinterpret<f64>(0x3FB3AA321E574000),\n  reinterpret<f64>(0x3FEDE5D6F0BD3DE6), reinterpret<f64>(0x3FB918A0D08B8000),\n  reinterpret<f64>(0x3FED77B681FF38B3), reinterpret<f64>(0x3FBE72E9DA044000),\n  reinterpret<f64>(0x3FED0CB5724DE943), reinterpret<f64>(0x3FC1DCD2507F6000),\n  reinterpret<f64>(0x3FECA4B2DC0E7563), reinterpret<f64>(0x3FC476AB03DEA000),\n  reinterpret<f64>(0x3FEC3F8EE8D6CB51), reinterpret<f64>(0x3FC7074377E22000),\n  reinterpret<f64>(0x3FEBDD2B4F020C4C), reinterpret<f64>(0x3FC98EDE8BA94000),\n  reinterpret<f64>(0x3FEB7D6C006015CA), reinterpret<f64>(0x3FCC0DB86AD2E000),\n  reinterpret<f64>(0x3FEB20366E2E338F), reinterpret<f64>(0x3FCE840AAFCEE000),\n  reinterpret<f64>(0x3FEAC57026295039), reinterpret<f64>(0x3FD0790AB4678000),\n  reinterpret<f64>(0x3FEA6D01BC2731DD), reinterpret<f64>(0x3FD1AC056801C000),\n  reinterpret<f64>(0x3FEA16D3BC3FF18B), reinterpret<f64>(0x3FD2DB11D4FEE000),\n  reinterpret<f64>(0x3FE9C2D14967FEAD), reinterpret<f64>(0x3FD406464EC58000),\n  reinterpret<f64>(0x3FE970E4F47C9902), reinterpret<f64>(0x3FD52DBE093AF000),\n  reinterpret<f64>(0x3FE920FB3982BCF2), reinterpret<f64>(0x3FD651902050D000),\n  reinterpret<f64>(0x3FE8D30187F759F1), reinterpret<f64>(0x3FD771D2CDEAF000),\n  reinterpret<f64>(0x3FE886E5EBB9F66D), reinterpret<f64>(0x3FD88E9C857D9000),\n  reinterpret<f64>(0x3FE83C97B658B994), reinterpret<f64>(0x3FD9A80155E16000),\n  reinterpret<f64>(0x3FE7F405FFC61022), reinterpret<f64>(0x3FDABE186ED3D000),\n  reinterpret<f64>(0x3FE7AD22181415CA), reinterpret<f64>(0x3FDBD0F2AEA0E000),\n  reinterpret<f64>(0x3FE767DCF99EFF8C), reinterpret<f64>(0x3FDCE0A43DBF4000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<f64>([\n  //              chi                 ,                 clo\n  reinterpret<f64>(0x3FE6200012B90A8E), reinterpret<f64>(0x3C8904AB0644B605),\n  reinterpret<f64>(0x3FE66000045734A6), reinterpret<f64>(0x3C61FF9BEA62F7A9),\n  reinterpret<f64>(0x3FE69FFFC325F2C5), reinterpret<f64>(0x3C827ECFCB3C90BA),\n  reinterpret<f64>(0x3FE6E00038B95A04), reinterpret<f64>(0x3C88FF8856739326),\n  reinterpret<f64>(0x3FE71FFFE09994E3), reinterpret<f64>(0x3C8AFD40275F82B1),\n  reinterpret<f64>(0x3FE7600015590E10), reinterpret<f64>(0xBC72FD75B4238341),\n  reinterpret<f64>(0x3FE7A00012655BD5), reinterpret<f64>(0x3C7808E67C242B76),\n  reinterpret<f64>(0x3FE7E0003259E9A6), reinterpret<f64>(0xBC6208E426F622B7),\n  reinterpret<f64>(0x3FE81FFFEDB4B2D2), reinterpret<f64>(0xBC8402461EA5C92F),\n  reinterpret<f64>(0x3FE860002DFAFCC3), reinterpret<f64>(0x3C6DF7F4A2F29A1F),\n  reinterpret<f64>(0x3FE89FFFF78C6B50), reinterpret<f64>(0xBC8E0453094995FD),\n  reinterpret<f64>(0x3FE8E00039671566), reinterpret<f64>(0xBC8A04F3BEC77B45),\n  reinterpret<f64>(0x3FE91FFFE2BF1745), reinterpret<f64>(0xBC77FA34400E203C),\n  reinterpret<f64>(0x3FE95FFFCC5C9FD1), reinterpret<f64>(0xBC76FF8005A0695D),\n  reinterpret<f64>(0x3FE9A0003BBA4767), reinterpret<f64>(0x3C70F8C4C4EC7E03),\n  reinterpret<f64>(0x3FE9DFFFE7B92DA5), reinterpret<f64>(0x3C8E7FD9478C4602),\n  reinterpret<f64>(0x3FEA1FFFD72EFDAF), reinterpret<f64>(0xBC6A0C554DCDAE7E),\n  reinterpret<f64>(0x3FEA5FFFDE04FF95), reinterpret<f64>(0x3C867DA98CE9B26B),\n  reinterpret<f64>(0x3FEA9FFFCA5E8D2B), reinterpret<f64>(0xBC8284C9B54C13DE),\n  reinterpret<f64>(0x3FEADFFFDDAD03EA), reinterpret<f64>(0x3C5812C8EA602E3C),\n  reinterpret<f64>(0x3FEB1FFFF10D3D4D), reinterpret<f64>(0xBC8EFADDAD27789C),\n  reinterpret<f64>(0x3FEB5FFFCE21165A), reinterpret<f64>(0x3C53CB1719C61237),\n  reinterpret<f64>(0x3FEB9FFFD950E674), reinterpret<f64>(0x3C73F7D94194CE00),\n  reinterpret<f64>(0x3FEBE000139CA8AF), reinterpret<f64>(0x3C750AC4215D9BC0),\n  reinterpret<f64>(0x3FEC20005B46DF99), reinterpret<f64>(0x3C6BEEA653E9C1C9),\n  reinterpret<f64>(0x3FEC600040B9F7AE), reinterpret<f64>(0xBC7C079F274A70D6),\n  reinterpret<f64>(0x3FECA0006255FD8A), reinterpret<f64>(0xBC7A0B4076E84C1F),\n  reinterpret<f64>(0x3FECDFFFD94C095D), reinterpret<f64>(0x3C88F933F99AB5D7),\n  reinterpret<f64>(0x3FED1FFFF975D6CF), reinterpret<f64>(0xBC582C08665FE1BE),\n  reinterpret<f64>(0x3FED5FFFA2561C93), reinterpret<f64>(0xBC7B04289BD295F3),\n  reinterpret<f64>(0x3FED9FFF9D228B0C), reinterpret<f64>(0x3C870251340FA236),\n  reinterpret<f64>(0x3FEDE00065BC7E16), reinterpret<f64>(0xBC75011E16A4D80C),\n  reinterpret<f64>(0x3FEE200002F64791), reinterpret<f64>(0x3C89802F09EF62E0),\n  reinterpret<f64>(0x3FEE600057D7A6D8), reinterpret<f64>(0xBC7E0B75580CF7FA),\n  reinterpret<f64>(0x3FEEA00027EDC00C), reinterpret<f64>(0xBC8C848309459811),\n  reinterpret<f64>(0x3FEEE0006CF5CB7C), reinterpret<f64>(0xBC8F8027951576F4),\n  reinterpret<f64>(0x3FEF2000782B7DCC), reinterpret<f64>(0xBC8F81D97274538F),\n  reinterpret<f64>(0x3FEF6000260C450A), reinterpret<f64>(0xBC4071002727FFDC),\n  reinterpret<f64>(0x3FEF9FFFE88CD533), reinterpret<f64>(0xBC581BDCE1FDA8B0),\n  reinterpret<f64>(0x3FEFDFFFD50F8689), reinterpret<f64>(0x3C87F91ACB918E6E),\n  reinterpret<f64>(0x3FF0200004292367), reinterpret<f64>(0x3C9B7FF365324681),\n  reinterpret<f64>(0x3FF05FFFE3E3D668), reinterpret<f64>(0x3C86FA08DDAE957B),\n  reinterpret<f64>(0x3FF0A0000A85A757), reinterpret<f64>(0xBC57E2DE80D3FB91),\n  reinterpret<f64>(0x3FF0E0001A5F3FCC), reinterpret<f64>(0xBC91823305C5F014),\n  reinterpret<f64>(0x3FF11FFFF8AFBAF5), reinterpret<f64>(0xBC8BFABB6680BAC2),\n  reinterpret<f64>(0x3FF15FFFE54D91AD), reinterpret<f64>(0xBC9D7F121737E7EF),\n  reinterpret<f64>(0x3FF1A00011AC36E1), reinterpret<f64>(0x3C9C000A0516F5FF),\n  reinterpret<f64>(0x3FF1E00019C84248), reinterpret<f64>(0xBC9082FBE4DA5DA0),\n  reinterpret<f64>(0x3FF220000FFE5E6E), reinterpret<f64>(0xBC88FDD04C9CFB43),\n  reinterpret<f64>(0x3FF26000269FD891), reinterpret<f64>(0x3C8CFE2A7994D182),\n  reinterpret<f64>(0x3FF2A00029A6E6DA), reinterpret<f64>(0xBC700273715E8BC5),\n  reinterpret<f64>(0x3FF2DFFFE0293E39), reinterpret<f64>(0x3C9B7C39DAB2A6F9),\n  reinterpret<f64>(0x3FF31FFFF7DCF082), reinterpret<f64>(0x3C7DF1336EDC5254),\n  reinterpret<f64>(0x3FF35FFFF05A8B60), reinterpret<f64>(0xBC9E03564CCD31EB),\n  reinterpret<f64>(0x3FF3A0002E0EAECC), reinterpret<f64>(0x3C75F0E74BD3A477),\n  reinterpret<f64>(0x3FF3E000043BB236), reinterpret<f64>(0x3C9C7DCB149D8833),\n  reinterpret<f64>(0x3FF4200002D187FF), reinterpret<f64>(0x3C7E08AFCF2D3D28),\n  reinterpret<f64>(0x3FF460000D387CB1), reinterpret<f64>(0x3C820837856599A6),\n  reinterpret<f64>(0x3FF4A00004569F89), reinterpret<f64>(0xBC89FA5C904FBCD2),\n  reinterpret<f64>(0x3FF4E000043543F3), reinterpret<f64>(0xBC781125ED175329),\n  reinterpret<f64>(0x3FF51FFFCC027F0F), reinterpret<f64>(0x3C9883D8847754DC),\n  reinterpret<f64>(0x3FF55FFFFD87B36F), reinterpret<f64>(0xBC8709E731D02807),\n  reinterpret<f64>(0x3FF59FFFF21DF7BA), reinterpret<f64>(0x3C87F79F68727B02),\n  reinterpret<f64>(0x3FF5DFFFEBFC3481), reinterpret<f64>(0xBC9180902E30E93E)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  var top = <u32>(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & 0xFFF0000000000000);\n\n  var invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n  var kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  var chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  var clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  var r   = (z - chi - clo) * invc;\n  var rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  var rlo = r - rhi;\n  var t1  = rhi * InvLn2hi;\n  var t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  var t3 = kd + logc;\n  var hi = t3 + t1;\n  var lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  var p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<f64>([\n  //              invc                ,                 logc\n  reinterpret<f64>(0x3FF734F0C3E0DE9F), reinterpret<f64>(0xBFD7CC7F79E69000),\n  reinterpret<f64>(0x3FF713786A2CE91F), reinterpret<f64>(0xBFD76FEEC20D0000),\n  reinterpret<f64>(0x3FF6F26008FAB5A0), reinterpret<f64>(0xBFD713E31351E000),\n  reinterpret<f64>(0x3FF6D1A61F138C7D), reinterpret<f64>(0xBFD6B85B38287800),\n  reinterpret<f64>(0x3FF6B1490BC5B4D1), reinterpret<f64>(0xBFD65D5590807800),\n  reinterpret<f64>(0x3FF69147332F0CBA), reinterpret<f64>(0xBFD602D076180000),\n  reinterpret<f64>(0x3FF6719F18224223), reinterpret<f64>(0xBFD5A8CA86909000),\n  reinterpret<f64>(0x3FF6524F99A51ED9), reinterpret<f64>(0xBFD54F4356035000),\n  reinterpret<f64>(0x3FF63356AA8F24C4), reinterpret<f64>(0xBFD4F637C36B4000),\n  reinterpret<f64>(0x3FF614B36B9DDC14), reinterpret<f64>(0xBFD49DA7FDA85000),\n  reinterpret<f64>(0x3FF5F66452C65C4C), reinterpret<f64>(0xBFD445923989A800),\n  reinterpret<f64>(0x3FF5D867B5912C4F), reinterpret<f64>(0xBFD3EDF439B0B800),\n  reinterpret<f64>(0x3FF5BABCCB5B90DE), reinterpret<f64>(0xBFD396CE448F7000),\n  reinterpret<f64>(0x3FF59D61F2D91A78), reinterpret<f64>(0xBFD3401E17BDA000),\n  reinterpret<f64>(0x3FF5805612465687), reinterpret<f64>(0xBFD2E9E2EF468000),\n  reinterpret<f64>(0x3FF56397CEE76BD3), reinterpret<f64>(0xBFD2941B3830E000),\n  reinterpret<f64>(0x3FF54725E2A77F93), reinterpret<f64>(0xBFD23EC58CDA8800),\n  reinterpret<f64>(0x3FF52AFF42064583), reinterpret<f64>(0xBFD1E9E129279000),\n  reinterpret<f64>(0x3FF50F22DBB2BDDF), reinterpret<f64>(0xBFD1956D2B48F800),\n  reinterpret<f64>(0x3FF4F38F4734DED7), reinterpret<f64>(0xBFD141679AB9F800),\n  reinterpret<f64>(0x3FF4D843CFDE2840), reinterpret<f64>(0xBFD0EDD094EF9800),\n  reinterpret<f64>(0x3FF4BD3EC078A3C8), reinterpret<f64>(0xBFD09AA518DB1000),\n  reinterpret<f64>(0x3FF4A27FC3E0258A), reinterpret<f64>(0xBFD047E65263B800),\n  reinterpret<f64>(0x3FF4880524D48434), reinterpret<f64>(0xBFCFEB224586F000),\n  reinterpret<f64>(0x3FF46DCE1B192D0B), reinterpret<f64>(0xBFCF474A7517B000),\n  reinterpret<f64>(0x3FF453D9D3391854), reinterpret<f64>(0xBFCEA4443D103000),\n  reinterpret<f64>(0x3FF43A2744B4845A), reinterpret<f64>(0xBFCE020D44E9B000),\n  reinterpret<f64>(0x3FF420B54115F8FB), reinterpret<f64>(0xBFCD60A22977F000),\n  reinterpret<f64>(0x3FF40782DA3EF4B1), reinterpret<f64>(0xBFCCC00104959000),\n  reinterpret<f64>(0x3FF3EE8F5D57FE8F), reinterpret<f64>(0xBFCC202956891000),\n  reinterpret<f64>(0x3FF3D5D9A00B4CE9), reinterpret<f64>(0xBFCB81178D811000),\n  reinterpret<f64>(0x3FF3BD60C010C12B), reinterpret<f64>(0xBFCAE2C9CCD3D000),\n  reinterpret<f64>(0x3FF3A5242B75DAB8), reinterpret<f64>(0xBFCA45402E129000),\n  reinterpret<f64>(0x3FF38D22CD9FD002), reinterpret<f64>(0xBFC9A877681DF000),\n  reinterpret<f64>(0x3FF3755BC5847A1C), reinterpret<f64>(0xBFC90C6D69483000),\n  reinterpret<f64>(0x3FF35DCE49AD36E2), reinterpret<f64>(0xBFC87120A645C000),\n  reinterpret<f64>(0x3FF34679984DD440), reinterpret<f64>(0xBFC7D68FB4143000),\n  reinterpret<f64>(0x3FF32F5CCEFFCB24), reinterpret<f64>(0xBFC73CB83C627000),\n  reinterpret<f64>(0x3FF3187775A10D49), reinterpret<f64>(0xBFC6A39A9B376000),\n  reinterpret<f64>(0x3FF301C8373E3990), reinterpret<f64>(0xBFC60B3154B7A000),\n  reinterpret<f64>(0x3FF2EB4EBB95F841), reinterpret<f64>(0xBFC5737D76243000),\n  reinterpret<f64>(0x3FF2D50A0219A9D1), reinterpret<f64>(0xBFC4DC7B8FC23000),\n  reinterpret<f64>(0x3FF2BEF9A8B7FD2A), reinterpret<f64>(0xBFC4462C51D20000),\n  reinterpret<f64>(0x3FF2A91C7A0C1BAB), reinterpret<f64>(0xBFC3B08ABC830000),\n  reinterpret<f64>(0x3FF293726014B530), reinterpret<f64>(0xBFC31B996B490000),\n  reinterpret<f64>(0x3FF27DFA5757A1F5), reinterpret<f64>(0xBFC2875490A44000),\n  reinterpret<f64>(0x3FF268B39B1D3BBF), reinterpret<f64>(0xBFC1F3B9F879A000),\n  reinterpret<f64>(0x3FF2539D838FF5BD), reinterpret<f64>(0xBFC160C8252CA000),\n  reinterpret<f64>(0x3FF23EB7AAC9083B), reinterpret<f64>(0xBFC0CE7F57F72000),\n  reinterpret<f64>(0x3FF22A012BA940B6), reinterpret<f64>(0xBFC03CDC49FEA000),\n  reinterpret<f64>(0x3FF2157996CC4132), reinterpret<f64>(0xBFBF57BDBC4B8000),\n  reinterpret<f64>(0x3FF201201DD2FC9B), reinterpret<f64>(0xBFBE370896404000),\n  reinterpret<f64>(0x3FF1ECF4494D480B), reinterpret<f64>(0xBFBD17983EF94000),\n  reinterpret<f64>(0x3FF1D8F5528F6569), reinterpret<f64>(0xBFBBF9674ED8A000),\n  reinterpret<f64>(0x3FF1C52311577E7C), reinterpret<f64>(0xBFBADC79202F6000),\n  reinterpret<f64>(0x3FF1B17C74CB26E9), reinterpret<f64>(0xBFB9C0C3E7288000),\n  reinterpret<f64>(0x3FF19E010C2C1AB6), reinterpret<f64>(0xBFB8A646B372C000),\n  reinterpret<f64>(0x3FF18AB07BB670BD), reinterpret<f64>(0xBFB78D01B3AC0000),\n  reinterpret<f64>(0x3FF1778A25EFBCB6), reinterpret<f64>(0xBFB674F145380000),\n  reinterpret<f64>(0x3FF1648D354C31DA), reinterpret<f64>(0xBFB55E0E6D878000),\n  reinterpret<f64>(0x3FF151B990275FDD), reinterpret<f64>(0xBFB4485CDEA1E000),\n  reinterpret<f64>(0x3FF13F0EA432D24C), reinterpret<f64>(0xBFB333D94D6AA000),\n  reinterpret<f64>(0x3FF12C8B7210F9DA), reinterpret<f64>(0xBFB22079F8C56000),\n  reinterpret<f64>(0x3FF11A3028ECB531), reinterpret<f64>(0xBFB10E4698622000),\n  reinterpret<f64>(0x3FF107FBDA8434AF), reinterpret<f64>(0xBFAFFA6C6AD20000),\n  reinterpret<f64>(0x3FF0F5EE0F4E6BB3), reinterpret<f64>(0xBFADDA8D4A774000),\n  reinterpret<f64>(0x3FF0E4065D2A9FCE), reinterpret<f64>(0xBFABBCECE4850000),\n  reinterpret<f64>(0x3FF0D244632CA521), reinterpret<f64>(0xBFA9A1894012C000),\n  reinterpret<f64>(0x3FF0C0A77CE2981A), reinterpret<f64>(0xBFA788583302C000),\n  reinterpret<f64>(0x3FF0AF2F83C636D1), reinterpret<f64>(0xBFA5715E67D68000),\n  reinterpret<f64>(0x3FF09DDB98A01339), reinterpret<f64>(0xBFA35C8A49658000),\n  reinterpret<f64>(0x3FF08CABAF52E7DF), reinterpret<f64>(0xBFA149E364154000),\n  reinterpret<f64>(0x3FF07B9F2F4E28FB), reinterpret<f64>(0xBF9E72C082EB8000),\n  reinterpret<f64>(0x3FF06AB58C358F19), reinterpret<f64>(0xBF9A55F152528000),\n  reinterpret<f64>(0x3FF059EEA5ECF92C), reinterpret<f64>(0xBF963D62CF818000),\n  reinterpret<f64>(0x3FF04949CDD12C90), reinterpret<f64>(0xBF9228FB8CAA0000),\n  reinterpret<f64>(0x3FF038C6C6F0ADA9), reinterpret<f64>(0xBF8C317B20F90000),\n  reinterpret<f64>(0x3FF02865137932A9), reinterpret<f64>(0xBF8419355DAA0000),\n  reinterpret<f64>(0x3FF0182427EA7348), reinterpret<f64>(0xBF781203C2EC0000),\n  reinterpret<f64>(0x3FF008040614B195), reinterpret<f64>(0xBF60040979240000),\n  reinterpret<f64>(0x3FEFE01FF726FA1A), reinterpret<f64>(0x3F6FEFF384900000),\n  reinterpret<f64>(0x3FEFA11CC261EA74), reinterpret<f64>(0x3F87DC41353D0000),\n  reinterpret<f64>(0x3FEF6310B081992E), reinterpret<f64>(0x3F93CEA3C4C28000),\n  reinterpret<f64>(0x3FEF25F63CEEADCD), reinterpret<f64>(0x3F9B9FC114890000),\n  reinterpret<f64>(0x3FEEE9C8039113E7), reinterpret<f64>(0x3FA1B0D8CE110000),\n  reinterpret<f64>(0x3FEEAE8078CBB1AB), reinterpret<f64>(0x3FA58A5BD001C000),\n  reinterpret<f64>(0x3FEE741AA29D0C9B), reinterpret<f64>(0x3FA95C8340D88000),\n  reinterpret<f64>(0x3FEE3A91830A99B5), reinterpret<f64>(0x3FAD276AEF578000),\n  reinterpret<f64>(0x3FEE01E009609A56), reinterpret<f64>(0x3FB07598E598C000),\n  reinterpret<f64>(0x3FEDCA01E577BB98), reinterpret<f64>(0x3FB253F5E30D2000),\n  reinterpret<f64>(0x3FED92F20B7C9103), reinterpret<f64>(0x3FB42EDD8B380000),\n  reinterpret<f64>(0x3FED5CAC66FB5CCE), reinterpret<f64>(0x3FB606598757C000),\n  reinterpret<f64>(0x3FED272CAA5EDE9D), reinterpret<f64>(0x3FB7DA76356A0000),\n  reinterpret<f64>(0x3FECF26E3E6B2CCD), reinterpret<f64>(0x3FB9AB434E1C6000),\n  reinterpret<f64>(0x3FECBE6DA2A77902), reinterpret<f64>(0x3FBB78C7BB0D6000),\n  reinterpret<f64>(0x3FEC8B266D37086D), reinterpret<f64>(0x3FBD431332E72000),\n  reinterpret<f64>(0x3FEC5894BD5D5804), reinterpret<f64>(0x3FBF0A3171DE6000),\n  reinterpret<f64>(0x3FEC26B533BB9F8C), reinterpret<f64>(0x3FC067152B914000),\n  reinterpret<f64>(0x3FEBF583EEECE73F), reinterpret<f64>(0x3FC147858292B000),\n  reinterpret<f64>(0x3FEBC4FD75DB96C1), reinterpret<f64>(0x3FC2266ECDCA3000),\n  reinterpret<f64>(0x3FEB951E0C864A28), reinterpret<f64>(0x3FC303D7A6C55000),\n  reinterpret<f64>(0x3FEB65E2C5EF3E2C), reinterpret<f64>(0x3FC3DFC33C331000),\n  reinterpret<f64>(0x3FEB374867C9888B), reinterpret<f64>(0x3FC4BA366B7A8000),\n  reinterpret<f64>(0x3FEB094B211D304A), reinterpret<f64>(0x3FC5933928D1F000),\n  reinterpret<f64>(0x3FEADBE885F2EF7E), reinterpret<f64>(0x3FC66ACD2418F000),\n  reinterpret<f64>(0x3FEAAF1D31603DA2), reinterpret<f64>(0x3FC740F8EC669000),\n  reinterpret<f64>(0x3FEA82E63FD358A7), reinterpret<f64>(0x3FC815C0F51AF000),\n  reinterpret<f64>(0x3FEA5740EF09738B), reinterpret<f64>(0x3FC8E92954F68000),\n  reinterpret<f64>(0x3FEA2C2A90AB4B27), reinterpret<f64>(0x3FC9BB3602F84000),\n  reinterpret<f64>(0x3FEA01A01393F2D1), reinterpret<f64>(0x3FCA8BED1C2C0000),\n  reinterpret<f64>(0x3FE9D79F24DB3C1B), reinterpret<f64>(0x3FCB5B515C01D000),\n  reinterpret<f64>(0x3FE9AE2505C7B190), reinterpret<f64>(0x3FCC2967CCBCC000),\n  reinterpret<f64>(0x3FE9852EF297CE2F), reinterpret<f64>(0x3FCCF635D5486000),\n  reinterpret<f64>(0x3FE95CBAEEA44B75), reinterpret<f64>(0x3FCDC1BD3446C000),\n  reinterpret<f64>(0x3FE934C69DE74838), reinterpret<f64>(0x3FCE8C01B8CFE000),\n  reinterpret<f64>(0x3FE90D4F2F6752E6), reinterpret<f64>(0x3FCF5509C0179000),\n  reinterpret<f64>(0x3FE8E6528EFFD79D), reinterpret<f64>(0x3FD00E6C121FB800),\n  reinterpret<f64>(0x3FE8BFCE9FCC007C), reinterpret<f64>(0x3FD071B80E93D000),\n  reinterpret<f64>(0x3FE899C0DABEC30E), reinterpret<f64>(0x3FD0D46B9E867000),\n  reinterpret<f64>(0x3FE87427AA2317FB), reinterpret<f64>(0x3FD13687334BD000),\n  reinterpret<f64>(0x3FE84F00ACB39A08), reinterpret<f64>(0x3FD1980D67234800),\n  reinterpret<f64>(0x3FE82A49E8653E55), reinterpret<f64>(0x3FD1F8FFE0CC8000),\n  reinterpret<f64>(0x3FE8060195F40260), reinterpret<f64>(0x3FD2595FD7636800),\n  reinterpret<f64>(0x3FE7E22563E0A329), reinterpret<f64>(0x3FD2B9300914A800),\n  reinterpret<f64>(0x3FE7BEB377DCB5AD), reinterpret<f64>(0x3FD3187210436000),\n  reinterpret<f64>(0x3FE79BAA679725C2), reinterpret<f64>(0x3FD377266DEC1800),\n  reinterpret<f64>(0x3FE77907F2170657), reinterpret<f64>(0x3FD3D54FFBAF3000),\n  reinterpret<f64>(0x3FE756CADBD6130C), reinterpret<f64>(0x3FD432EEE32FE000)\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<f64>([\n  //               chi                ,                  clo\n  reinterpret<f64>(0x3FE61000014FB66B), reinterpret<f64>(0x3C7E026C91425B3C),\n  reinterpret<f64>(0x3FE63000034DB495), reinterpret<f64>(0x3C8DBFEA48005D41),\n  reinterpret<f64>(0x3FE650000D94D478), reinterpret<f64>(0x3C8E7FA786D6A5B7),\n  reinterpret<f64>(0x3FE67000074E6FAD), reinterpret<f64>(0x3C61FCEA6B54254C),\n  reinterpret<f64>(0x3FE68FFFFEDF0FAE), reinterpret<f64>(0xBC7C7E274C590EFD),\n  reinterpret<f64>(0x3FE6B0000763C5BC), reinterpret<f64>(0xBC8AC16848DCDA01),\n  reinterpret<f64>(0x3FE6D0001E5CC1F6), reinterpret<f64>(0x3C833F1C9D499311),\n  reinterpret<f64>(0x3FE6EFFFEB05F63E), reinterpret<f64>(0xBC7E80041AE22D53),\n  reinterpret<f64>(0x3FE710000E869780), reinterpret<f64>(0x3C7BFF6671097952),\n  reinterpret<f64>(0x3FE72FFFFC67E912), reinterpret<f64>(0x3C8C00E226BD8724),\n  reinterpret<f64>(0x3FE74FFFDF81116A), reinterpret<f64>(0xBC6E02916EF101D2),\n  reinterpret<f64>(0x3FE770000F679C90), reinterpret<f64>(0xBC67FC71CD549C74),\n  reinterpret<f64>(0x3FE78FFFFA7EC835), reinterpret<f64>(0x3C81BEC19EF50483),\n  reinterpret<f64>(0x3FE7AFFFFE20C2E6), reinterpret<f64>(0xBC707E1729CC6465),\n  reinterpret<f64>(0x3FE7CFFFED3FC900), reinterpret<f64>(0xBC808072087B8B1C),\n  reinterpret<f64>(0x3FE7EFFFE9261A76), reinterpret<f64>(0x3C8DC0286D9DF9AE),\n  reinterpret<f64>(0x3FE81000049CA3E8), reinterpret<f64>(0x3C897FD251E54C33),\n  reinterpret<f64>(0x3FE8300017932C8F), reinterpret<f64>(0xBC8AFEE9B630F381),\n  reinterpret<f64>(0x3FE850000633739C), reinterpret<f64>(0x3C89BFBF6B6535BC),\n  reinterpret<f64>(0x3FE87000204289C6), reinterpret<f64>(0xBC8BBF65F3117B75),\n  reinterpret<f64>(0x3FE88FFFEBF57904), reinterpret<f64>(0xBC89006EA23DCB57),\n  reinterpret<f64>(0x3FE8B00022BC04DF), reinterpret<f64>(0xBC7D00DF38E04B0A),\n  reinterpret<f64>(0x3FE8CFFFE50C1B8A), reinterpret<f64>(0xBC88007146FF9F05),\n  reinterpret<f64>(0x3FE8EFFFFC918E43), reinterpret<f64>(0x3C83817BD07A7038),\n  reinterpret<f64>(0x3FE910001EFA5FC7), reinterpret<f64>(0x3C893E9176DFB403),\n  reinterpret<f64>(0x3FE9300013467BB9), reinterpret<f64>(0x3C7F804E4B980276),\n  reinterpret<f64>(0x3FE94FFFE6EE076F), reinterpret<f64>(0xBC8F7EF0D9FF622E),\n  reinterpret<f64>(0x3FE96FFFDE3C12D1), reinterpret<f64>(0xBC7082AA962638BA),\n  reinterpret<f64>(0x3FE98FFFF4458A0D), reinterpret<f64>(0xBC87801B9164A8EF),\n  reinterpret<f64>(0x3FE9AFFFDD982E3E), reinterpret<f64>(0xBC8740E08A5A9337),\n  reinterpret<f64>(0x3FE9CFFFED49FB66), reinterpret<f64>(0x3C3FCE08C19BE000),\n  reinterpret<f64>(0x3FE9F00020F19C51), reinterpret<f64>(0xBC8A3FAA27885B0A),\n  reinterpret<f64>(0x3FEA10001145B006), reinterpret<f64>(0x3C74FF489958DA56),\n  reinterpret<f64>(0x3FEA300007BBF6FA), reinterpret<f64>(0x3C8CBEAB8A2B6D18),\n  reinterpret<f64>(0x3FEA500010971D79), reinterpret<f64>(0x3C88FECADD787930),\n  reinterpret<f64>(0x3FEA70001DF52E48), reinterpret<f64>(0xBC8F41763DD8ABDB),\n  reinterpret<f64>(0x3FEA90001C593352), reinterpret<f64>(0xBC8EBF0284C27612),\n  reinterpret<f64>(0x3FEAB0002A4F3E4B), reinterpret<f64>(0xBC69FD043CFF3F5F),\n  reinterpret<f64>(0x3FEACFFFD7AE1ED1), reinterpret<f64>(0xBC823EE7129070B4),\n  reinterpret<f64>(0x3FEAEFFFEE510478), reinterpret<f64>(0x3C6A063EE00EDEA3),\n  reinterpret<f64>(0x3FEB0FFFDB650D5B), reinterpret<f64>(0x3C5A06C8381F0AB9),\n  reinterpret<f64>(0x3FEB2FFFFEAACA57), reinterpret<f64>(0xBC79011E74233C1D),\n  reinterpret<f64>(0x3FEB4FFFD995BADC), reinterpret<f64>(0xBC79FF1068862A9F),\n  reinterpret<f64>(0x3FEB7000249E659C), reinterpret<f64>(0x3C8AFF45D0864F3E),\n  reinterpret<f64>(0x3FEB8FFFF9871640), reinterpret<f64>(0x3C7CFE7796C2C3F9),\n  reinterpret<f64>(0x3FEBAFFFD204CB4F), reinterpret<f64>(0xBC63FF27EEF22BC4),\n  reinterpret<f64>(0x3FEBCFFFD2415C45), reinterpret<f64>(0xBC6CFFB7EE3BEA21),\n  reinterpret<f64>(0x3FEBEFFFF86309DF), reinterpret<f64>(0xBC814103972E0B5C),\n  reinterpret<f64>(0x3FEC0FFFE1B57653), reinterpret<f64>(0x3C8BC16494B76A19),\n  reinterpret<f64>(0x3FEC2FFFF1FA57E3), reinterpret<f64>(0xBC64FEEF8D30C6ED),\n  reinterpret<f64>(0x3FEC4FFFDCBFE424), reinterpret<f64>(0xBC843F68BCEC4775),\n  reinterpret<f64>(0x3FEC6FFFED54B9F7), reinterpret<f64>(0x3C847EA3F053E0EC),\n  reinterpret<f64>(0x3FEC8FFFEB998FD5), reinterpret<f64>(0x3C7383068DF992F1),\n  reinterpret<f64>(0x3FECB0002125219A), reinterpret<f64>(0xBC68FD8E64180E04),\n  reinterpret<f64>(0x3FECCFFFDD94469C), reinterpret<f64>(0x3C8E7EBE1CC7EA72),\n  reinterpret<f64>(0x3FECEFFFEAFDC476), reinterpret<f64>(0x3C8EBE39AD9F88FE),\n  reinterpret<f64>(0x3FED1000169AF82B), reinterpret<f64>(0x3C757D91A8B95A71),\n  reinterpret<f64>(0x3FED30000D0FF71D), reinterpret<f64>(0x3C89C1906970C7DA),\n  reinterpret<f64>(0x3FED4FFFEA790FC4), reinterpret<f64>(0xBC580E37C558FE0C),\n  reinterpret<f64>(0x3FED70002EDC87E5), reinterpret<f64>(0xBC7F80D64DC10F44),\n  reinterpret<f64>(0x3FED900021DC82AA), reinterpret<f64>(0xBC747C8F94FD5C5C),\n  reinterpret<f64>(0x3FEDAFFFD86B0283), reinterpret<f64>(0x3C8C7F1DC521617E),\n  reinterpret<f64>(0x3FEDD000296C4739), reinterpret<f64>(0x3C88019EB2FFB153),\n  reinterpret<f64>(0x3FEDEFFFE54490F5), reinterpret<f64>(0x3C6E00D2C652CC89),\n  reinterpret<f64>(0x3FEE0FFFCDABF694), reinterpret<f64>(0xBC7F8340202D69D2),\n  reinterpret<f64>(0x3FEE2FFFDB52C8DD), reinterpret<f64>(0x3C7B00C1CA1B0864),\n  reinterpret<f64>(0x3FEE4FFFF24216EF), reinterpret<f64>(0x3C72FFA8B094AB51),\n  reinterpret<f64>(0x3FEE6FFFE88A5E11), reinterpret<f64>(0xBC57F673B1EFBE59),\n  reinterpret<f64>(0x3FEE9000119EFF0D), reinterpret<f64>(0xBC84808D5E0BC801),\n  reinterpret<f64>(0x3FEEAFFFDFA51744), reinterpret<f64>(0x3C780006D54320B5),\n  reinterpret<f64>(0x3FEED0001A127FA1), reinterpret<f64>(0xBC5002F860565C92),\n  reinterpret<f64>(0x3FEEF00007BABCC4), reinterpret<f64>(0xBC8540445D35E611),\n  reinterpret<f64>(0x3FEF0FFFF57A8D02), reinterpret<f64>(0xBC4FFB3139EF9105),\n  reinterpret<f64>(0x3FEF30001EE58AC7), reinterpret<f64>(0x3C8A81ACF2731155),\n  reinterpret<f64>(0x3FEF4FFFF5823494), reinterpret<f64>(0x3C8A3F41D4D7C743),\n  reinterpret<f64>(0x3FEF6FFFFCA94C6B), reinterpret<f64>(0xBC6202F41C987875),\n  reinterpret<f64>(0x3FEF8FFFE1F9C441), reinterpret<f64>(0x3C777DD1F477E74B),\n  reinterpret<f64>(0x3FEFAFFFD2E0E37E), reinterpret<f64>(0xBC6F01199A7CA331),\n  reinterpret<f64>(0x3FEFD0001C77E49E), reinterpret<f64>(0x3C7181EE4BCEACB1),\n  reinterpret<f64>(0x3FEFEFFFF7E0C331), reinterpret<f64>(0xBC6E05370170875A),\n  reinterpret<f64>(0x3FF00FFFF465606E), reinterpret<f64>(0xBC8A7EAD491C0ADA),\n  reinterpret<f64>(0x3FF02FFFF3867A58), reinterpret<f64>(0xBC977F69C3FCB2E0),\n  reinterpret<f64>(0x3FF04FFFFDFC0D17), reinterpret<f64>(0x3C97BFFE34CB945B),\n  reinterpret<f64>(0x3FF0700003CD4D82), reinterpret<f64>(0x3C820083C0E456CB),\n  reinterpret<f64>(0x3FF08FFFF9F2CBE8), reinterpret<f64>(0xBC6DFFDFBE37751A),\n  reinterpret<f64>(0x3FF0B000010CDA65), reinterpret<f64>(0xBC913F7FAEE626EB),\n  reinterpret<f64>(0x3FF0D00001A4D338), reinterpret<f64>(0x3C807DFA79489FF7),\n  reinterpret<f64>(0x3FF0EFFFFADAFDFD), reinterpret<f64>(0xBC77040570D66BC0),\n  reinterpret<f64>(0x3FF110000BBAFD96), reinterpret<f64>(0x3C8E80D4846D0B62),\n  reinterpret<f64>(0x3FF12FFFFAE5F45D), reinterpret<f64>(0x3C9DBFFA64FD36EF),\n  reinterpret<f64>(0x3FF150000DD59AD9), reinterpret<f64>(0x3C9A0077701250AE),\n  reinterpret<f64>(0x3FF170000F21559A), reinterpret<f64>(0x3C8DFDF9E2E3DEEE),\n  reinterpret<f64>(0x3FF18FFFFC275426), reinterpret<f64>(0x3C910030DC3B7273),\n  reinterpret<f64>(0x3FF1B000123D3C59), reinterpret<f64>(0x3C997F7980030188),\n  reinterpret<f64>(0x3FF1CFFFF8299EB7), reinterpret<f64>(0xBC65F932AB9F8C67),\n  reinterpret<f64>(0x3FF1EFFFF48AD400), reinterpret<f64>(0x3C937FBF9DA75BEB),\n  reinterpret<f64>(0x3FF210000C8B86A4), reinterpret<f64>(0x3C9F806B91FD5B22),\n  reinterpret<f64>(0x3FF2300003854303), reinterpret<f64>(0x3C93FFC2EB9FBF33),\n  reinterpret<f64>(0x3FF24FFFFFBCF684), reinterpret<f64>(0x3C7601E77E2E2E72),\n  reinterpret<f64>(0x3FF26FFFF52921D9), reinterpret<f64>(0x3C7FFCBB767F0C61),\n  reinterpret<f64>(0x3FF2900014933A3C), reinterpret<f64>(0xBC7202CA3C02412B),\n  reinterpret<f64>(0x3FF2B00014556313), reinterpret<f64>(0xBC92808233F21F02),\n  reinterpret<f64>(0x3FF2CFFFEBFE523B), reinterpret<f64>(0xBC88FF7E384FDCF2),\n  reinterpret<f64>(0x3FF2F0000BB8AD96), reinterpret<f64>(0xBC85FF51503041C5),\n  reinterpret<f64>(0x3FF30FFFFB7AE2AF), reinterpret<f64>(0xBC810071885E289D),\n  reinterpret<f64>(0x3FF32FFFFEAC5F7F), reinterpret<f64>(0xBC91FF5D3FB7B715),\n  reinterpret<f64>(0x3FF350000CA66756), reinterpret<f64>(0x3C957F82228B82BD),\n  reinterpret<f64>(0x3FF3700011FBF721), reinterpret<f64>(0x3C8000BAC40DD5CC),\n  reinterpret<f64>(0x3FF38FFFF9592FB9), reinterpret<f64>(0xBC943F9D2DB2A751),\n  reinterpret<f64>(0x3FF3B00004DDD242), reinterpret<f64>(0x3C857F6B707638E1),\n  reinterpret<f64>(0x3FF3CFFFF5B2C957), reinterpret<f64>(0x3C7A023A10BF1231),\n  reinterpret<f64>(0x3FF3EFFFEAB0B418), reinterpret<f64>(0x3C987F6D66B152B0),\n  reinterpret<f64>(0x3FF410001532AFF4), reinterpret<f64>(0x3C67F8375F198524),\n  reinterpret<f64>(0x3FF4300017478B29), reinterpret<f64>(0x3C8301E672DC5143),\n  reinterpret<f64>(0x3FF44FFFE795B463), reinterpret<f64>(0x3C89FF69B8B2895A),\n  reinterpret<f64>(0x3FF46FFFE80475E0), reinterpret<f64>(0xBC95C0B19BC2F254),\n  reinterpret<f64>(0x3FF48FFFEF6FC1E7), reinterpret<f64>(0x3C9B4009F23A2A72),\n  reinterpret<f64>(0x3FF4AFFFE5BEA704), reinterpret<f64>(0xBC94FFB7BF0D7D45),\n  reinterpret<f64>(0x3FF4D000171027DE), reinterpret<f64>(0xBC99C06471DC6A3D),\n  reinterpret<f64>(0x3FF4F0000FF03EE2), reinterpret<f64>(0x3C977F890B85531C),\n  reinterpret<f64>(0x3FF5100012DC4BD1), reinterpret<f64>(0x3C6004657166A436),\n  reinterpret<f64>(0x3FF530001605277A), reinterpret<f64>(0xBC96BFCECE233209),\n  reinterpret<f64>(0x3FF54FFFECDB704C), reinterpret<f64>(0xBC8902720505A1D7),\n  reinterpret<f64>(0x3FF56FFFEF5F54A9), reinterpret<f64>(0x3C9BBFE60EC96412),\n  reinterpret<f64>(0x3FF5900017E61012), reinterpret<f64>(0x3C887EC581AFEF90),\n  reinterpret<f64>(0x3FF5B00003C93E92), reinterpret<f64>(0xBC9F41080ABF0CC0),\n  reinterpret<f64>(0x3FF5D0001D4919BC), reinterpret<f64>(0xBC98812AFB254729),\n  reinterpret<f64>(0x3FF5EFFFE7B87A89), reinterpret<f64>(0xBC947EB780ED6904)\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  var top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp  = ix - 0x3FE6000000000000;\n  var i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  var k    = <i64>tmp >> 52;\n  var iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  var invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  var logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  var z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  var r = (z - chi - clo) * invc;\n  // #endif\n  var kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  var w  = kd * Ln2hi + logc;\n  var hi = w + r;\n  var lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  var r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<f64>([\n  //             invc                 ,pad,               logc                 ,               logctail\n  reinterpret<f64>(0x3FF6A00000000000), 0, reinterpret<f64>(0xBFD62C82F2B9C800), reinterpret<f64>(0x3CFAB42428375680),\n  reinterpret<f64>(0x3FF6800000000000), 0, reinterpret<f64>(0xBFD5D1BDBF580800), reinterpret<f64>(0xBD1CA508D8E0F720),\n  reinterpret<f64>(0x3FF6600000000000), 0, reinterpret<f64>(0xBFD5767717455800), reinterpret<f64>(0xBD2362A4D5B6506D),\n  reinterpret<f64>(0x3FF6400000000000), 0, reinterpret<f64>(0xBFD51AAD872DF800), reinterpret<f64>(0xBCE684E49EB067D5),\n  reinterpret<f64>(0x3FF6200000000000), 0, reinterpret<f64>(0xBFD4BE5F95777800), reinterpret<f64>(0xBD041B6993293EE0),\n  reinterpret<f64>(0x3FF6000000000000), 0, reinterpret<f64>(0xBFD4618BC21C6000), reinterpret<f64>(0x3D13D82F484C84CC),\n  reinterpret<f64>(0x3FF5E00000000000), 0, reinterpret<f64>(0xBFD404308686A800), reinterpret<f64>(0x3CDC42F3ED820B3A),\n  reinterpret<f64>(0x3FF5C00000000000), 0, reinterpret<f64>(0xBFD3A64C55694800), reinterpret<f64>(0x3D20B1C686519460),\n  reinterpret<f64>(0x3FF5A00000000000), 0, reinterpret<f64>(0xBFD347DD9A988000), reinterpret<f64>(0x3D25594DD4C58092),\n  reinterpret<f64>(0x3FF5800000000000), 0, reinterpret<f64>(0xBFD2E8E2BAE12000), reinterpret<f64>(0x3D267B1E99B72BD8),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5600000000000), 0, reinterpret<f64>(0xBFD2895A13DE8800), reinterpret<f64>(0x3D15CA14B6CFB03F),\n  reinterpret<f64>(0x3FF5400000000000), 0, reinterpret<f64>(0xBFD22941FBCF7800), reinterpret<f64>(0xBD165A242853DA76),\n  reinterpret<f64>(0x3FF5200000000000), 0, reinterpret<f64>(0xBFD1C898C1699800), reinterpret<f64>(0xBD1FAFBC68E75404),\n  reinterpret<f64>(0x3FF5000000000000), 0, reinterpret<f64>(0xBFD1675CABABA800), reinterpret<f64>(0x3D1F1FC63382A8F0),\n  reinterpret<f64>(0x3FF4E00000000000), 0, reinterpret<f64>(0xBFD1058BF9AE4800), reinterpret<f64>(0xBD26A8C4FD055A66),\n  reinterpret<f64>(0x3FF4C00000000000), 0, reinterpret<f64>(0xBFD0A324E2739000), reinterpret<f64>(0xBD0C6BEE7EF4030E),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4A00000000000), 0, reinterpret<f64>(0xBFD0402594B4D000), reinterpret<f64>(0xBCF036B89EF42D7F),\n  reinterpret<f64>(0x3FF4800000000000), 0, reinterpret<f64>(0xBFCFB9186D5E4000), reinterpret<f64>(0x3D0D572AAB993C87),\n  reinterpret<f64>(0x3FF4600000000000), 0, reinterpret<f64>(0xBFCEF0ADCBDC6000), reinterpret<f64>(0x3D2B26B79C86AF24),\n  reinterpret<f64>(0x3FF4400000000000), 0, reinterpret<f64>(0xBFCE27076E2AF000), reinterpret<f64>(0xBD172F4F543FFF10),\n  reinterpret<f64>(0x3FF4200000000000), 0, reinterpret<f64>(0xBFCD5C216B4FC000), reinterpret<f64>(0x3D21BA91BBCA681B),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF4000000000000), 0, reinterpret<f64>(0xBFCC8FF7C79AA000), reinterpret<f64>(0x3D27794F689F8434),\n  reinterpret<f64>(0x3FF3E00000000000), 0, reinterpret<f64>(0xBFCBC286742D9000), reinterpret<f64>(0x3D194EB0318BB78F),\n  reinterpret<f64>(0x3FF3C00000000000), 0, reinterpret<f64>(0xBFCAF3C94E80C000), reinterpret<f64>(0x3CBA4E633FCD9066),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3A00000000000), 0, reinterpret<f64>(0xBFCA23BC1FE2B000), reinterpret<f64>(0xBD258C64DC46C1EA),\n  reinterpret<f64>(0x3FF3800000000000), 0, reinterpret<f64>(0xBFC9525A9CF45000), reinterpret<f64>(0xBD2AD1D904C1D4E3),\n  reinterpret<f64>(0x3FF3600000000000), 0, reinterpret<f64>(0xBFC87FA06520D000), reinterpret<f64>(0x3D2BBDBF7FDBFA09),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3400000000000), 0, reinterpret<f64>(0xBFC7AB890210E000), reinterpret<f64>(0x3D2BDB9072534A58),\n  reinterpret<f64>(0x3FF3200000000000), 0, reinterpret<f64>(0xBFC6D60FE719D000), reinterpret<f64>(0xBD10E46AA3B2E266),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF3000000000000), 0, reinterpret<f64>(0xBFC5FF3070A79000), reinterpret<f64>(0xBD1E9E439F105039),\n  reinterpret<f64>(0x3FF2E00000000000), 0, reinterpret<f64>(0xBFC526E5E3A1B000), reinterpret<f64>(0xBD20DE8B90075B8F),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2C00000000000), 0, reinterpret<f64>(0xBFC44D2B6CCB8000), reinterpret<f64>(0x3D170CC16135783C),\n  reinterpret<f64>(0x3FF2A00000000000), 0, reinterpret<f64>(0xBFC371FC201E9000), reinterpret<f64>(0x3CF178864D27543A),\n  reinterpret<f64>(0x3FF2800000000000), 0, reinterpret<f64>(0xBFC29552F81FF000), reinterpret<f64>(0xBD248D301771C408),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2600000000000), 0, reinterpret<f64>(0xBFC1B72AD52F6000), reinterpret<f64>(0xBD2E80A41811A396),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2400000000000), 0, reinterpret<f64>(0xBFC0D77E7CD09000), reinterpret<f64>(0x3D0A699688E85BF4),\n  reinterpret<f64>(0x3FF2200000000000), 0, reinterpret<f64>(0xBFBFEC9131DBE000), reinterpret<f64>(0xBD2575545CA333F2),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF2000000000000), 0, reinterpret<f64>(0xBFBE27076E2B0000), reinterpret<f64>(0x3D2A342C2AF0003C),\n  reinterpret<f64>(0x3FF1E00000000000), 0, reinterpret<f64>(0xBFBC5E548F5BC000), reinterpret<f64>(0xBD1D0C57585FBE06),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1C00000000000), 0, reinterpret<f64>(0xBFBA926D3A4AE000), reinterpret<f64>(0x3D253935E85BAAC8),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1A00000000000), 0, reinterpret<f64>(0xBFB8C345D631A000), reinterpret<f64>(0x3D137C294D2F5668),\n  reinterpret<f64>(0x3FF1800000000000), 0, reinterpret<f64>(0xBFB6F0D28AE56000), reinterpret<f64>(0xBD269737C93373DA),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1600000000000), 0, reinterpret<f64>(0xBFB51B073F062000), reinterpret<f64>(0x3D1F025B61C65E57),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1400000000000), 0, reinterpret<f64>(0xBFB341D7961BE000), reinterpret<f64>(0x3D2C5EDACCF913DF),\n  reinterpret<f64>(0x3FF1200000000000), 0, reinterpret<f64>(0xBFB16536EEA38000), reinterpret<f64>(0x3D147C5E768FA309),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF1000000000000), 0, reinterpret<f64>(0xBFAF0A30C0118000), reinterpret<f64>(0x3D2D599E83368E91),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0E00000000000), 0, reinterpret<f64>(0xBFAB42DD71198000), reinterpret<f64>(0x3D1C827AE5D6704C),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0C00000000000), 0, reinterpret<f64>(0xBFA77458F632C000), reinterpret<f64>(0xBD2CFC4634F2A1EE),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0A00000000000), 0, reinterpret<f64>(0xBFA39E87B9FEC000), reinterpret<f64>(0x3CF502B7F526FEAA),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0800000000000), 0, reinterpret<f64>(0xBF9F829B0E780000), reinterpret<f64>(0xBD2980267C7E09E4),\n  reinterpret<f64>(0x3FF0600000000000), 0, reinterpret<f64>(0xBF97B91B07D58000), reinterpret<f64>(0xBD288D5493FAA639),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0400000000000), 0, reinterpret<f64>(0xBF8FC0A8B0FC0000), reinterpret<f64>(0xBCDF1E7CF6D3A69C),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0200000000000), 0, reinterpret<f64>(0xBF7FE02A6B100000), reinterpret<f64>(0xBD19E23F0DDA40E4),\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FF0000000000000), 0, 0, 0,\n  reinterpret<f64>(0x3FEFC00000000000), 0, reinterpret<f64>(0x3F80101575890000), reinterpret<f64>(0xBD10C76B999D2BE8),\n  reinterpret<f64>(0x3FEF800000000000), 0, reinterpret<f64>(0x3F90205658938000), reinterpret<f64>(0xBD23DC5B06E2F7D2),\n  reinterpret<f64>(0x3FEF400000000000), 0, reinterpret<f64>(0x3F98492528C90000), reinterpret<f64>(0xBD2AA0BA325A0C34),\n  reinterpret<f64>(0x3FEF000000000000), 0, reinterpret<f64>(0x3FA0415D89E74000), reinterpret<f64>(0x3D0111C05CF1D753),\n  reinterpret<f64>(0x3FEEC00000000000), 0, reinterpret<f64>(0x3FA466AED42E0000), reinterpret<f64>(0xBD2C167375BDFD28),\n  reinterpret<f64>(0x3FEE800000000000), 0, reinterpret<f64>(0x3FA894AA149FC000), reinterpret<f64>(0xBD197995D05A267D),\n  reinterpret<f64>(0x3FEE400000000000), 0, reinterpret<f64>(0x3FACCB73CDDDC000), reinterpret<f64>(0xBD1A68F247D82807),\n  reinterpret<f64>(0x3FEE200000000000), 0, reinterpret<f64>(0x3FAEEA31C006C000), reinterpret<f64>(0xBD0E113E4FC93B7B),\n  reinterpret<f64>(0x3FEDE00000000000), 0, reinterpret<f64>(0x3FB1973BD1466000), reinterpret<f64>(0xBD25325D560D9E9B),\n  reinterpret<f64>(0x3FEDA00000000000), 0, reinterpret<f64>(0x3FB3BDF5A7D1E000), reinterpret<f64>(0x3D2CC85EA5DB4ED7),\n  reinterpret<f64>(0x3FED600000000000), 0, reinterpret<f64>(0x3FB5E95A4D97A000), reinterpret<f64>(0xBD2C69063C5D1D1E),\n  reinterpret<f64>(0x3FED400000000000), 0, reinterpret<f64>(0x3FB700D30AEAC000), reinterpret<f64>(0x3CEC1E8DA99DED32),\n  reinterpret<f64>(0x3FED000000000000), 0, reinterpret<f64>(0x3FB9335E5D594000), reinterpret<f64>(0x3D23115C3ABD47DA),\n  reinterpret<f64>(0x3FECC00000000000), 0, reinterpret<f64>(0x3FBB6AC88DAD6000), reinterpret<f64>(0xBD1390802BF768E5),\n  reinterpret<f64>(0x3FECA00000000000), 0, reinterpret<f64>(0x3FBC885801BC4000), reinterpret<f64>(0x3D2646D1C65AACD3),\n  reinterpret<f64>(0x3FEC600000000000), 0, reinterpret<f64>(0x3FBEC739830A2000), reinterpret<f64>(0xBD2DC068AFE645E0),\n  reinterpret<f64>(0x3FEC400000000000), 0, reinterpret<f64>(0x3FBFE89139DBE000), reinterpret<f64>(0xBD2534D64FA10AFD),\n  reinterpret<f64>(0x3FEC000000000000), 0, reinterpret<f64>(0x3FC1178E8227E000), reinterpret<f64>(0x3D21EF78CE2D07F2),\n  reinterpret<f64>(0x3FEBE00000000000), 0, reinterpret<f64>(0x3FC1AA2B7E23F000), reinterpret<f64>(0x3D2CA78E44389934),\n  reinterpret<f64>(0x3FEBA00000000000), 0, reinterpret<f64>(0x3FC2D1610C868000), reinterpret<f64>(0x3D039D6CCB81B4A1),\n  reinterpret<f64>(0x3FEB800000000000), 0, reinterpret<f64>(0x3FC365FCB0159000), reinterpret<f64>(0x3CC62FA8234B7289),\n  reinterpret<f64>(0x3FEB400000000000), 0, reinterpret<f64>(0x3FC4913D8333B000), reinterpret<f64>(0x3D25837954FDB678),\n  reinterpret<f64>(0x3FEB200000000000), 0, reinterpret<f64>(0x3FC527E5E4A1B000), reinterpret<f64>(0x3D2633E8E5697DC7),\n  reinterpret<f64>(0x3FEAE00000000000), 0, reinterpret<f64>(0x3FC6574EBE8C1000), reinterpret<f64>(0x3D19CF8B2C3C2E78),\n  reinterpret<f64>(0x3FEAC00000000000), 0, reinterpret<f64>(0x3FC6F0128B757000), reinterpret<f64>(0xBD25118DE59C21E1),\n  reinterpret<f64>(0x3FEAA00000000000), 0, reinterpret<f64>(0x3FC7898D85445000), reinterpret<f64>(0xBD1C661070914305),\n  reinterpret<f64>(0x3FEA600000000000), 0, reinterpret<f64>(0x3FC8BEAFEB390000), reinterpret<f64>(0xBD073D54AAE92CD1),\n  reinterpret<f64>(0x3FEA400000000000), 0, reinterpret<f64>(0x3FC95A5ADCF70000), reinterpret<f64>(0x3D07F22858A0FF6F),\n  reinterpret<f64>(0x3FEA000000000000), 0, reinterpret<f64>(0x3FCA93ED3C8AE000), reinterpret<f64>(0xBD28724350562169),\n  reinterpret<f64>(0x3FE9E00000000000), 0, reinterpret<f64>(0x3FCB31D8575BD000), reinterpret<f64>(0xBD0C358D4EACE1AA),\n  reinterpret<f64>(0x3FE9C00000000000), 0, reinterpret<f64>(0x3FCBD087383BE000), reinterpret<f64>(0xBD2D4BC4595412B6),\n  reinterpret<f64>(0x3FE9A00000000000), 0, reinterpret<f64>(0x3FCC6FFBC6F01000), reinterpret<f64>(0xBCF1EC72C5962BD2),\n  reinterpret<f64>(0x3FE9600000000000), 0, reinterpret<f64>(0x3FCDB13DB0D49000), reinterpret<f64>(0xBD2AFF2AF715B035),\n  reinterpret<f64>(0x3FE9400000000000), 0, reinterpret<f64>(0x3FCE530EFFE71000), reinterpret<f64>(0x3CC212276041F430),\n  reinterpret<f64>(0x3FE9200000000000), 0, reinterpret<f64>(0x3FCEF5ADE4DD0000), reinterpret<f64>(0xBCCA211565BB8E11),\n  reinterpret<f64>(0x3FE9000000000000), 0, reinterpret<f64>(0x3FCF991C6CB3B000), reinterpret<f64>(0x3D1BCBECCA0CDF30),\n  reinterpret<f64>(0x3FE8C00000000000), 0, reinterpret<f64>(0x3FD07138604D5800), reinterpret<f64>(0x3CF89CDB16ED4E91),\n  reinterpret<f64>(0x3FE8A00000000000), 0, reinterpret<f64>(0x3FD0C42D67616000), reinterpret<f64>(0x3D27188B163CEAE9),\n  reinterpret<f64>(0x3FE8800000000000), 0, reinterpret<f64>(0x3FD1178E8227E800), reinterpret<f64>(0xBD2C210E63A5F01C),\n  reinterpret<f64>(0x3FE8600000000000), 0, reinterpret<f64>(0x3FD16B5CCBACF800), reinterpret<f64>(0x3D2B9ACDF7A51681),\n  reinterpret<f64>(0x3FE8400000000000), 0, reinterpret<f64>(0x3FD1BF99635A6800), reinterpret<f64>(0x3D2CA6ED5147BDB7),\n  reinterpret<f64>(0x3FE8200000000000), 0, reinterpret<f64>(0x3FD214456D0EB800), reinterpret<f64>(0x3D0A87DEBA46BAEA),\n  reinterpret<f64>(0x3FE7E00000000000), 0, reinterpret<f64>(0x3FD2BEF07CDC9000), reinterpret<f64>(0x3D2A9CFA4A5004F4),\n  reinterpret<f64>(0x3FE7C00000000000), 0, reinterpret<f64>(0x3FD314F1E1D36000), reinterpret<f64>(0xBD28E27AD3213CB8),\n  reinterpret<f64>(0x3FE7A00000000000), 0, reinterpret<f64>(0x3FD36B6776BE1000), reinterpret<f64>(0x3D116ECDB0F177C8),\n  reinterpret<f64>(0x3FE7800000000000), 0, reinterpret<f64>(0x3FD3C25277333000), reinterpret<f64>(0x3D183B54B606BD5C),\n  reinterpret<f64>(0x3FE7600000000000), 0, reinterpret<f64>(0x3FD419B423D5E800), reinterpret<f64>(0x3D08E436EC90E09D),\n  reinterpret<f64>(0x3FE7400000000000), 0, reinterpret<f64>(0x3FD4718DC271C800), reinterpret<f64>(0xBD2F27CE0967D675),\n  reinterpret<f64>(0x3FE7200000000000), 0, reinterpret<f64>(0x3FD4C9E09E173000), reinterpret<f64>(0xBD2E20891B0AD8A4),\n  reinterpret<f64>(0x3FE7000000000000), 0, reinterpret<f64>(0x3FD522AE0738A000), reinterpret<f64>(0x3D2EBE708164C759),\n  reinterpret<f64>(0x3FE6E00000000000), 0, reinterpret<f64>(0x3FD57BF753C8D000), reinterpret<f64>(0x3D1FADEDEE5D40EF),\n  reinterpret<f64>(0x3FE6C00000000000), 0, reinterpret<f64>(0x3FD5D5BDDF596000), reinterpret<f64>(0xBD0A0B2A08A465DC)\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  var e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy var log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  var tmp = ix - 0x3fE6955500000000;\n  var i   = <usize>((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  var k   = <i64>tmp >> 52;\n  var iz  = ix - (tmp & u64(0xFFF) << 52);\n  var z   = reinterpret<f64>(iz);\n  var kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  var invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  var logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  var logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  var zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  var zlo = z - zhi;\n  var rhi = zhi * invc - 1.0;\n  var rlo = zlo * invc;\n  var r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  var t1  = kd * Ln2hi + logc;\n  var t2  = t1 + r;\n  var lo1 = kd * Ln2lo + logctail;\n  var lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  var ar  = A0 * r; // A[0] = -0.5\n  var ar2 = r * ar;\n  var ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  var arhi  = A0  * rhi;\n  var arhi2 = rhi * arhi;\n  var hi    = t2  + arhi2;\n  var lo3   = rlo * (ar + arhi);\n  var lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  var p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  var lo = lo1 + lo2 + lo3 + lo4 + p;\n  var y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  var abstop: u32;\n  var ki: u64, top: u64, sbits: u64;\n  var idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  var kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  var ux = reinterpret<u64>(x);\n  abstop = <u32>(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return ux >> 63 ? uflow(sign_bias) : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = <usize>((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  var sign_bias: u32 = 0;\n  var ix = reinterpret<u64>(x);\n  var iy = reinterpret<u64>(y);\n  var topx = ix >> 52;\n  var topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return iy >> 63 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (ix >> 63) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  var hi = log_inline(ix);\n  var lo = log_tail;\n  var ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  var yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  var ylo = y - yhi;\n  var lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  var llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import * as JSMath from \"./bindings/Math\";\nexport { JSMath };\n\nimport {\n  pow_lut, exp_lut, exp2_lut, log_lut, log2_lut,\n  powf_lut, expf_lut, exp2f_lut, logf_lut, log2f_lut\n} from \"./util/math\";\n\nimport {\n  abs as builtin_abs,\n  ceil as builtin_ceil,\n  clz as builtin_clz,\n  copysign as builtin_copysign,\n  floor as builtin_floor,\n  max as builtin_max,\n  min as builtin_min,\n  sqrt as builtin_sqrt,\n  trunc as builtin_trunc\n} from \"./builtins\";\n\n// SUN COPYRIGHT NOTICE\n//\n// Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.\n// Developed at SunPro, a Sun Microsystems, Inc. business.\n// Permission to use, copy, modify, and distribute this software\n// is freely granted, provided that this notice is preserved.\n//\n// Applies to all functions marked with a comment referring here.\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy var rempio2_y0: f64, rempio2_y1: f64, res128_hi: u64;\n\n/** @internal */\n// @ts-ignore: decorator\n@lazy @inline const PIO2_TABLE = memory.data<u64>([\n  0x00000000A2F9836E, 0x4E441529FC2757D1, 0xF534DDC0DB629599, 0x3C439041FE5163AB,\n  0xDEBBC561B7246E3A, 0x424DD2E006492EEA, 0x09D1921CFE1DEB1C, 0xB129A73EE88235F5,\n  0x2EBB4484E99C7026, 0xB45F7E413991D639, 0x835339F49C845F8B, 0xBDF9283B1FF897FF,\n  0xDE05980FEF2F118B, 0x5A0A6D1F6D367ECF, 0x27CB09B74F463F66, 0x9E5FEA2D7527BAC7,\n  0xEBE5F17B3D0739F7, 0x8A5292EA6BFB5FB1, 0x1F8D5D0856033046, 0xFC7B6BABF0CFBC20,\n  0x9AF4361DA9E39161, 0x5EE61B086599855F, 0x14A068408DFFD880, 0x4D73273106061557\n]);\n\n/** @internal */\nfunction R(z: f64): f64 { // Rational approximation of (asin(x)-x)/x^3\n  const                   // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f64>(0x3FC5555555555555), //  1.66666666666666657415e-01\n    pS1 = reinterpret<f64>(0xBFD4D61203EB6F7D), // -3.25565818622400915405e-01\n    pS2 = reinterpret<f64>(0x3FC9C1550E884455), //  2.01212532134862925881e-01\n    pS3 = reinterpret<f64>(0xBFA48228B5688F3B), // -4.00555345006794114027e-02\n    pS4 = reinterpret<f64>(0x3F49EFE07501B288), //  7.91534994289814532176e-04\n    pS5 = reinterpret<f64>(0x3F023DE10DFDF709), //  3.47933107596021167570e-05\n    qS1 = reinterpret<f64>(0xC0033A271C8A2D4B), // -2.40339491173441421878e+00\n    qS2 = reinterpret<f64>(0x40002AE59C598AC8), //  2.02094576023350569471e+00\n    qS3 = reinterpret<f64>(0xBFE6066C1B8D0159), // -6.88283971605453293030e-01\n    qS4 = reinterpret<f64>(0x3FB3B8C5B12E9282); //  7.70381505559019352791e-02\n\n  var p = z * (pS0 + z * (pS1 + z * (pS2 + z * (pS3 + z * (pS4 + z * pS5)))));\n  var q = 1.0 + z * (qS1 + z * (qS2 + z * (qS3 + z * qS4)));\n  return p / q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction expo2(x: f64, sign: f64): f64 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                       // see: musl/src/math/__expo2.c\n    k    = <u32>2043,\n    kln2 = reinterpret<f64>(0x40962066151ADD8B); // 0x1.62066151add8bp+10\n  var scale = reinterpret<f64>(<u64>((<u32>0x3FF + k / 2) << 20) << 32);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMath.exp(x - kln2) * (sign * scale) * scale;\n}\n\n/** @internal */\n/* Helper function to eventually get bits of /2 * |x|\n *\n * y = /4 * (frac << clz(frac) >> 11)\n * return clz(frac)\n *\n * Right shift 11 bits to make upper half fit in `double`\n */\n// @ts-ignore: decorator\n@inline\nfunction pio2_right(q0: u64, q1: u64): u64 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  // Bits of /4\n  const p0: u64 = 0xC4C6628B80DC1CD1;\n  const p1: u64 = 0xC90FDAA22168C234;\n\n  const Ox1p_64 = reinterpret<f64>(0x3BF0000000000000); // 0x1p-64\n  const Ox1p_75 = reinterpret<f64>(0x3B40000000000000); // 0x1p-75\n\n  var shift = clz(q1);\n\n  q1 = q1 << shift | q0 >> (64 - shift);\n  q0 <<= shift;\n\n  var lo = umuldi(p1, q1);\n  var hi = res128_hi;\n\n  var ahi = hi >> 11;\n  var alo = lo >> 11 | hi << 53;\n  var blo = <u64>(Ox1p_75 * <f64>p0 * <f64>q1 + Ox1p_75 * <f64>p1 * <f64>q0);\n\n  rempio2_y0 = <f64>(ahi + u64(lo < blo));\n  rempio2_y1 = Ox1p_64 * <f64>(alo + blo);\n\n  return shift;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction umuldi(u: u64, v: u64): u64 {\n  var u1: u64 , v1: u64, w0: u64, w1: u64, t: u64;\n\n  u1 = u & 0xFFFFFFFF;\n  v1 = v & 0xFFFFFFFF;\n\n  u >>= 32;\n  v >>= 32;\n\n  t  = u1 * v1;\n  w0 = t & 0xFFFFFFFF;\n  t  = u * v1 + (t >> 32);\n  w1 = t >> 32;\n  t  = u1 * v + (t & 0xFFFFFFFF);\n\n  res128_hi = u * v + w1 + (t >> 32);\n  return (t << 32) + w0;\n}\n\n/** @internal */\nfunction pio2_large_quot(x: f64, u: i64): i32 { // see: jdh8/metallic/blob/master/src/math/double/rem_pio2.c\n  var magnitude = u & 0x7FFFFFFFFFFFFFFF;\n  var offset = (magnitude >> 52) - 1045;\n  var shift  = offset & 63;\n  var tblPtr = PIO2_TABLE + (<i32>(offset >> 6) << 3);\n  var s0: u64, s1: u64, s2: u64;\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var b2 = load<u64>(tblPtr, 2 << 3);\n\n  // Get 192 bits of 0x1p-31 /  with `offset` bits skipped\n  if (shift) {\n    let rshift = 64 - shift;\n    let b3 = load<u64>(tblPtr, 3 << 3);\n    s0 = b1 >> rshift | b0 << shift;\n    s1 = b2 >> rshift | b1 << shift;\n    s2 = b3 >> rshift | b2 << shift;\n  } else {\n    s0 = b0;\n    s1 = b1;\n    s2 = b2;\n  }\n\n  var significand = (u & 0x000FFFFFFFFFFFFF) | 0x0010000000000000;\n\n  // First 128 bits of fractional part of x/(2)\n  var blo = umuldi(s1, significand);\n  var bhi = res128_hi;\n\n  var ahi = s0 * significand;\n  var clo = (s2 >> 32) * (significand >> 32);\n  var plo = blo + clo;\n  var phi = ahi + bhi + u64(plo < clo);\n\n  // r: u128 = p << 2\n  var rlo = plo << 2;\n  var rhi = phi << 2 | plo >> 62;\n\n  // s: i128 = r >> 127\n  var slo = <i64>rhi >> 63;\n  var shi = slo >> 1;\n  var q   = (<i64>phi >> 62) - slo;\n\n  var shifter = 0x3CB0000000000000 - (pio2_right(rlo ^ slo, rhi ^ shi) << 52);\n  var signbit = (u ^ rhi) & 0x8000000000000000;\n  var coeff   = reinterpret<f64>(shifter | signbit);\n\n  rempio2_y0 *= coeff;\n  rempio2_y1 *= coeff;\n\n  return <i32>q;\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction rempio2(x: f64, u: u64, sign: i32): i32 {\n  const\n    pio2_1  = reinterpret<f64>(0x3FF921FB54400000), // 1.57079632673412561417e+00\n    pio2_1t = reinterpret<f64>(0x3DD0B4611A626331), // 6.07710050650619224932e-11\n    pio2_2  = reinterpret<f64>(0x3DD0B4611A600000), // 6.07710050630396597660e-11\n    pio2_2t = reinterpret<f64>(0x3BA3198A2E037073), // 2.02226624879595063154e-21\n    pio2_3  = reinterpret<f64>(0x3BA3198A2E000000), // 2.02226624871116645580e-21\n    pio2_3t = reinterpret<f64>(0x397B839A252049C1), // 8.47842766036889956997e-32\n    invpio2 = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  var ix = <u32>(u >> 32) & 0x7FFFFFFF;\n\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (ix < 0x4002D97C) { // |x| < 3pi/4, special case with n=+-1\n      let q = 1, z: f64, y0: f64, y1: f64;\n      if (!sign) {\n        z = x - pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z - pio2_1t;\n          y1 = (z - y0) - pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z -= pio2_2;\n          y0 = z - pio2_2t;\n          y1 = (z - y0) - pio2_2t;\n        }\n      } else { // negative x\n        z = x + pio2_1;\n        if (ix != 0x3FF921FB) { // 33+53 bit pi is good enough\n          y0 = z + pio2_1t;\n          y1 = (z - y0) + pio2_1t;\n        } else { // near pi/2, use 33+33+53 bit pi\n          z += pio2_2;\n          y0 = z + pio2_2t;\n          y1 = (z - y0) + pio2_2t;\n        }\n        q = -1;\n      }\n      rempio2_y0 = y0;\n      rempio2_y1 = y1;\n      return q;\n    }\n  }\n\n  if (ix < 0x413921FB) { // |x| ~< 2^20*pi/2 (1647099)\n    // Use precise Cody Waite scheme\n    let q  = nearest(x * invpio2);\n    let r  = x - q * pio2_1;\n    let w  = q * pio2_1t; // 1st round good to 85 bit\n    let j  = ix >> 20;\n    let y0 = r - w;\n    let hi = <u32>(reinterpret<u64>(y0) >> 32);\n    let i  = j - ((hi >> 20) & 0x7FF);\n\n    if (i > 16) { // 2nd iteration needed, good to 118\n      let t = r;\n      w  = q * pio2_2;\n      r  = t - w;\n      w  = q * pio2_2t - ((t - r) - w);\n      y0 = r - w;\n      hi = <u32>(reinterpret<u64>(y0) >> 32);\n      i = j - ((hi >> 20) & 0x7FF);\n      if (i > 49) { // 3rd iteration need, 151 bits acc\n        let t = r;\n        w  = q * pio2_3;\n        r  = t - w;\n        w  = q * pio2_3t - ((t - r) - w);\n        y0 = r - w;\n      }\n    }\n    let y1 = (r - y0) - w;\n    rempio2_y0 = y0;\n    rempio2_y1 = y1;\n    return <i32>q;\n  }\n  var q = pio2_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction sin_kern(x: f64, y: f64, iy: i32): f64 { // see: musl/tree/src/math/__sin.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555555555549), // -1.66666666666666324348e-01\n    S2 = reinterpret<f64>(0x3F8111111110F8A6), //  8.33333333332248946124e-03\n    S3 = reinterpret<f64>(0xBF2A01A019C161D5), // -1.98412698298579493134e-04\n    S4 = reinterpret<f64>(0x3EC71DE357B1FE7D), //  2.75573137070700676789e-06\n    S5 = reinterpret<f64>(0xBE5AE5E68A2B9CEB), // -2.50507602534068634195e-08\n    S6 = reinterpret<f64>(0x3DE5D93A5ACFD57C); //  1.58969099521155010221e-10\n\n  var z = x * x;\n  var w = z * z;\n  var r = S2 + z * (S3 + z * S4) + z * w * (S5 + z * S6);\n  var v = z * x;\n  if (!iy) {\n    return x + v * (S1 + z * r);\n  } else {\n    return x - ((z * (0.5 * y - v * r) - y) - v * S1);\n  }\n}\n\n/** @internal */\n// @ts-ignore: decorator\n@inline\nfunction cos_kern(x: f64, y: f64): f64 { // see: musl/tree/src/math/__cos.c\n  const\n    C1 = reinterpret<f64>(0x3FA555555555554C), //  4.16666666666666019037e-02\n    C2 = reinterpret<f64>(0xBF56C16C16C15177), // -1.38888888888741095749e-03\n    C3 = reinterpret<f64>(0x3EFA01A019CB1590), //  2.48015872894767294178e-05\n    C4 = reinterpret<f64>(0xBE927E4F809C52AD), // -2.75573143513906633035e-07\n    C5 = reinterpret<f64>(0x3E21EE9EBDB4B1C4), //  2.08757232129817482790e-09\n    C6 = reinterpret<f64>(0xBDA8FAE9BE8838D4); // -1.13596475577881948265e-11\n\n  var z = x * x;\n  var w = z * z;\n  var r = z * (C1 + z * (C2 + z * C3)) + w * w * (C4 + z * (C5 + z * C6));\n  var hz = 0.5 * z;\n  w = 1.0 - hz;\n  return w + (((1.0 - w) - hz) + (z * r - x * y));\n}\n\n/** @internal */\nfunction tan_kern(x: f64, y: f64, iy: i32): f64 { // see: src/lib/msun/src/k_tan.c\n  const\n    T0  = reinterpret<f64>(0x3FD5555555555563), //  3.33333333333334091986e-01\n    T1  = reinterpret<f64>(0x3FC111111110FE7A), //  1.33333333333201242699e-01\n    T2  = reinterpret<f64>(0x3FABA1BA1BB341FE), //  5.39682539762260521377e-02\n    T3  = reinterpret<f64>(0x3F9664F48406D637), //  2.18694882948595424599e-02\n    T4  = reinterpret<f64>(0x3F8226E3E96E8493), //  8.86323982359930005737e-03\n    T5  = reinterpret<f64>(0x3F6D6D22C9560328), //  3.59207910759131235356e-03\n    T6  = reinterpret<f64>(0x3F57DBC8FEE08315), //  1.45620945432529025516e-03\n    T7  = reinterpret<f64>(0x3F4344D8F2F26501), //  5.88041240820264096874e-04\n    T8  = reinterpret<f64>(0x3F3026F71A8D1068), //  2.46463134818469906812e-04\n    T9  = reinterpret<f64>(0x3F147E88A03792A6), //  7.81794442939557092300e-05\n    T10 = reinterpret<f64>(0x3F12B80F32F0A7E9), //  7.14072491382608190305e-05\n    T11 = reinterpret<f64>(0xBEF375CBDB605373), // -1.85586374855275456654e-05\n    T12 = reinterpret<f64>(0x3EFB2A7074BF7AD4); //  2.59073051863633712884e-05\n\n  const\n    one    = reinterpret<f64>(0x3FF0000000000000), // 1.00000000000000000000e+00\n    pio4   = reinterpret<f64>(0x3FE921FB54442D18), // 7.85398163397448278999e-01\n    pio4lo = reinterpret<f64>(0x3C81A62633145C07); // 3.06161699786838301793e-17\n\n  var z: f64, r: f64, v: f64, w: f64, s: f64;\n  var hx = <i32>(reinterpret<u64>(x) >> 32); // high word of x\n  var ix = hx & 0x7FFFFFFF; // high word of |x|\n  var big = ix >= 0x3FE59428;\n  if (big) { // |x| >= 0.6744\n    if (hx < 0) { x = -x, y = -y; }\n    z = pio4 - x;\n    w = pio4lo - y;\n    x = z + w;\n    y = 0.0;\n  }\n  z = x * x;\n  w = z * z;\n  r = T1 + w * (T3 + w * (T5 + w * (T7 + w * (T9 + w * T11))));\n  v = z * (T2 + w * (T4 + w * (T6 + w * (T8 + w * (T10 + w * T12)))));\n  s = z * x;\n  r = y + z * (s * (r + v) + y);\n  r += T0 * s;\n  w = x + r;\n  if (big) {\n    v = iy;\n    return (1 - ((hx >> 30) & 2)) * (v - 2.0 * (x - (w * w / (w + v) - r)));\n  }\n  if (iy == 1) return w;\n  var a: f64, t: f64;\n  z = w;\n  z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF00000000);\n  v = r - (z - x);  // z + v = r + x\n  t = a = -one / w; // a = -1.0 / w\n  t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n  s = one + t * z;\n  return t + a * (s + t * v);\n}\n\n/** @internal */\nfunction dtoi32(x: f64): i32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    const inv32 = 1.0 / 4294967296;\n    return <i32><i64>(x - 4294967296 * floor(x * inv32));\n  } else {\n    let result = 0;\n    let u = reinterpret<u64>(x);\n    let e = (u >> 52) & 0x7FF;\n    if (e <= 1023 + 30) {\n      result = <i32>x;\n    } else if (e <= 1023 + 30 + 53) {\n      let v = (u & ((<u64>1 << 52) - 1)) | (<u64>1 << 52);\n      v = v << e - 1023 - 52 + 32;\n      result = <i32>(v >> 32);\n      result = select<i32>(-result, result, u >> 63);\n    }\n    return result;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var random_seeded = false;\n\n// @ts-ignore: decorator\n@lazy var random_state0_64: u64, random_state1_64: u64;\n\n// @ts-ignore: decorator\n@lazy var random_state0_32: u32, random_state1_32: u32;\n\nfunction murmurHash3(h: u64): u64 { // Force all bits of a hash block to avalanche\n  h ^= h >> 33;                     // see: https://github.com/aappleby/smhasher\n  h *= 0xFF51AFD7ED558CCD;\n  h ^= h >> 33;\n  h *= 0xC4CEB9FE1A85EC53;\n  h ^= h >> 33;\n  return h;\n}\n\nfunction splitMix32(h: u32): u32 {\n  h += 0x6D2B79F5;\n  h  = (h ^ (h >> 15)) * (h | 1);\n  h ^= h + (h ^ (h >> 7)) * (h | 61);\n  return h ^ (h >> 14);\n}\n\nexport namespace NativeMath {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = reinterpret<f64>(0x4005BF0A8B145769); // 2.7182818284590452354\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.69314718055994530942\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = reinterpret<f64>(0x40026BB1BBB55516); // 2.30258509299404568402\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = reinterpret<f64>(0x3FF71547652B82FE); // 1.4426950408889634074\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = reinterpret<f64>(0x3FDBCB7B1526E50E); // 0.43429448190325182765\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = reinterpret<f64>(0x400921FB54442D18); // 3.14159265358979323846\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = reinterpret<f64>(0x3FE6A09E667F3BCD); // 0.70710678118654752440\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = reinterpret<f64>(0x3FF6A09E667F3BCD); // 1.41421356237309504880\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f64 = 0;\n\n  // @ts-ignore: decorator\n  @inline export function abs(x: f64): f64 {\n    return builtin_abs<f64>(x);\n  }\n\n  export function acos(x: f64): f64 { // see: musl/src/math/acos.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix <= 0x3C600000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * R(x * x)));\n    }\n    var s: f64, w: f64, z: f64;\n    if (hx >> 31) {\n      // z = (1.0 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f64>(z);\n      w = R(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1.0 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f64>(z);\n    var df = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n    var c = (z - df * df) / (s + df);\n    w = R(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f64): f64 { // see: musl/src/math/acosh.c\n    const s = reinterpret<f64>(0x3FE62E42FEFA39EF);\n    var e = reinterpret<u64>(x) >> 52 & 0x7FF;\n    if (e < 0x3FF + 1) return log1p(x - 1 + builtin_sqrt<f64>((x - 1) * (x - 1) + 2 * (x - 1)));\n    if (e < 0x3FF + 26) return log(2 * x - 1 / (x + builtin_sqrt<f64>(x * x - 1)));\n    return log(x) + s;\n  }\n\n  export function asin(x: f64): f64 { // see: musl/src/math/asin.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f64>(0x3FF921FB54442D18), // 1.57079632679489655800e+00\n      pio2_lo   = reinterpret<f64>(0x3C91A62633145C07), // 6.12323399573676603587e-17\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    var hx = <u32>(reinterpret<u64>(x) >> 32);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3FF00000) {\n      let lx = <u32>reinterpret<u64>(x);\n      if ((ix - 0x3FF00000 | lx) == 0) return x * pio2_hi + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (ix < 0x3FE00000) {\n      if (ix < 0x3E500000 && ix >= 0x00100000) return x;\n      return x + x * R(x * x);\n    }\n    // var z = (1.0 - builtin_abs<f64>(x)) * 0.5;\n    var z = 0.5 - builtin_abs<f64>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z);\n    var r = R(z);\n    if (ix >= 0x3FEF3333) x = pio2_hi - (2 * (s + s * r) - pio2_lo);\n    else {\n      let f = reinterpret<f64>(reinterpret<u64>(s) & 0xFFFFFFFF00000000);\n      let c = (z - f * f) / (s + f);\n      x = 0.5 * pio2_hi - (2 * s * r - (pio2_lo - 2 * c) - (0.5 * pio2_hi - 2 * f));\n    }\n    if (hx >> 31) return -x;\n    return x;\n  }\n\n  export function asinh(x: f64): f64 { // see: musl/src/math/asinh.c\n    const c = reinterpret<f64>(0x3FE62E42FEFA39EF); // 0.693147180559945309417232121458176568\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = reinterpret<f64>(u & 0x7FFFFFFFFFFFFFFF);\n    if (e >= 0x3FF + 26) y = log(y) + c;\n    else if (e >= 0x3FF + 1)  y =   log(2 * y + 1 / (builtin_sqrt<f64>(y * y + 1) + y));\n    else if (e >= 0x3FF - 26) y = log1p(y + y * y / (builtin_sqrt<f64>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f64): f64 { // see musl/src/math/atan.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f64>(0x3FDDAC670561BB4F), //  4.63647609000806093515e-01\n      atanhi1   = reinterpret<f64>(0x3FE921FB54442D18), //  7.85398163397448278999e-01\n      atanhi2   = reinterpret<f64>(0x3FEF730BD281F69B), //  9.82793723247329054082e-01\n      atanhi3   = reinterpret<f64>(0x3FF921FB54442D18), //  1.57079632679489655800e+00\n      atanlo0   = reinterpret<f64>(0x3C7A2B7F222F65E2), //  2.26987774529616870924e-17\n      atanlo1   = reinterpret<f64>(0x3C81A62633145C07), //  3.06161699786838301793e-17\n      atanlo2   = reinterpret<f64>(0x3C7007887AF0CBBD), //  1.39033110312309984516e-17\n      atanlo3   = reinterpret<f64>(0x3C91A62633145C07), //  6.12323399573676603587e-17\n      aT0       = reinterpret<f64>(0x3FD555555555550D), //  3.33333333333329318027e-01\n      aT1       = reinterpret<f64>(0xBFC999999998EBC4), // -1.99999999998764832476e-01\n      aT2       = reinterpret<f64>(0x3FC24924920083FF), //  1.42857142725034663711e-01\n      aT3       = reinterpret<f64>(0xBFBC71C6FE231671), // -1.11111104054623557880e-01,\n      aT4       = reinterpret<f64>(0x3FB745CDC54C206E), //  9.09088713343650656196e-02\n      aT5       = reinterpret<f64>(0xBFB3B0F2AF749A6D), // -7.69187620504482999495e-02\n      aT6       = reinterpret<f64>(0x3FB10D66A0D03D51), //  6.66107313738753120669e-02\n      aT7       = reinterpret<f64>(0xBFADDE2D52DEFD9A), // -5.83357013379057348645e-02\n      aT8       = reinterpret<f64>(0x3FA97B4B24760DEB), //  4.97687799461593236017e-02\n      aT9       = reinterpret<f64>(0xBFA2B4442C6A6C2F), // -3.65315727442169155270e-02\n      aT10      = reinterpret<f64>(0x3F90AD3AE322DA11), //  1.62858201153657823623e-02\n      Ox1p_120f = reinterpret<f32>(0x03800000);\n\n    var ix = <u32>(reinterpret<u64>(x) >> 32);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f64;\n    if (ix >= 0x44100000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign<f64>(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3FDC0000) {\n      if (ix < 0x3E400000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f64>(x);\n      if (ix < 0x3FF30000) {\n        if (ix < 0x3FE60000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x40038000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * (aT4 + w * (aT6 + w * (aT8 + w * aT10)))));\n    var s2 = w * (aT1 + w * (aT3 + w * (aT5 + w * (aT7 + w * aT9))));\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign<f64>(z, sx);\n  }\n\n  export function atanh(x: f64): f64 { // see: musl/src/math/atanh.c\n    var u = reinterpret<u64>(x);\n    var e = u >> 52 & 0x7FF;\n    var y = builtin_abs(x);\n    if (e < 0x3FF - 1) {\n      if (e >= 0x3FF - 32) y = 0.5 * log1p(2 * y + 2 * y * y / (1 - y));\n    } else {\n      y = 0.5 * log1p(2 * (y / (1 - y)));\n    }\n    return builtin_copysign<f64>(y, x);\n  }\n\n  export function atan2(y: f64, x: f64): f64 { // see: musl/src/math/atan2.c and SUN COPYRIGHT NOTICE above\n    const pi_lo = reinterpret<f64>(0x3CA1A62633145C07); // 1.2246467991473531772E-16\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var lx = <u32>u;\n    u = reinterpret<u64>(y);\n    var iy = <u32>(u >> 32);\n    var ly = <u32>u;\n    if ((ix - 0x3FF00000 | lx) == 0) return atan(y);\n    var m = ((iy >> 31) & 1) | ((ix >> 30) & 2);\n    ix = ix & 0x7FFFFFFF;\n    iy = iy & 0x7FFFFFFF;\n    if ((iy | ly) == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  PI;\n        case 3: return -PI;\n      }\n    }\n    if ((ix | lx) == 0) return m & 1 ? -PI / 2 : PI / 2;\n    if (ix == 0x7FF00000) {\n      if (iy == 0x7FF00000) {\n        let t = m & 2 ? 3 * PI / 4 : PI / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t = m & 2 ? PI : 0;\n        return m & 1 ? -t : t;\n      }\n    }\n    var z: f64;\n    if (ix + (64 << 20) < iy || iy == 0x7FF00000) return m & 1 ? -PI / 2 : PI / 2;\n    if ((m & 2) && iy + (64 << 20) < ix) z = 0;\n    else z = atan(builtin_abs<f64>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return PI - (z - pi_lo);\n      case 3: return (z - pi_lo) - PI;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f64): f64 { // see: musl/src/math/cbrt.c and SUN COPYRIGHT NOTICE above\n    const\n      B1     = <u32>715094163,\n      B2     = <u32>696219795,\n      P0     = reinterpret<f64>(0x3FFE03E60F61E692), //  1.87595182427177009643\n      P1     = reinterpret<f64>(0xBFFE28E092F02420), // -1.88497979543377169875\n      P2     = reinterpret<f64>(0x3FF9F1604A49D6C2), //  1.621429720105354466140\n      P3     = reinterpret<f64>(0xBFE844CBBEE751D9), // -0.758397934778766047437\n      P4     = reinterpret<f64>(0x3FC2B000D4E4EDD7), //  0.145996192886612446982\n      Ox1p54 = reinterpret<f64>(0x4350000000000000); //  0x1p54\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32) & 0x7FFFFFFF;\n    if (hx >= 0x7FF00000) return x + x;\n    if (hx < 0x00100000) {\n      u = reinterpret<u64>(x * Ox1p54);\n      hx = <u32>(u >> 32) & 0x7FFFFFFF;\n      if (hx == 0) return x;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 1 << 63;\n    u |= <u64>hx << 32;\n    var t = reinterpret<f64>(u);\n    var r = (t * t) * (t / x);\n    t = t * ((P0 + r * (P1 + r * P2)) + ((r * r) * r) * (P3 + r * P4));\n    t = reinterpret<f64>((reinterpret<u64>(t) + 0x80000000) & 0xFFFFFFFFC0000000);\n    var s = t * t;\n    r = x / s;\n    r = (r - t) / (2 * t + r);\n    t = t + t * r;\n    return t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f64): f64 {\n    return builtin_ceil<f64>(x);\n  }\n\n  export function clz32(x: f64): f64 {\n    if (!isFinite(x)) return 32;\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    return builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f64): f64 { // see: musl/src/math/cos.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E46A09E) {  // |x| < 2**-27 * sqrt(2)\n        return 1.0;\n      }\n      return cos_kern(x, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? sin_kern(y0, y1, 1) : cos_kern(y0, y1);\n    return (n + 1) & 2 ? -x : x;\n  }\n\n  export function cosh(x: f64): f64 { // see: musl/src/math/cosh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    x = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w < 0x3FE62E42) {\n      if (w < 0x3FF00000 - (26 << 20)) return 1;\n      t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (w < 0x40862E42) {\n      t = exp(x);\n      return 0.5 * (t + 1 / t);\n    }\n    t = expo2(x, 1);\n    return t;\n  }\n\n  export function exp(x: f64): f64 { // see: musl/src/math/exp.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return exp_lut(x);\n    } else {\n      const\n        ln2hi     = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n        ln2lo     = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n        invln2    = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        P1        = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2        = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3        = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4        = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5        = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        overflow  = reinterpret<f64>(0x40862E42FEFA39EF), //  709.782712893383973096\n        underflow = reinterpret<f64>(0xC0874910D52D3051), // -745.13321910194110842\n        Ox1p1023  = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n      let hx = <u32>(reinterpret<u64>(x) >> 32);\n      let sign_ = <i32>(hx >> 31);\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x4086232B) {\n        if (isNaN(x)) return x;\n        if (x > overflow)  return x * Ox1p1023;\n        if (x < underflow) return 0;\n      }\n      let hi: f64, lo: f64 = 0;\n      let k = 0;\n      if (hx > 0x3FD62E42) {\n        if (hx >= 0x3FF0A2B2) {\n          k = <i32>(invln2 * x + builtin_copysign<f64>(0.5, x));\n        } else {\n          k = 1 - (sign_ << 1);\n        }\n        hi = x - k * ln2hi;\n        lo = k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x3E300000) {\n        hi = x;\n      } else return 1.0 + x;\n      let xs = x * x;\n      // var c = x - xp2 * (P1 + xp2 * (P2 + xp2 * (P3 + xp2 * (P4 + xp2 * P5))));\n      let xq = xs * xs;\n      let c = x - (xs * P1 + xq * ((P2 + xs * P3) + xq * (P4 + xs * P5)));\n      let y = 1.0 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f64): f64 {\n    return exp2_lut(x);\n  }\n\n  export function expm1(x: f64): f64 { // see: musl/src/math/expm1.c and SUN COPYRIGHT NOTICE above\n    const\n      o_threshold = reinterpret<f64>(0x40862E42FEFA39EF), //  7.09782712893383973096e+02\n      ln2_hi      = reinterpret<f64>(0x3FE62E42FEE00000), //  6.93147180369123816490e-01\n      ln2_lo      = reinterpret<f64>(0x3DEA39EF35793C76), //  1.90821492927058770002e-10\n      invln2      = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n      Q1          = reinterpret<f64>(0xBFA11111111110F4), // -3.33333333333331316428e-02\n      Q2          = reinterpret<f64>(0x3F5A01A019FE5585), //  1.58730158725481460165e-03\n      Q3          = reinterpret<f64>(0xBF14CE199EAADBB7), // -7.93650757867487942473e-05\n      Q4          = reinterpret<f64>(0x3ED0CFCA86E65239), //  4.00821782732936239552e-06\n      Q5          = reinterpret<f64>(0xBE8AFDB76E09C32D), // -2.01099218183624371326e-07\n      Ox1p1023    = reinterpret<f64>(0x7FE0000000000000); //  0x1p1023\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32 & 0x7FFFFFFF);\n    var k = 0, sign_ = <i32>(u >> 63);\n    if (hx >= 0x4043687A) {\n      if (isNaN(x)) return x;\n      if (sign_) return -1;\n      if (x > o_threshold) return x * Ox1p1023;\n    }\n    var c = 0.0, t: f64;\n    if (hx > 0x3FD62E42) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f64>(0.5, x)),\n        hx < 0x3FF0A2B2\n      );\n      t = <f64>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x3C900000) return x;\n    var hfx = 0.5 * x;\n    var hxs = x * hfx;\n    // var r1 = 1.0 + hxs * (Q1 + hxs * (Q2 + hxs * (Q3 + hxs * (Q4 + hxs * Q5))));\n    var hxq = hxs * hxs;\n    var r1 = (1.0 + hxs * Q1) + hxq * ((Q2 + hxs * Q3) + hxq * (Q4 + hxs * Q5));\n    t = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x3FF + k) << 52;\n    var twopk = reinterpret<f64>(u);\n    var y: f64;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 1024) y = y * 2.0 * Ox1p1023;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x3FF - k) << 52;\n    y = reinterpret<f64>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f64): f64 {\n    return builtin_floor<f64>(x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f64): f64 {\n    return <f32>x;\n  }\n\n  export function hypot(x: f64, y: f64): f64 { // see: musl/src/math/hypot.c\n    const\n      SPLIT    = reinterpret<f64>(0x41A0000000000000) + 1, // 0x1p27 + 1\n      Ox1p700  = reinterpret<f64>(0x6BB0000000000000),\n      Ox1p_700 = reinterpret<f64>(0x1430000000000000);\n\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    ux &= 0x7FFFFFFFFFFFFFFF;\n    uy &= 0x7FFFFFFFFFFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    var ex = <i32>(ux >> 52);\n    var ey = <i32>(uy >> 52);\n    y = reinterpret<f64>(uy);\n    if (ey == 0x7FF) return y;\n    x = reinterpret<f64>(ux);\n    if (ex == 0x7FF || uy == 0) return x;\n    if (ex - ey > 64) return x + y;\n    var z = 1.0;\n    if (ex > 0x3FF + 510) {\n      z  = Ox1p700;\n      x *= Ox1p_700;\n      y *= Ox1p_700;\n    } else if (ey < 0x3FF - 450) {\n      z  = Ox1p_700;\n      x *= Ox1p700;\n      y *= Ox1p700;\n    }\n    var c = x * SPLIT;\n    var h = x - c + c;\n    var l = x - h;\n    var hx = x * x;\n    var lx = h * h - hx + (2 * h + l) * l;\n    c = y * SPLIT;\n    h = y - c + c;\n    l = y - h;\n    var hy = y * y;\n    var ly = h * h - hy + (2 * h + l) * l;\n    return z * builtin_sqrt(ly + lx + hy + hx);\n  }\n\n  export function imul(x: f64, y: f64): f64 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return dtoi32(x) * dtoi32(y);\n  }\n\n  export function log(x: f64): f64 { // see: musl/src/math/log.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log_lut(x);\n    } else {\n      const\n        ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n        ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n        Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54 = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = <u32>(u >> 32);\n      let k = 0;\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (hx >> 31)    return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = <u32>(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += (<i32>hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let dk = <f64>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f64): f64 { // see: musl/src/math/log10.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f64>(0x3FDBCB7B15200000), // 4.34294481878168880939e-01\n      ivln10lo  = reinterpret<f64>(0x3DBB9438CA9AADD5), // 2.50829467116452752298e-11\n      log10_2hi = reinterpret<f64>(0x3FD34413509F6000), // 3.01029995663611771306e-01\n      log10_2lo = reinterpret<f64>(0x3D59FEF311F12B36), // 3.69423907715893078616e-13\n      Lg1       = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2       = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3       = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4       = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5       = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6       = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7       = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n      Ox1p54    = reinterpret<f64>(0x4350000000000000); // 0x1p54\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 0;\n    if (hx < 0x00100000 || <bool>(hx >> 31)) {\n      if (u << 1 == 0) return -1 / (x * x);\n      if (hx >> 31) return (x - x) / 0.0;\n      k -= 54;\n      x *= Ox1p54;\n      u = reinterpret<u64>(x);\n      hx = <u32>(u >> 32);\n    } else if (hx >= 0x7FF00000) {\n      return x;\n    } else if (hx == 0x3FF00000 && u << 32 == 0) {\n      return 0;\n    }\n    hx += 0x3FF00000 - 0x3FE6A09E;\n    k += <i32>(hx >> 20) - 0x3FF;\n    hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n    u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n    x = reinterpret<f64>(u);\n    var f = x - 1.0;\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var hi = f - hfsq;\n    u = reinterpret<u64>(hi);\n    u &= 0xFFFFFFFF00000000;\n    hi = reinterpret<f64>(u);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var val_hi = hi * ivln10hi;\n    var dk = <f64>k;\n    var y = dk * log10_2hi;\n    var val_lo = dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi;\n    w = y + val_hi;\n    val_lo += (y - w) + val_hi;\n    return val_lo + w;\n  }\n\n  export function log1p(x: f64): f64 { // see: musl/src/math/log1p.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f64>(0x3FE62E42FEE00000), // 6.93147180369123816490e-01\n      ln2_lo = reinterpret<f64>(0x3DEA39EF35793C76), // 1.90821492927058770002e-10\n      Lg1    = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n      Lg2    = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n      Lg3    = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n      Lg4    = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n      Lg5    = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n      Lg6    = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n      Lg7    = reinterpret<f64>(0x3FC2F112DF3E5244); // 1.479819860511658591e-01\n\n    var u = reinterpret<u64>(x);\n    var hx = <u32>(u >> 32);\n    var k = 1;\n    var c = 0.0, f = 0.0;\n    if (hx < 0x3FDA827A || <bool>(hx >> 31)) {\n      if (hx >= 0xBFF00000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (hx << 1 < 0x3CA00000 << 1) return x;\n      if (hx <= 0xBFD2BEC4) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (hx >= 0x7FF00000) return x;\n    if (k) {\n      u = reinterpret<u64>(1 + x);\n      let hu = <u32>(u >> 32);\n      hu += 0x3FF00000 - 0x3FE6A09E;\n      k = <i32>(hu >> 20) - 0x3FF;\n      if (k < 54) {\n        let uf = reinterpret<f64>(u);\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      hu = (hu & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hu << 32 | (u & 0xFFFFFFFF);\n      f = reinterpret<f64>(u) - 1;\n    }\n    var hfsq = 0.5 * f * f;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n    var t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n    var r = t2 + t1;\n    var dk = <f64>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f64): f64 { // see: musl/src/math/log2.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f64>(0x3FF7154765200000), // 1.44269504072144627571e+00\n        ivln2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 1.67517131648865118353e-10\n        Lg1     = reinterpret<f64>(0x3FE5555555555593), // 6.666666666666735130e-01\n        Lg2     = reinterpret<f64>(0x3FD999999997FA04), // 3.999999999940941908e-01\n        Lg3     = reinterpret<f64>(0x3FD2492494229359), // 2.857142874366239149e-01\n        Lg4     = reinterpret<f64>(0x3FCC71C51D8E78AF), // 2.222219843214978396e-01\n        Lg5     = reinterpret<f64>(0x3FC7466496CB03DE), // 1.818357216161805012e-01\n        Lg6     = reinterpret<f64>(0x3FC39A09D078C69F), // 1.531383769920937332e-01\n        Lg7     = reinterpret<f64>(0x3FC2F112DF3E5244), // 1.479819860511658591e-01\n        Ox1p54  = reinterpret<f64>(0x4350000000000000); // 1p54\n\n      let u = reinterpret<u64>(x);\n      let hx = <u32>(u >> 32);\n      let k = 0;\n      if (hx < 0x00100000 || <bool>(hx >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (hx >> 31) return (x - x) / 0.0;\n        k -= 54;\n        x *= Ox1p54;\n        u = reinterpret<u64>(x);\n        hx = <u32>(u >> 32);\n      } else if (hx >= 0x7FF00000) {\n        return x;\n      } else if (hx == 0x3FF00000 && u << 32 == 0) {\n        return 0;\n      }\n      hx += 0x3FF00000 - 0x3FE6A09E;\n      k += <i32>(hx >> 20) - 0x3FF;\n      hx = (hx & 0x000FFFFF) + 0x3FE6A09E;\n      u = <u64>hx << 32 | (u & 0xFFFFFFFF);\n      x = reinterpret<f64>(u);\n      let f = x - 1.0;\n      let hfsq = 0.5 * f * f;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * (Lg4 + w * Lg6));\n      let t2 = z * (Lg1 + w * (Lg3 + w * (Lg5 + w * Lg7)));\n      let r = t2 + t1;\n      let hi = f - hfsq;\n      u = reinterpret<u64>(hi);\n      u &= 0xFFFFFFFF00000000;\n      hi = reinterpret<f64>(u);\n      let lo = f - hi - hfsq + s * (hfsq + r);\n      let val_hi = hi * ivln2hi;\n      let val_lo = (lo + hi) * ivln2lo + lo * ivln2hi;\n      let y = <f64>k;\n      w = y + val_hi;\n      val_lo += (y - w) + val_hi;\n      val_hi = w;\n      return val_lo + val_hi;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f64, value2: f64): f64 {\n    return builtin_max<f64>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f64, value2: f64): f64 {\n    return builtin_min<f64>(value1, value2);\n  }\n\n  export function pow(x: f64, y: f64): f64 { // see: musl/src/math/pow.c and SUN COPYRIGHT NOTICE above\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f64>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f64>(\n          builtin_abs<f64>(builtin_sqrt<f64>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      return pow_lut(x, y);\n    } else {\n      const\n        dp_h1   = reinterpret<f64>(0x3FE2B80340000000), //  5.84962487220764160156e-01\n        dp_l1   = reinterpret<f64>(0x3E4CFDEB43CFD006), //  1.35003920212974897128e-08\n        two53   = reinterpret<f64>(0x4340000000000000), //  9007199254740992.0\n        huge    = reinterpret<f64>(0x7E37E43C8800759C), //  1e+300\n        tiny    = reinterpret<f64>(0x01A56E1FC2F8F359), //  1e-300\n        L1      = reinterpret<f64>(0x3FE3333333333303), //  5.99999999999994648725e-01\n        L2      = reinterpret<f64>(0x3FDB6DB6DB6FABFF), //  4.28571428578550184252e-01\n        L3      = reinterpret<f64>(0x3FD55555518F264D), //  3.33333329818377432918e-01\n        L4      = reinterpret<f64>(0x3FD17460A91D4101), //  2.72728123808534006489e-01\n        L5      = reinterpret<f64>(0x3FCD864A93C9DB65), //  2.30660745775561754067e-01\n        L6      = reinterpret<f64>(0x3FCA7E284A454EEF), //  2.06975017800338417784e-01\n        P1      = reinterpret<f64>(0x3FC555555555553E), //  1.66666666666666019037e-01\n        P2      = reinterpret<f64>(0xBF66C16C16BEBD93), // -2.77777777770155933842e-03\n        P3      = reinterpret<f64>(0x3F11566AAF25DE2C), //  6.61375632143793436117e-05\n        P4      = reinterpret<f64>(0xBEBBBD41C5D26BF1), // -1.65339022054652515390e-06\n        P5      = reinterpret<f64>(0x3E66376972BEA4D0), //  4.13813679705723846039e-08\n        lg2     = reinterpret<f64>(0x3FE62E42FEFA39EF), //  6.93147180559945286227e-01\n        lg2_h   = reinterpret<f64>(0x3FE62E4300000000), //  6.93147182464599609375e-01\n        lg2_l   = reinterpret<f64>(0xBE205C610CA86C39), // -1.90465429995776804525e-09\n        ovt     = reinterpret<f64>(0x3C971547652B82FE), //  8.0085662595372944372e-017\n        cp      = reinterpret<f64>(0x3FEEC709DC3A03FD), //  9.61796693925975554329e-01\n        cp_h    = reinterpret<f64>(0x3FEEC709E0000000), //  9.61796700954437255859e-01\n        cp_l    = reinterpret<f64>(0xBE3E2FE0145B01F5), // -7.02846165095275826516e-09\n        ivln2   = reinterpret<f64>(0x3FF71547652B82FE), //  1.44269504088896338700e+00\n        ivln2_h = reinterpret<f64>(0x3FF7154760000000), //  1.44269502162933349609e+00\n        ivln2_l = reinterpret<f64>(0x3E54AE0BF85DDF44), //  1.92596299112661746887e-08\n        inv3    = reinterpret<f64>(0x3FD5555555555555); //  0.3333333333333333333333\n\n      let u_ = reinterpret<u64>(x);\n      let hx = <i32>(u_ >> 32);\n      let lx = <u32>u_;\n      u_ = reinterpret<u64>(y);\n      let hy = <i32>(u_ >> 32);\n      let ly = <u32>u_;\n      let ix = hx & 0x7FFFFFFF;\n      let iy = hy & 0x7FFFFFFF;\n      if ((iy | ly) == 0) return 1.0; // x**0 = 1, even if x is NaN\n      // if (hx == 0x3FF00000 && lx == 0) return 1.0; // C: 1**y = 1, even if y is NaN, JS: NaN\n      if ( // NaN if either arg is NaN\n        ix > 0x7FF00000 || (ix == 0x7FF00000 && lx != 0) ||\n        iy > 0x7FF00000 || (iy == 0x7FF00000 && ly != 0)\n      ) return x + y;\n      let yisint = 0, k: i32;\n      if (hx < 0) {\n        if (iy >= 0x43400000) yisint = 2;\n        else if (iy >= 0x3FF00000) {\n          k = (iy >> 20) - 0x3FF;\n          let offset = select<u32>(52, 20, k > 20) - k;\n          let Ly = select<u32>(ly, iy, k > 20);\n          let jj = Ly >> offset;\n          if ((jj << offset) == Ly) yisint = 2 - (jj & 1);\n        }\n      }\n      if (ly == 0) {\n        if (iy == 0x7FF00000) { // y is +-inf\n          if (((ix - 0x3FF00000) | lx) == 0) return NaN; // C: (-1)**+-inf is 1, JS: NaN\n          else if (ix >= 0x3FF00000) return hy >= 0 ? y : 0.0; // (|x|>1)**+-inf = inf,0\n          else return hy >= 0 ? 0.0 : -y; // (|x|<1)**+-inf = 0,inf\n        }\n        if (iy == 0x3FF00000) {\n          if (hy >= 0) return x;\n          return 1 / x;\n        }\n        if (hy == 0x40000000) return x * x;\n        if (hy == 0x3FE00000) {\n          if (hx >= 0) return builtin_sqrt(x);\n        }\n      }\n      let ax = builtin_abs<f64>(x), z: f64;\n      if (lx == 0) {\n        if (ix == 0 || ix == 0x7FF00000 || ix == 0x3FF00000) {\n          z = ax;\n          if (hy < 0) z = 1.0 / z;\n          if (hx < 0) {\n            if (((ix - 0x3FF00000) | yisint) == 0) {\n              let d = z - z;\n              z = d / d;\n            } else if (yisint == 1) z = -z;\n          }\n          return z;\n        }\n      }\n      let s = 1.0;\n      if (hx < 0) {\n        if (yisint == 0) {\n          let d = x - x;\n          return d / d;\n        }\n        if (yisint == 1) s = -1.0;\n      }\n      let t1: f64, t2: f64, p_h: f64, p_l: f64, r: f64, t: f64, u: f64, v: f64, w: f64;\n      let j: i32, n: i32;\n      if (iy > 0x41E00000) {\n        if (iy > 0x43F00000) {\n          if (ix <= 0x3FEFFFFF) return hy < 0 ? huge * huge : tiny * tiny;\n          if (ix >= 0x3FF00000) return hy > 0 ? huge * huge : tiny * tiny;\n        }\n        if (ix < 0x3FEFFFFF) return hy < 0 ? s * huge * huge : s * tiny * tiny;\n        if (ix > 0x3FF00000) return hy > 0 ? s * huge * huge : s * tiny * tiny;\n        t = ax - 1.0;\n        w = (t * t) * (0.5 - t * (inv3 - t * 0.25));\n        u = ivln2_h * t;\n        v = t * ivln2_l - w * ivln2;\n        t1 = u + v;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = v - (t1 - u);\n      } else {\n        let ss: f64, s2: f64, s_h: f64, s_l: f64, t_h: f64, t_l: f64;\n        n = 0;\n        if (ix < 0x00100000) {\n          ax *= two53;\n          n -= 53;\n          ix = <u32>(reinterpret<u64>(ax) >> 32);\n        }\n        n += (ix >> 20) - 0x3FF;\n        j = ix & 0x000FFFFF;\n        ix = j | 0x3FF00000;\n        if (j <= 0x3988E) k = 0;\n        else if (j < 0xBB67A) k = 1;\n        else {\n          k = 0;\n          n += 1;\n          ix -= 0x00100000;\n        }\n        ax = reinterpret<f64>(reinterpret<u64>(ax) & 0xFFFFFFFF | (<u64>ix << 32));\n        let bp = select<f64>(1.5, 1.0, k); // k ? 1.5 : 1.0\n        u = ax - bp;\n        v = 1.0 / (ax + bp);\n        ss = u * v;\n        s_h = ss;\n        s_h = reinterpret<f64>(reinterpret<u64>(s_h) & 0xFFFFFFFF00000000);\n        t_h = reinterpret<f64>(<u64>(((ix >> 1) | 0x20000000) + 0x00080000 + (k << 18)) << 32);\n        t_l = ax - (t_h - bp);\n        s_l = v * ((u - s_h * t_h) - s_h * t_l);\n        s2 = ss * ss;\n        r = s2 * s2 * (L1 + s2 * (L2 + s2 * (L3 + s2 * (L4 + s2 * (L5 + s2 * L6)))));\n        r += s_l * (s_h + ss);\n        s2 = s_h * s_h;\n        t_h = 3.0 + s2 + r;\n        t_h = reinterpret<f64>(reinterpret<u64>(t_h) & 0xFFFFFFFF00000000);\n        t_l = r - ((t_h - 3.0) - s2);\n        u = s_h * t_h;\n        v = s_l * t_h + t_l * ss;\n        p_h = u + v;\n        p_h = reinterpret<f64>(reinterpret<u64>(p_h) & 0xFFFFFFFF00000000);\n        p_l = v - (p_h - u);\n        let z_h = cp_h * p_h;\n        let dp_l = select<f64>(dp_l1, 0.0, k);\n        let z_l = cp_l * p_h + p_l * cp + dp_l;\n        t = <f64>n;\n        let dp_h = select<f64>(dp_h1, 0.0, k);\n        t1 = ((z_h + z_l) + dp_h) + t;\n        t1 = reinterpret<f64>(reinterpret<u64>(t1) & 0xFFFFFFFF00000000);\n        t2 = z_l - (((t1 - t) - dp_h) - z_h);\n      }\n      let y1 = y;\n      y1 = reinterpret<f64>(reinterpret<u64>(y1) & 0xFFFFFFFF00000000);\n      p_l = (y - y1) * t1 + y * t2;\n      p_h = y1 * t1;\n      z = p_l + p_h;\n      u_ = reinterpret<u64>(z);\n      j = <u32>(u_ >> 32);\n      let i = <i32>u_;\n      if (j >= 0x40900000) {\n        if (((j - 0x40900000) | i) != 0) return s * huge * huge;\n        if (p_l + ovt > z - p_h) return s * huge * huge;\n      } else if ((j & 0x7FFFFFFF) >= 0x4090CC00) {\n        if (((j - 0xC090CC00) | i) != 0) return s * tiny * tiny;\n        if (p_l <= z - p_h) return s * tiny * tiny;\n      }\n      i = j & 0x7FFFFFFF;\n      k = (i >> 20) - 0x3FF;\n      n = 0;\n      if (i > 0x3FE00000) {\n        n = j + (0x00100000 >> (k + 1));\n        k = ((n & 0x7FFFFFFF) >> 20) - 0x3FF;\n        t = 0.0;\n        t = reinterpret<f64>(<u64>(n & ~(0x000FFFFF >> k)) << 32);\n        n = ((n & 0x000FFFFF) | 0x00100000) >> (20 - k);\n        if (j < 0) n = -n;\n        p_h -= t;\n      }\n      t = p_l + p_h;\n      t = reinterpret<f64>(reinterpret<u64>(t) & 0xFFFFFFFF00000000);\n      u = t * lg2_h;\n      v = (p_l - (t - p_h)) * lg2 + t * lg2_l;\n      z = u + v;\n      w = v - (z - u);\n      t = z * z;\n      t1 = z - t * (P1 + t * (P2 + t * (P3 + t * (P4 + t * P5))));\n      r = (z * t1) / (t1 - 2.0) - (w + z * w);\n      z = 1.0 - (r - z);\n      j = <u32>(reinterpret<u64>(z) >> 32);\n      j += n << 20;\n      if ((j >> 20) <= 0) z = scalbn(z, n);\n      else z = reinterpret<f64>(reinterpret<u64>(z) & 0xFFFFFFFF | (<u64>j << 32));\n      return s * z;\n    }\n  }\n\n  export function seedRandom(value: i64): void {\n    random_seeded = true;\n    random_state0_64 = murmurHash3(value);\n    random_state1_64 = murmurHash3(~random_state0_64);\n    random_state0_32 = splitMix32(<u32>value);\n    random_state1_32 = splitMix32(random_state0_32);\n    assert(\n      random_state0_64 != 0 && random_state1_64 != 0 &&\n      random_state0_32 != 0 && random_state1_32 != 0\n    );\n  }\n\n  export function random(): f64 { // see: v8/src/base/utils/random-number-generator.cc\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n    var s1 = random_state0_64;\n    var s0 = random_state1_64;\n    random_state0_64 = s0;\n    s1 ^= s1 << 23;\n    s1 ^= s1 >> 17;\n    s1 ^= s0;\n    s1 ^= s0 >> 26;\n    random_state1_64 = s1;\n    var r = (s0 >> 12) | 0x3FF0000000000000;\n    return reinterpret<f64>(r) - 1;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f64): f64 {\n    return builtin_copysign<f64>(builtin_floor<f64>(x + 0.5), x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f64): f64 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f64>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f64): bool {\n    return <bool>(reinterpret<u64>(x) >>> 63);\n  }\n\n  export function sin(x: f64): f64 { // see: musl/src/math/sin.c\n    var u  = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E500000) { // |x| < 2**-26\n        return x;\n      }\n      return sin_kern(x, 0.0, 0);\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    // argument reduction needed\n    var n  = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n\n    x = n & 1 ? cos_kern(y0, y1) : sin_kern(y0, y1, 1);\n    return n & 2 ? -x : x;\n  }\n\n  export function sinh(x: f64): f64 { // see: musl/src/math/sinh.c\n    var u = reinterpret<u64>(x) & 0x7FFFFFFFFFFFFFFF;\n    var a = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var h = builtin_copysign(0.5, x);\n    if (w < 0x40862E42) {\n      let t = expm1(a);\n      if (w < 0x3FF00000) {\n        if (w < 0x3FF00000 - (26 << 20)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f64): f64 {\n    return builtin_sqrt<f64>(x);\n  }\n\n  export function tan(x: f64): f64 { // see: musl/src/math/tan.c\n    var u = reinterpret<u64>(x);\n    var ix = <i32>(u >> 32);\n    var sign = ix >>> 31;\n\n    ix &= 0x7FFFFFFF;\n\n    // |x| ~< pi/4\n    if (ix <= 0x3FE921FB) {\n      if (ix < 0x3E400000) { // |x| < 2**-27\n        return x;\n      }\n      return tan_kern(x, 0.0, 1);\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ix >= 0x7FF00000) return x - x;\n\n    var n = rempio2(x, u, sign);\n    return tan_kern(rempio2_y0, rempio2_y1, 1 - ((n & 1) << 1));\n  }\n\n  export function tanh(x: f64): f64 { // see: musl/src/math/tanh.c\n    var u = reinterpret<u64>(x);\n    u &= 0x7FFFFFFFFFFFFFFF;\n    var y = reinterpret<f64>(u);\n    var w = <u32>(u >> 32);\n    var t: f64;\n    if (w > 0x3FE193EA) {\n      if (w > 0x40340000) {\n        t = 1 - 0 / y;\n      } else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (w > 0x3FD058AE) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (w >= 0x00100000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f64>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f64): f64 {\n    return builtin_trunc<f64>(x);\n  }\n\n  export function scalbn(x: f64, n: i32): f64 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbn.c\n    const\n      Ox1p53    = reinterpret<f64>(0x4340000000000000),\n      Ox1p1023  = reinterpret<f64>(0x7FE0000000000000),\n      Ox1p_1022 = reinterpret<f64>(0x0010000000000000);\n\n    var y = x;\n    if (n > 1023) {\n      y *= Ox1p1023;\n      n -= 1023;\n      if (n > 1023) {\n        y *= Ox1p1023;\n        n = builtin_min<i32>(n - 1023, 1023);\n      }\n    } else if (n < -1022) {\n      // make sure final n < -53 to avoid double\n      // rounding in the subnormal range\n      y *= Ox1p_1022 * Ox1p53;\n      n += 1022 - 53;\n      if (n < -1022) {\n        y *= Ox1p_1022 * Ox1p53;\n        n = builtin_max<i32>(n + 1022 - 53, -1022);\n      }\n    }\n    return y * reinterpret<f64>(<u64>(0x3FF + n) << 52);\n  }\n\n  export function mod(x: f64, y: f64): f64 { // see: musl/src/math/fmod.c\n    if (builtin_abs<f64>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f64>(x - builtin_trunc<f64>(x), x);\n    }\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = ux >> 63;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0x7FF || isNaN<f64>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f64(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<i64>(ux << 12);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u64>-1 >> 12;\n      ux |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 52); ux <<= 1) --ex;\n    var shift = builtin_clz<i64>(ux << 11);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 52;\n      ux |= ex << 52;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f64>(ux | (sx << 63));\n  }\n\n  export function rem(x: f64, y: f64): f64 { // see: musl/src/math/remquo.c\n    var ux = reinterpret<u64>(x);\n    var uy = reinterpret<u64>(y);\n    var ex = <i64>(ux >> 52 & 0x7FF);\n    var ey = <i64>(uy >> 52 & 0x7FF);\n    var sx = <i32>(ux >> 63);\n    if (uy << 1 == 0 || ex == 0x7FF || isNaN(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    if (ux << 1 == 0) return x;\n    var uxi = ux;\n    if (!ex) {\n      ex -= builtin_clz<i64>(uxi << 12);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= <u64>-1 >> 12;\n      uxi |= 1 << 52;\n    }\n    if (!ey) {\n      ey -= builtin_clz<i64>(uy << 12);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u64>-1 >> 12;\n      uy |= 1 << 52;\n    }\n    var q: u32 = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -60;\n      else {\n        let shift = builtin_clz<i64>(uxi << 11);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 52;\n      uxi |= ex << 52;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f64>(uxi);\n    y = builtin_abs<f64>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (x2 > y || (x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // ++q;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f64): void { // see: musl/tree/src/math/sincos.c\n    var u = reinterpret<u64>(x);\n    var ix = <u32>(u >> 32);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3FE921FB) {  // |x| ~<= /4\n      if (ix < 0x3E46A09E) { // if |x| < 2**-27 * sqrt(2)\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kern(x, 0, 0);\n      sincos_cos = cos_kern(x, 0);\n      return;\n    }\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    var n = rempio2(x, u, sign);\n    var y0 = rempio2_y0;\n    var y1 = rempio2_y1;\n    var s = sin_kern(y0, y1, 1);\n    var c = cos_kern(y0, y1);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\n// @ts-ignore: decorator\n@lazy var rempio2f_y: f64;\n\n// @ts-ignore: decorator\n@lazy @inline const PIO2F_TABLE = memory.data<u64>([\n  0xA2F9836E4E441529,\n  0xFC2757D1F534DDC0,\n  0xDB6295993C439041,\n  0xFE5163ABDEBBC561\n]);\n\nfunction Rf(z: f32): f32 { // Rational approximation of (asin(x)-x)/x^3\n  const                    // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    pS0 = reinterpret<f32>(0x3E2AAA75), //  1.6666586697e-01f\n    pS1 = reinterpret<f32>(0xBD2F13BA), // -4.2743422091e-02f\n    pS2 = reinterpret<f32>(0xBC0DD36B), // -8.6563630030e-03f\n    qS1 = reinterpret<f32>(0xBF34E5AE); // -7.0662963390e-01f\n\n  var p = z * (pS0 + z * (pS1 + z * pS2));\n  var q: f32 = 1 + z * qS1;\n  return p / q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction expo2f(x: f32, sign: f32): f32 { // exp(x)/2 for x >= log(DBL_MAX)\n  const                                // see: musl/src/math/__expo2f.c\n    k    = <u32>235,\n    kln2 = reinterpret<f32>(0x4322E3BC); // 0x1.45c778p+7f\n  var scale = reinterpret<f32>(<u32>(0x7F + (k >> 1)) << 23);\n  // in directed rounding correct sign before rounding or overflow is important\n  return NativeMathf.exp(x - kln2) * (sign * scale) * scale;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pio2f_large_quot(x: f32, u: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const coeff = reinterpret<f64>(0x3BF921FB54442D18); //  * 0x1p-65 = 8.51530395021638647334e-20\n\n  var offset = (u >> 23) - 152;\n  var shift  = <u64>(offset & 63);\n  var tblPtr = PIO2F_TABLE + (offset >> 6 << 3);\n\n  var b0 = load<u64>(tblPtr, 0 << 3);\n  var b1 = load<u64>(tblPtr, 1 << 3);\n  var lo: u64;\n\n  if (shift > 32) {\n    let b2 = load<u64>(tblPtr, 2 << 3);\n    lo  = b2 >> (96 - shift);\n    lo |= b1 << (shift - 32);\n  } else {\n    lo = b1 >> (32 - shift);\n  }\n\n  var hi = (b1 >> (64 - shift)) | (b0 << shift);\n  var mantissa: u64 = (u & 0x007FFFFF) | 0x00800000;\n  var product = mantissa * hi + (mantissa * lo >> 32);\n  var r: i64 = product << 2;\n  var q = <i32>((product >> 62) + (r >>> 63));\n  rempio2f_y = copysign<f64>(coeff, x) * <f64>r;\n  return q;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction rempio2f(x: f32, u: u32, sign: i32): i32 { // see: jdh8/metallic/blob/master/src/math/float/rem_pio2f.c\n  const\n    pi2hi = reinterpret<f64>(0x3FF921FB50000000), // 1.57079631090164184570\n    pi2lo = reinterpret<f64>(0x3E5110B4611A6263), // 1.58932547735281966916e-8\n    _2_pi = reinterpret<f64>(0x3FE45F306DC9C883); // 0.63661977236758134308\n\n  if (u < 0x4DC90FDB) { //  * 0x1p28\n    let q = nearest(x * _2_pi);\n    rempio2f_y = x - q * pi2hi - q * pi2lo;\n    return <i32>q;\n  }\n\n  var q = pio2f_large_quot(x, u);\n  return select(-q, q, sign);\n}\n\n// |sin(x)/x - s(x)| < 2**-37.5 (~[-4.89e-12, 4.824e-12]).\n// @ts-ignore: decorator\n@inline\nfunction sin_kernf(x: f64): f32 { // see: musl/tree/src/math/__sindf.c\n  const\n    S1 = reinterpret<f64>(0xBFC5555554CBAC77), // -0x15555554cbac77.0p-55\n    S2 = reinterpret<f64>(0x3F811110896EFBB2), //  0x111110896efbb2.0p-59\n    S3 = reinterpret<f64>(0xBF2A00F9E2CAE774), // -0x1a00f9e2cae774.0p-65\n    S4 = reinterpret<f64>(0x3EC6CD878C3B46A7); //  0x16cd878c3b46a7.0p-71\n\n  var z = x * x;\n  var w = z * z;\n  var r = S3 + z * S4;\n  var s = z * x;\n  return <f32>((x + s * (S1 + z * S2)) + s * w * r);\n}\n\n// |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]).\n// @ts-ignore: decorator\n@inline\nfunction cos_kernf(x: f64): f32 { // see: musl/tree/src/math/__cosdf.c\n  const\n    C0 = reinterpret<f64>(0xBFDFFFFFFD0C5E81), // -0x1ffffffd0c5e81.0p-54\n    C1 = reinterpret<f64>(0x3FA55553E1053A42), //  0x155553e1053a42.0p-57\n    C2 = reinterpret<f64>(0xBF56C087E80F1E27), // -0x16c087e80f1e27.0p-62\n    C3 = reinterpret<f64>(0x3EF99342E0EE5069); //  0x199342e0ee5069.0p-68\n\n  var z = x * x;\n  var w = z * z;\n  var r = C2 + z * C3;\n  return <f32>(((1 + z * C0) + w * C1) + (w * z) * r);\n}\n\n// |tan(x)/x - t(x)| < 2**-25.5 (~[-2e-08, 2e-08]).\n// @ts-ignore: decorator\n@inline\nfunction tan_kernf(x: f64, odd: i32): f32 { // see: musl/tree/src/math/__tandf.c\n  const\n    T0 = reinterpret<f64>(0x3FD5554D3418C99F), // 0x15554d3418c99f.0p-54\n    T1 = reinterpret<f64>(0x3FC112FD38999F72), // 0x1112fd38999f72.0p-55\n    T2 = reinterpret<f64>(0x3FAB54C91D865AFE), // 0x1b54c91d865afe.0p-57\n    T3 = reinterpret<f64>(0x3F991DF3908C33CE), // 0x191df3908c33ce.0p-58\n    T4 = reinterpret<f64>(0x3F685DADFCECF44E), // 0x185dadfcecf44e.0p-61\n    T5 = reinterpret<f64>(0x3F8362B9BF971BCD); // 0x1362b9bf971bcd.0p-59\n\n  var z = x * x;\n  var r = T4 + z * T5;\n  var t = T2 + z * T3;\n  var w = z * z;\n  var s = z * x;\n  var u = T0 + z * T1;\n\n  r = (x + s * u) + (s * w) * (t + w * r);\n  return <f32>(odd ? -1 / r : r);\n}\n\n// See: jdh8/metallic/src/math/float/log2f.c and jdh8/metallic/src/math/float/kernel/atanh.h\n// @ts-ignore: decorator\n@inline\nfunction log2f(x: f64): f64 {\n  const\n    log2e = reinterpret<f64>(0x3FF71547652B82FE), // 1.44269504088896340736\n    c0 = reinterpret<f64>(0x3FD555554FD9CAEF),    // 0.33333332822728226129\n    c1 = reinterpret<f64>(0x3FC999A7A8AF4132),    // 0.20000167595436263505\n    c2 = reinterpret<f64>(0x3FC2438D79437030),    // 0.14268654271188685375\n    c3 = reinterpret<f64>(0x3FBE2F663B001C97);    // 0.11791075649681414150\n\n  var i = reinterpret<i64>(x);\n  var exponent = (i - 0x3FE6A09E667F3BCD) >> 52;\n  x = reinterpret<f64>(i - (exponent << 52));\n  x = (x - 1) / (x + 1);\n  var xx = x * x;\n  var y = x + x * xx * (c0 + c1 * xx + (c2 + c3 * xx) * (xx * xx));\n  return (2 * log2e) * y + <f64>exponent;\n}\n\n// See: jdh8/metallic/src/math/float/exp2f.h and jdh8/metallic/blob/master/src/math/float/kernel/exp2f.h\n// @ts-ignore: decorator\n@inline\nfunction exp2f(x: f64): f64 {\n  const\n    c0 = reinterpret<f64>(0x3FE62E4302FCC24A), // 6.931471880289532425e-1\n    c1 = reinterpret<f64>(0x3FCEBFBE07D97B91), // 2.402265108421173406e-1\n    c2 = reinterpret<f64>(0x3FAC6AF6CCFC1A65), // 5.550357105498874537e-2\n    c3 = reinterpret<f64>(0x3F83B29E3CE9AEF6), // 9.618030771171497658e-3\n    c4 = reinterpret<f64>(0x3F55F0896145A89F), // 1.339086685300950937e-3\n    c5 = reinterpret<f64>(0x3F2446C81E384864); // 1.546973499989028719e-4\n\n  if (x < -1022) return 0;\n  if (x >= 1024) return Infinity;\n\n  var n = nearest(x);\n  x -= n;\n  var xx = x * x;\n  var y = 1 + x * (c0 + c1 * x + (c2 + c3 * x) * xx + (c4 + c5 * x) * (xx * xx));\n  return reinterpret<f64>(reinterpret<i64>(y) + (<i64>n << 52));\n}\n\nexport namespace NativeMathf {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const E       = <f32>NativeMath.E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN2     = <f32>NativeMath.LN2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LN10    = <f32>NativeMath.LN10;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG2E   = <f32>NativeMath.LOG2E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const LOG10E  = <f32>NativeMath.LOG10E;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const PI      = <f32>NativeMath.PI;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT1_2 = <f32>NativeMath.SQRT1_2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const SQRT2   = <f32>NativeMath.SQRT2;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_sin: f32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export var sincos_cos: f32 = 0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function abs(x: f32): f32 {\n    return builtin_abs<f32>(x);\n  }\n\n  export function acos(x: f32): f32 { // see: musl/src/math/acosf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2_hi   = reinterpret<f32>(0x3FC90FDA), // 1.5707962513e+00f\n      pio2_lo   = reinterpret<f32>(0x33A22168), // 7.5497894159e-08f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    var hx = reinterpret<u32>(x);\n    var ix = hx & 0x7FFFFFFF;\n    if (ix >= 0x3F800000) {\n      if (ix == 0x3F800000) {\n        if (hx >> 31) return 2 * pio2_hi + Ox1p_120f;\n        return 0;\n      }\n      return 0 / (x - x);\n    }\n    if (ix < 0x3F000000) {\n      if (ix <= 0x32800000) return pio2_hi + Ox1p_120f;\n      return pio2_hi - (x - (pio2_lo - x * Rf(x * x)));\n    }\n    var z: f32, w: f32, s: f32;\n    if (hx >> 31) {\n      // z = (1 + x) * 0.5;\n      z = 0.5 + x * 0.5;\n      s = builtin_sqrt<f32>(z);\n      w = Rf(z) * s - pio2_lo;\n      return 2 * (pio2_hi - (s + w));\n    }\n    // z = (1 - x) * 0.5;\n    z = 0.5 - x * 0.5;\n    s = builtin_sqrt<f32>(z);\n    hx = reinterpret<u32>(s);\n    var df = reinterpret<f32>(hx & 0xFFFFF000);\n    var c = (z - df * df) / (s + df);\n    w = Rf(z) * s + c;\n    return 2 * (df + w);\n  }\n\n  export function acosh(x: f32): f32 { // see: musl/src/math/acoshf.c\n    const s = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x);\n    var a = u & 0x7FFFFFFF;\n    if (a < 0x3F800000 + (1 << 23)) { // |x| < 2, invalid if x < 1\n      let xm1 = x - 1;\n      return log1p(xm1 + builtin_sqrt(xm1 * (xm1 + 2)));\n    }\n    if (u < 0x3F800000 + (12 << 23)) { // 2 <= x < 0x1p12\n      return log(2 * x - 1 / (x + builtin_sqrt<f32>(x * x - 1)));\n    }\n    // x >= 0x1p12 or x <= -2 or NaN\n    return log(x) + s;\n  }\n\n  export function asin(x: f32): f32 { // see: musl/src/math/asinf.c and SUN COPYRIGHT NOTICE above\n    const\n      pio2      = reinterpret<f32>(0x3FC90FDB), // 1.570796326794896558e+00f\n      Ox1p_120f = reinterpret<f32>(0x03800000); // 0x1p-120f\n\n    var sx = x;\n    var hx = reinterpret<u32>(x) & 0x7FFFFFFF;\n    if (hx >= 0x3F800000) {\n      if (hx == 0x3F800000) return x * pio2 + Ox1p_120f;\n      return 0 / (x - x);\n    }\n    if (hx < 0x3F000000) {\n      if (hx < 0x39800000 && hx >= 0x00800000) return x;\n      return x + x * Rf(x * x);\n    }\n    // var z: f32 = (1 - builtin_abs<f32>(x)) * 0.5;\n    var z: f32 = 0.5 - builtin_abs<f32>(x) * 0.5;\n    var s = builtin_sqrt<f64>(z); // sic\n    x = <f32>(pio2 - 2 * (s + s * Rf(z)));\n    return builtin_copysign(x, sx);\n  }\n\n  export function asinh(x: f32): f32 { // see: musl/src/math/asinhf.c\n    const c = reinterpret<f32>(0x3F317218); // 0.693147180559945309417232121458176568f\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    if (u >= 0x3F800000 + (12 << 23)) y = log(y) + c;\n    else if (u >= 0x3F800000 + (1 << 23))  y =   log(2 * y + 1 / (builtin_sqrt<f32>(y * y + 1) + y));\n    else if (u >= 0x3F800000 - (12 << 23)) y = log1p(y + y * y / (builtin_sqrt<f32>(y * y + 1) + 1));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan(x: f32): f32 { // see: musl/src/math/atanf.c and SUN COPYRIGHT NOTICE above\n    const\n      atanhi0   = reinterpret<f32>(0x3EED6338), //  4.6364760399e-01f\n      atanhi1   = reinterpret<f32>(0x3F490FDA), //  7.8539812565e-01f\n      atanhi2   = reinterpret<f32>(0x3F7B985E), //  9.8279368877e-01f\n      atanhi3   = reinterpret<f32>(0x3FC90FDA), //  1.5707962513e+00f\n      atanlo0   = reinterpret<f32>(0x31AC3769), //  5.0121582440e-09f\n      atanlo1   = reinterpret<f32>(0x33222168), //  3.7748947079e-08f\n      atanlo2   = reinterpret<f32>(0x33140FB4), //  3.4473217170e-08f\n      atanlo3   = reinterpret<f32>(0x33A22168), //  7.5497894159e-08f\n      aT0       = reinterpret<f32>(0x3EAAAAA9), //  3.3333328366e-01f\n      aT1       = reinterpret<f32>(0xBE4CCA98), // -1.9999158382e-01f\n      aT2       = reinterpret<f32>(0x3E11F50D), //  1.4253635705e-01f\n      aT3       = reinterpret<f32>(0xBDDA1247), // -1.0648017377e-01f\n      aT4       = reinterpret<f32>(0x3D7CAC25), //  6.1687607318e-02f\n      Ox1p_120f = reinterpret<f32>(0x03800000); //  0x1p-120f\n\n    var ix = reinterpret<u32>(x);\n    var sx = x;\n    ix &= 0x7FFFFFFF;\n    var z: f32;\n    if (ix >= 0x4C800000) {\n      if (isNaN(x)) return x;\n      z = atanhi3 + Ox1p_120f;\n      return builtin_copysign(z, sx);\n    }\n    var id: i32;\n    if (ix < 0x3EE00000) {\n      if (ix < 0x39800000) return x;\n      id = -1;\n    } else {\n      x = builtin_abs<f32>(x);\n      if (ix < 0x3F980000) {\n        if (ix < 0x3F300000) {\n          id = 0;\n          x = (2.0 * x - 1.0) / (2.0 + x);\n        } else {\n          id = 1;\n          x = (x - 1.0) / (x + 1.0);\n        }\n      } else {\n        if (ix < 0x401C0000) {\n          id = 2;\n          x = (x - 1.5) / (1.0 + 1.5 * x);\n        } else {\n          id = 3;\n          x = -1.0 / x;\n        }\n      }\n    }\n    z = x * x;\n    var w = z * z;\n    var s1 = z * (aT0 + w * (aT2 + w * aT4));\n    var s2 = w * (aT1 + w * aT3);\n    var s3 = x * (s1 + s2);\n    if (id < 0) return x - s3;\n    switch (id) {\n      case 0: { z = atanhi0 - ((s3 - atanlo0) - x); break; }\n      case 1: { z = atanhi1 - ((s3 - atanlo1) - x); break; }\n      case 2: { z = atanhi2 - ((s3 - atanlo2) - x); break; }\n      case 3: { z = atanhi3 - ((s3 - atanlo3) - x); break; }\n      default: unreachable();\n    }\n    return builtin_copysign(z, sx);\n  }\n\n  export function atanh(x: f32): f32 { // see: musl/src/math/atanhf.c\n    var u = reinterpret<u32>(x);\n    var y = builtin_abs(x);\n    if (u < 0x3F800000 - (1 << 23)) {\n      if (u >= 0x3F800000 - (32 << 23)) y = 0.5 * log1p(2 * y * (1.0 + y / (1 - y)));\n    } else y = 0.5 * log1p(2 * (y / (1 - y)));\n    return builtin_copysign(y, x);\n  }\n\n  export function atan2(y: f32, x: f32): f32 { // see: musl/src/math/atan2f.c and SUN COPYRIGHT NOTICE above\n    const\n      pi    = reinterpret<f32>(0x40490FDB), //  3.1415927410e+00f\n      pi_lo = reinterpret<f32>(0xB3BBBD2E); // -8.7422776573e-08f\n\n    if (isNaN(x) || isNaN(y)) return x + y;\n    var ix = reinterpret<u32>(x);\n    var iy = reinterpret<u32>(y);\n    if (ix == 0x3F800000) return atan(y);\n    var m = <u32>(((iy >> 31) & 1) | ((ix >> 30) & 2));\n    ix &= 0x7FFFFFFF;\n    iy &= 0x7FFFFFFF;\n    if (iy == 0) {\n      switch (m) {\n        case 0:\n        case 1: return  y;\n        case 2: return  pi;\n        case 3: return -pi;\n      }\n    }\n    if (ix == 0) return m & 1 ? -pi / 2 : pi / 2;\n    if (ix == 0x7F800000) {\n      if (iy == 0x7F800000) {\n        let t: f32 = m & 2 ? 3 * pi / 4 : pi / 4;\n        return m & 1 ? -t : t;\n      } else {\n        let t: f32 = m & 2 ? pi : 0.0;\n        return m & 1 ? -t : t;\n      }\n    }\n    if (ix + (26 << 23) < iy || iy == 0x7F800000) return m & 1 ? -pi / 2 : pi / 2;\n    var z: f32;\n    if ((m & 2) && iy + (26 << 23) < ix) z = 0.0;\n    else z = atan(builtin_abs<f32>(y / x));\n    switch (m) {\n      case 0: return  z;\n      case 1: return -z;\n      case 2: return pi - (z - pi_lo);\n      case 3: return (z - pi_lo) - pi;\n    }\n    unreachable();\n    return 0;\n  }\n\n  export function cbrt(x: f32): f32 { // see: musl/src/math/cbrtf.c and SUN COPYRIGHT NOTICE above\n    const\n      B1      = <u32>709958130,\n      B2      = <u32>642849266,\n      Ox1p24f = reinterpret<f32>(0x4B800000);\n\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    if (hx >= 0x7F800000) return x + x;\n    if (hx < 0x00800000) {\n      if (hx == 0) return x;\n      u = reinterpret<u32>(x * Ox1p24f);\n      hx = u & 0x7FFFFFFF;\n      hx = hx / 3 + B2;\n    } else {\n      hx = hx / 3 + B1;\n    }\n    u &= 0x80000000;\n    u |= hx;\n    var t = <f64>reinterpret<f32>(u);\n    var r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    r = t * t * t;\n    t = t * (<f64>x + x + r) / (x + r + r);\n    return <f32>t;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function ceil(x: f32): f32 {\n    return builtin_ceil<f32>(x);\n  }\n\n  export function clz32(x: f32): f32 {\n    if (!isFinite(x)) return 32;\n    return <f32>builtin_clz(dtoi32(x));\n  }\n\n  export function cos(x: f32): f32 { // see: musl/src/math/cosf.c\n    const\n      c1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      c2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      c3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      c4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        // raise inexact if x != 0\n        return 1;\n      }\n      return cos_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {  // |x| ~<= 5/4\n        if (ix > 0x4016CBE3) { // |x|  ~> 3/4\n          return -cos_kernf(sign ? x + c2pio2 : x - c2pio2);\n        } else {\n          return sign ? sin_kernf(x + c1pio2) : sin_kernf(c1pio2 - x);\n        }\n      }\n      if (ix <= 0x40E231D5) {  // |x| ~<= 9/4\n        if (ix > 0x40AFEDDF) { // |x|  ~> 7/4\n          return cos_kernf(sign ? x + c4pio2 : x - c4pio2);\n        } else {\n          return sign ? sin_kernf(-x - c3pio2) : sin_kernf(x - c3pio2);\n        }\n      }\n    }\n\n    // cos(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    // general argument reduction needed\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? sin_kernf(y) : cos_kernf(y);\n    return (n + 1) & 2 ? -t : t;\n  }\n\n  export function cosh(x: f32): f32 { // see: musl/src/math/coshf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    x = reinterpret<f32>(u);\n    if (u < 0x3F317217) {\n      if (u < 0x3F800000 - (12 << 23)) return 1;\n      let t = expm1(x);\n      // return 1 + t * t / (2 * (1 + t));\n      return 1 + t * t / (2 + 2 * t);\n    }\n    if (u < 0x42B17217) {\n      let t = exp(x);\n      // return 0.5 * (t + 1 / t);\n      return 0.5 * t + 0.5 / t;\n    }\n    return expo2f(x, 1);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function floor(x: f32): f32 {\n    return builtin_floor<f32>(x);\n  }\n\n  export function exp(x: f32): f32 { // see: musl/src/math/expf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return expf_lut(x);\n    } else {\n      const\n        ln2hi    = reinterpret<f32>(0x3F317200), //  6.9314575195e-1f\n        ln2lo    = reinterpret<f32>(0x35BFBE8E), //  1.4286067653e-6f\n        invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+0f\n        P1       = reinterpret<f32>(0x3E2AAA8F), //  1.6666625440e-1f\n        P2       = reinterpret<f32>(0xBB355215), // -2.7667332906e-3f\n        Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n      let hx = reinterpret<u32>(x);\n      let sign_ = <i32>(hx >> 31);\n      hx &= 0x7FFFFFFF;\n      if (hx >= 0x42AEAC50) {\n        if (hx > 0x7F800000) return x; // NaN\n        if (hx >= 0x42B17218) {\n          if (!sign_) return x * Ox1p127f;\n          else if (hx >= 0x42CFF1B5) return 0;\n        }\n      }\n      let hi: f32, lo: f32;\n      let k: i32;\n      if (hx > 0x3EB17218) {\n        if (hx > 0x3F851592) {\n          k = <i32>(invln2 * x + builtin_copysign<f32>(0.5, x));\n        } else {\n          k = 1 - (sign_ << 1);\n        }\n        hi = x - <f32>k * ln2hi;\n        lo = <f32>k * ln2lo;\n        x = hi - lo;\n      } else if (hx > 0x39000000) {\n        k = 0;\n        hi = x;\n        lo = 0;\n      } else {\n        return 1 + x;\n      }\n      let xx = x * x;\n      let c = x - xx * (P1 + xx * P2);\n      let y: f32 = 1 + (x * c / (2 - c) - lo + hi);\n      return k == 0 ? y : scalbn(y, k);\n    }\n  }\n\n  export function exp2(x: f32): f32 {\n    return exp2f_lut(x);\n  }\n\n  export function expm1(x: f32): f32 { // see: musl/src/math/expm1f.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi   = reinterpret<f32>(0x3F317180), //  6.9313812256e-01f\n      ln2_lo   = reinterpret<f32>(0x3717F7D1), //  9.0580006145e-06f\n      invln2   = reinterpret<f32>(0x3FB8AA3B), //  1.4426950216e+00f\n      Q1       = reinterpret<f32>(0xBD088868), // -3.3333212137e-02f\n      Q2       = reinterpret<f32>(0x3ACF3010), //  1.5807170421e-03f\n      Ox1p127f = reinterpret<f32>(0x7F000000); //  0x1p+127f\n\n    var u = reinterpret<u32>(x);\n    var hx = u & 0x7FFFFFFF;\n    var sign_ = <i32>(u >> 31);\n    if (hx >= 0x4195B844) {\n      if (hx > 0x7F800000) return x;\n      if (sign_) return -1;\n      if (hx > 0x42B17217) { // x > log(FLT_MAX)\n        x *= Ox1p127f;\n        return x;\n      }\n    }\n    var c: f32 = 0.0, t: f32, k: i32;\n    if (hx > 0x3EB17218) {\n      k = select<i32>(\n        1 - (sign_ << 1),\n        <i32>(invln2 * x + builtin_copysign<f32>(0.5, x)),\n        hx < 0x3F851592\n      );\n      t = <f32>k;\n      let hi = x - t * ln2_hi;\n      let lo = t * ln2_lo;\n      x = hi - lo;\n      c = (hi - x) - lo;\n    } else if (hx < 0x33000000) {\n      return x;\n    } else k = 0;\n    var hfx: f32 = 0.5 * x;\n    var hxs: f32 = x * hfx;\n    var r1: f32 = 1.0 + hxs * (Q1 + hxs * Q2);\n    t  = 3.0 - r1 * hfx;\n    var e = hxs * ((r1 - t) / (6.0 - x * t));\n    if (k == 0) return x - (x * e - hxs);\n    e  = x * (e - c) - c;\n    e -= hxs;\n    if (k == -1) return 0.5 * (x - e) - 0.5;\n    if (k == 1) {\n      if (x < -0.25) return -2.0 * (e - (x + 0.5));\n      return 1.0 + 2.0 * (x - e);\n    }\n    u = (0x7F + k) << 23;\n    var twopk = reinterpret<f32>(u);\n    var y: f32;\n    if (k < 0 || k > 56) {\n      y = x - e + 1.0;\n      if (k == 128) y = y * 2.0 * Ox1p127f;\n      else y = y * twopk;\n      return y - 1.0;\n    }\n    u = (0x7F - k) << 23;\n    y = reinterpret<f32>(u);\n    if (k < 20) y = (1 - y) - e;\n    else y = 1 - (e + y);\n    return (x + y) * twopk;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function fround(x: f32): f32 {\n    return x;\n  }\n\n  export function hypot(x: f32, y: f32): f32 { // see: musl/src/math/hypotf.c\n    const\n      Ox1p90f  = reinterpret<f32>(0x6C800000),\n      Ox1p_90f = reinterpret<f32>(0x12800000);\n\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    ux &= 0x7FFFFFFF;\n    uy &= 0x7FFFFFFF;\n    if (ux < uy) {\n      let ut = ux;\n      ux = uy;\n      uy = ut;\n    }\n    x = reinterpret<f32>(ux);\n    y = reinterpret<f32>(uy);\n    if (uy == 0xFF << 23) return y;\n    if (ux >= 0xFF << 23 || uy == 0 || ux - uy >= 25 << 23) return x + y;\n    var z: f32 = 1;\n    if (ux >= (0x7F + 60) << 23) {\n      z  = Ox1p90f;\n      x *= Ox1p_90f;\n      y *= Ox1p_90f;\n    } else if (uy < (0x7F - 60) << 23) {\n      z  = Ox1p_90f;\n      x *= Ox1p90f;\n      y *= Ox1p90f;\n    }\n    return z * builtin_sqrt<f32>(<f32>(<f64>x * x + <f64>y * y));\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function imul(x: f32, y: f32): f32 {\n    /*\n     * Wasm (MVP) and JS have different approaches for double->int conversions.\n     *\n     * For emulate JS conversion behavior and avoid trapping from wasm we should modulate by MAX_INT\n     * our float-point arguments before actual convertion to integers.\n     */\n    if (!isFinite(x + y)) return 0;\n    return <f32>(dtoi32(x) * dtoi32(y));\n  }\n\n  export function log(x: f32): f32 { // see: musl/src/math/logf.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return logf_lut(x);\n    } else {\n      const\n        ln2_hi  = reinterpret<f32>(0x3F317180), // 6.9313812256e-01f\n        ln2_lo  = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06f\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f\n        Lg4     = reinterpret<f32>(0x3E789E26), // 0xf89e26.0p-26f\n        Ox1p25f = reinterpret<f32>(0x4C000000);\n\n      let u = reinterpret<u32>(x);\n      let k = 0;\n      if (u < 0x00800000 || <bool>(u >> 31)) {\n        if (u << 1 == 0) return -1 / (x * x);\n        if (u >> 31) return (x - x) / 0;\n        k -= 25;\n        x *= Ox1p25f;\n        u = reinterpret<u32>(x);\n      } else if (u >= 0x7F800000) {\n        return x;\n      } else if (u == 0x3F800000) {\n        return 0;\n      }\n      u += 0x3F800000 - 0x3F3504F3;\n      k += <u32>(<i32>u >> 23) - 0x7F;\n      u = (u & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(u);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq = <f32>0.5 * f * f;\n      let dk = <f32>k;\n      return s * (hfsq + r) + dk * ln2_lo - hfsq + f + dk * ln2_hi;\n    }\n  }\n\n  export function log10(x: f32): f32 { // see: musl/src/math/log10f.c and SUN COPYRIGHT NOTICE above\n    const\n      ivln10hi  = reinterpret<f32>(0x3EDE6000), //  4.3432617188e-01f\n      ivln10lo  = reinterpret<f32>(0xB804EAD9), // -3.1689971365e-05f\n      log10_2hi = reinterpret<f32>(0x3E9A2080), //  3.0102920532e-01f\n      log10_2lo = reinterpret<f32>(0x355427DB), //  7.9034151668e-07f\n      Lg1       = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2       = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n      Lg3       = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n      Lg4       = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n      Ox1p25f   = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n    var ix = reinterpret<u32>(x);\n    var k = 0;\n    if (ix < 0x00800000 || <bool>(ix >> 31)) {\n      if (ix << 1 == 0) return -1 / (x * x);\n      if (ix >> 31) return (x - x) / 0.0;\n      k -= 25;\n      x *= Ox1p25f;\n      ix = reinterpret<u32>(x);\n    } else if (ix >= 0x7F800000) {\n      return x;\n    } else if (ix == 0x3F800000) {\n      return 0;\n    }\n    ix += 0x3F800000 - 0x3F3504F3;\n    k += <i32>(ix >> 23) - 0x7F;\n    ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n    x = reinterpret<f32>(ix);\n    var f = x - 1.0;\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var hi = f - hfsq;\n    ix = reinterpret<u32>(hi);\n    ix &= 0xFFFFF000;\n    hi = reinterpret<f32>(ix);\n    var lo = f - hi - hfsq + s * (hfsq + r);\n    var dk = <f32>k;\n    return dk * log10_2lo + (lo + hi) * ivln10lo + lo * ivln10hi + hi * ivln10hi + dk * log10_2hi;\n  }\n\n  export function log1p(x: f32): f32 { // see: musl/src/math/log1pf.c and SUN COPYRIGHT NOTICE above\n    const\n      ln2_hi = reinterpret<f32>(0x3F317180), // 6.9313812256e-01\n      ln2_lo = reinterpret<f32>(0x3717F7D1), // 9.0580006145e-06\n      Lg1    = reinterpret<f32>(0x3F2AAAAA), // 0xaaaaaa.0p-24f, 0.66666662693f\n      Lg2    = reinterpret<f32>(0x3ECCCE13), // 0xccce13.0p-25f, 0.40000972152f\n      Lg3    = reinterpret<f32>(0x3E91E9EE), // 0x91e9ee.0p-25f, 0.28498786688f\n      Lg4    = reinterpret<f32>(0x3E789E26); // 0xf89e26.0p-26f, 0.24279078841f\n\n    var ix = reinterpret<u32>(x);\n    var c: f32 = 0, f: f32 = 0;\n    var k: i32 = 1;\n    if (ix < 0x3ED413D0 || <bool>(ix >> 31)) {\n      if (ix >= 0xBF800000) {\n        if (x == -1) return x / 0.0;\n        return (x - x) / 0.0;\n      }\n      if (ix << 1 < 0x33800000 << 1) return x;\n      if (ix <= 0xBE95F619) {\n        k = 0;\n        c = 0;\n        f = x;\n      }\n    } else if (ix >= 0x7F800000) return x;\n    if (k) {\n      let uf: f32 = 1 + x;\n      let iu = reinterpret<u32>(uf);\n      iu += 0x3F800000 - 0x3F3504F3;\n      k = <i32>(iu >> 23) - 0x7F;\n      if (k < 25) {\n        c = k >= 2 ? 1 - (uf - x) : x - (uf - 1);\n        c /= uf;\n      } else c = 0;\n      iu = (iu & 0x007FFFFF) + 0x3F3504F3;\n      f = reinterpret<f32>(iu) - 1;\n    }\n    var s = f / (2.0 + f);\n    var z = s * s;\n    var w = z * z;\n    var t1 = w * (Lg2 + w * Lg4);\n    var t2 = z * (Lg1 + w * Lg3);\n    var r = t2 + t1;\n    var hfsq: f32 = 0.5 * f * f;\n    var dk = <f32>k;\n    return s * (hfsq + r) + (dk * ln2_lo + c) - hfsq + f + dk * ln2_hi;\n  }\n\n  export function log2(x: f32): f32 { // see: musl/src/math/log2f.c and SUN COPYRIGHT NOTICE above\n    if (ASC_SHRINK_LEVEL < 1) {\n      return log2f_lut(x);\n    } else {\n      const\n        ivln2hi = reinterpret<f32>(0x3FB8B000), //  1.4428710938e+00f\n        ivln2lo = reinterpret<f32>(0xB9389AD4), // -1.7605285393e-04\n        Lg1     = reinterpret<f32>(0x3F2AAAAA), //  0xaaaaaa.0p-24f, 0.66666662693f\n        Lg2     = reinterpret<f32>(0x3ECCCE13), //  0xccce13.0p-25f, 0.40000972152f\n        Lg3     = reinterpret<f32>(0x3E91E9EE), //  0x91e9ee.0p-25f, 0.28498786688f\n        Lg4     = reinterpret<f32>(0x3E789E26), //  0xf89e26.0p-26f, 0.24279078841f\n        Ox1p25f = reinterpret<f32>(0x4C000000); //  0x1p25f\n\n      let ix = reinterpret<u32>(x);\n      let k: i32 = 0;\n      if (ix < 0x00800000 || <bool>(ix >> 31)) {\n        if (ix << 1 == 0) return -1 / (x * x);\n        if (ix >> 31) return (x - x) / 0.0;\n        k -= 25;\n        x *= Ox1p25f;\n        ix = reinterpret<u32>(x);\n      } else if (ix >= 0x7F800000) {\n        return x;\n      } else if (ix == 0x3F800000) {\n        return 0;\n      }\n      ix += 0x3F800000 - 0x3F3504F3;\n      k += <i32>(ix >> 23) - 0x7F;\n      ix = (ix & 0x007FFFFF) + 0x3F3504F3;\n      x = reinterpret<f32>(ix);\n      let f = x - 1.0;\n      let s = f / (2.0 + f);\n      let z = s * s;\n      let w = z * z;\n      let t1 = w * (Lg2 + w * Lg4);\n      let t2 = z * (Lg1 + w * Lg3);\n      let r = t2 + t1;\n      let hfsq: f32 = 0.5 * f * f;\n      let hi = f - hfsq;\n      let u = reinterpret<u32>(hi);\n      u &= 0xFFFFF000;\n      hi = reinterpret<f32>(u);\n      let lo: f32 = f - hi - hfsq + s * (hfsq + r);\n      let dk = <f32>k;\n      return (lo + hi) * ivln2lo + lo * ivln2hi + hi * ivln2hi + dk;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function max(value1: f32, value2: f32): f32 {\n    return builtin_max<f32>(value1, value2);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function min(value1: f32, value2: f32): f32 {\n    return builtin_min<f32>(value1, value2);\n  }\n\n  export function pow(x: f32, y: f32): f32 {\n    // TODO: remove this fast pathes after introduced own mid-end IR with \"stdlib call simplify\" transforms\n    if (builtin_abs<f32>(y) <= 2) {\n      if (y == 2.0) return x * x;\n      if (y == 0.5) {\n        return select<f32>(\n          builtin_abs<f32>(builtin_sqrt<f32>(x)),\n          Infinity,\n          x != -Infinity\n        );\n      }\n      if (y == -1.0) return 1 / x;\n      if (y == 1.0) return x;\n      if (y == 0.0) return 1.0;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      // see: musl/src/math/powf.c\n      return powf_lut(x, y);\n    } else {\n      // based on:  jdh8/metallic/src/math/float/powf.c\n      if (y == 0) return 1;\n      // @ts-ignore: cast\n      if (isNaN(x) | isNaN(y)) {\n        return NaN;\n      }\n      let sign: u32 = 0;\n      let uy = reinterpret<u32>(y);\n      let ux = reinterpret<u32>(x);\n      let sx = ux >> 31;\n      ux &= 0x7FFFFFFF;\n      if (sx && nearest(y) == y) {\n        x = -x;\n        sx = 0;\n        sign = u32(nearest(y * 0.5) != y * 0.5) << 31;\n      }\n      let m: u32;\n      if (ux == 0x3F800000) { // x == 1\n        m = sx | u32((uy & 0x7FFFFFFF) == 0x7F800000) ? 0x7FC00000 : 0x3F800000;\n      } else if (ux == 0) {\n        m = uy >> 31 ? 0x7F800000 : 0;\n      } else if (ux == 0x7F800000) {\n        m = uy >> 31 ? 0 : 0x7F800000;\n      } else if (sx) {\n        m = 0x7FC00000;\n      } else {\n        m = reinterpret<u32>(<f32>exp2f(<f64>y * log2f(x)));\n      }\n      return reinterpret<f32>(m | sign);\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function seedRandom(value: i64): void {\n    NativeMath.seedRandom(value);\n  }\n\n  // Using xoroshiro64starstar from http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n  export function random(): f32 {\n    if (!random_seeded) seedRandom(reinterpret<i64>(seed()));\n\n    var s0 = random_state0_32;\n    var s1 = random_state1_32;\n    var r  = rotl<u32>(s0 * 0x9E3779BB, 5) * 5;\n\n    s1 ^= s0;\n    random_state0_32 = rotl<u32>(s0, 26) ^ s1 ^ (s1 << 9);\n    random_state1_32 = rotl<u32>(s1, 13);\n\n    return reinterpret<f32>((r >> 9) | (127 << 23)) - 1.0;\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function round(x: f32): f32 {\n    return builtin_copysign<f32>(builtin_floor<f32>(x + 0.5), x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sign(x: f32): f32 {\n    if (ASC_SHRINK_LEVEL > 0) {\n      return builtin_abs(x) > 0 ? builtin_copysign<f32>(1, x) : x;\n    } else {\n      return x > 0 ? 1 : x < 0 ? -1 : x;\n    }\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function signbit(x: f32): bool {\n    return <bool>(reinterpret<u32>(x) >>> 31);\n  }\n\n  export function sin(x: f32): f32 { // see: musl/src/math/sinf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // M_PI_2 * 1\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // M_PI_2 * 2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // M_PI_2 * 3\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // M_PI_2 * 4\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return sin_kernf(x);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3/4\n          return sign ? -cos_kernf(x + s1pio2) : cos_kernf(x - s1pio2);\n        }\n        return sin_kernf(-(sign ? x + s2pio2 : x - s2pio2));\n      }\n\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7/4\n          return sign ? cos_kernf(x + s3pio2) : -cos_kernf(x - s3pio2);\n        }\n        return sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n      }\n    }\n\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n\n    var t = n & 1 ? cos_kernf(y) : sin_kernf(y);\n    return n & 2 ? -t : t;\n  }\n\n  export function sinh(x: f32): f32 { // see: musl/src/math/sinhf.c\n    var u = reinterpret<u32>(x) & 0x7FFFFFFF;\n    var a = reinterpret<f32>(u);\n    var h = builtin_copysign<f32>(0.5, x);\n    if (u < 0x42B17217) {\n      let t = expm1(a);\n      if (u < 0x3F800000) {\n        if (u < 0x3F800000 - (12 << 23)) return x;\n        return h * (2 * t - t * t / (t + 1));\n      }\n      return h * (t + t / (t + 1));\n    }\n    return expo2f(a, 2 * h);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function sqrt(x: f32): f32 {\n    return builtin_sqrt<f32>(x);\n  }\n\n  export function tan(x: f32): f32 { // see: musl/src/math/tanf.c\n    const\n      t1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      t2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      t3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      t4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        return x;\n      }\n      return tan_kernf(x, 0);\n    }\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3/4\n          return tan_kernf((sign ? x + t1pio2 : x - t1pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t2pio2 : x - t2pio2), 0);\n        }\n      }\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7/4\n          return tan_kernf((sign ? x + t3pio2 : x - t3pio2), 1);\n        } else {\n          return tan_kernf((sign ? x + t4pio2 : x - t4pio2), 0);\n        }\n      }\n    }\n\n    // tan(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) return x - x;\n\n    // argument reduction\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    return tan_kernf(y, n & 1);\n  }\n\n  export function tanh(x: f32): f32 { // see: musl/src/math/tanhf.c\n    var u = reinterpret<u32>(x);\n    u &= 0x7FFFFFFF;\n    var y = reinterpret<f32>(u);\n    var t: f32;\n    if (u > 0x3F0C9F54) {\n      if (u > 0x41200000) t = 1 + 0 / y;\n      else {\n        t = expm1(2 * y);\n        t = 1 - 2 / (t + 2);\n      }\n    } else if (u > 0x3E82C578) {\n      t = expm1(2 * y);\n      t = t / (t + 2);\n    } else if (u >= 0x00800000) {\n      t = expm1(-2 * y);\n      t = -t / (t + 2);\n    } else t = y;\n    return builtin_copysign<f32>(t, x);\n  }\n\n  // @ts-ignore: decorator\n  @inline\n  export function trunc(x: f32): f32 {\n    return builtin_trunc<f32>(x);\n  }\n\n  export function scalbn(x: f32, n: i32): f32 { // see: https://git.musl-libc.org/cgit/musl/tree/src/math/scalbnf.c\n    const\n      Ox1p24f   = reinterpret<f32>(0x4B800000),\n      Ox1p127f  = reinterpret<f32>(0x7F000000),\n      Ox1p_126f = reinterpret<f32>(0x00800000);\n\n    var y = x;\n    if (n > 127) {\n      y *= Ox1p127f;\n      n -= 127;\n      if (n > 127) {\n        y *= Ox1p127f;\n        n = builtin_min<i32>(n - 127, 127);\n      }\n    } else if (n < -126) {\n      y *= Ox1p_126f * Ox1p24f;\n      n += 126 - 24;\n      if (n < -126) {\n        y *= Ox1p_126f * Ox1p24f;\n        n = builtin_max<i32>(n + 126 - 24, -126);\n      }\n    }\n    return y * reinterpret<f32>(<u32>(0x7F + n) << 23);\n  }\n\n  export function mod(x: f32, y: f32): f32 { // see: musl/src/math/fmodf.c\n    if (builtin_abs<f32>(y) == 1.0) {\n      // x % 1, x % -1  ==>  sign(x) * abs(x - 1.0 * trunc(x / 1.0))\n      // TODO: move this rule to compiler's optimization pass.\n      // It could be apply for any x % C_pot, where \"C_pot\" is pow of two const.\n      return builtin_copysign<f32>(x - builtin_trunc<f32>(x), x);\n    }\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sm = ux & 0x80000000;\n    var uy1 = uy << 1;\n    if (uy1 == 0 || ex == 0xFF || isNaN<f32>(y)) {\n      let m = x * y;\n      return m / m;\n    }\n    var ux1 = ux << 1;\n    if (ux1 <= uy1) {\n      return x * f32(ux1 != uy1);\n    }\n    if (!ex) {\n      ex -= builtin_clz<u32>(ux << 9);\n      ux <<= 1 - ex;\n    } else {\n      ux &= <u32>-1 >> 9;\n      ux |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    while (ex > ey) {\n      if (ux >= uy) {\n        if (ux == uy) return 0 * x;\n        ux -= uy;\n      }\n      ux <<= 1;\n      --ex;\n    }\n    if (ux >= uy) {\n      if (ux == uy) return 0 * x;\n      ux -= uy;\n    }\n    // for (; !(ux >> 23); ux <<= 1) --ex;\n    var shift = <i32>builtin_clz<u32>(ux << 8);\n    ex -= shift;\n    ux <<= shift;\n    if (ex > 0) {\n      ux -= 1 << 23;\n      ux |= <u32>ex << 23;\n    } else {\n      ux >>= -ex + 1;\n    }\n    return reinterpret<f32>(ux | sm);\n  }\n\n  export function rem(x: f32, y: f32): f32 { // see: musl/src/math/remquof.c\n    var ux = reinterpret<u32>(x);\n    var uy = reinterpret<u32>(y);\n    var ex = <i32>(ux >> 23 & 0xFF);\n    var ey = <i32>(uy >> 23 & 0xFF);\n    var sx = <i32>(ux >> 31);\n    var uxi = ux;\n    if (uy << 1 == 0 || ex == 0xFF || isNaN(y)) return (x * y) / (x * y);\n    if (ux << 1 == 0) return x;\n    if (!ex) {\n      ex -= builtin_clz<u32>(uxi << 9);\n      uxi <<= 1 - ex;\n    } else {\n      uxi &= <u32>-1 >> 9;\n      uxi |= 1 << 23;\n    }\n    if (!ey) {\n      ey -= builtin_clz<u32>(uy << 9);\n      uy <<= 1 - ey;\n    } else {\n      uy &= <u32>-1 >> 9;\n      uy |= 1 << 23;\n    }\n    var q = 0;\n    do {\n      if (ex < ey) {\n        if (ex + 1 == ey) break; // goto end\n        return x;\n      }\n      while (ex > ey) {\n        if (uxi >= uy) {\n          uxi -= uy;\n          ++q;\n        }\n        uxi <<= 1;\n        q <<= 1;\n        --ex;\n      }\n      if (uxi >= uy) {\n        uxi -= uy;\n        ++q;\n      }\n      if (uxi == 0) ex = -30;\n      else {\n        let shift = builtin_clz<i32>(uxi << 8);\n        ex -= shift;\n        uxi <<= shift;\n      }\n      break;\n    } while (false);\n    // end:\n    if (ex > 0) {\n      uxi -= 1 << 23;\n      uxi |= <u32>ex << 23;\n    } else {\n      uxi >>= -ex + 1;\n    }\n    x = reinterpret<f32>(uxi);\n    y = builtin_abs<f32>(y);\n    var x2 = x + x;\n    if (ex == ey || (ex + 1 == ey && (<f32>x2 > y || (<f32>x2 == y && <bool>(q & 1))))) {\n      x -= y;\n      // q++;\n    }\n    return sx ? -x : x;\n  }\n\n  export function sincos(x: f32): void { // see: musl/tree/src/math/sincosf.c\n    const\n      s1pio2 = reinterpret<f64>(0x3FF921FB54442D18), // 1 * M_PI_2\n      s2pio2 = reinterpret<f64>(0x400921FB54442D18), // 2 * M_PI_2\n      s3pio2 = reinterpret<f64>(0x4012D97C7F3321D2), // 3 * M_PI_2\n      s4pio2 = reinterpret<f64>(0x401921FB54442D18); // 4 * M_PI_2\n\n    var ix = reinterpret<u32>(x);\n    var sign = ix >> 31;\n    ix &= 0x7FFFFFFF;\n\n    if (ix <= 0x3F490FDA) {  // |x| ~<= /4\n      if (ix < 0x39800000) { // |x| < 2**-12\n        sincos_sin = x;\n        sincos_cos = 1;\n        return;\n      }\n      sincos_sin = sin_kernf(x);\n      sincos_cos = cos_kernf(x);\n      return;\n    }\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (ix <= 0x407B53D1) {   // |x| ~<= 5/4\n        if (ix <= 0x4016CBE3) { // |x| ~<= 3/4\n          if (sign) {\n            sincos_sin = -cos_kernf(x + s1pio2);\n            sincos_cos =  sin_kernf(x + s1pio2);\n          } else {\n            sincos_sin = cos_kernf(s1pio2 - x);\n            sincos_cos = sin_kernf(s1pio2 - x);\n          }\n          return;\n        }\n        // -sin(x + c) is not correct if x+c could be 0: -0 vs +0\n        sincos_sin = -sin_kernf(sign ? x + s2pio2 : x - s2pio2);\n        sincos_cos = -cos_kernf(sign ? x + s2pio2 : x - s2pio2);\n        return;\n      }\n      if (ix <= 0x40E231D5) {   // |x| ~<= 9/4\n        if (ix <= 0x40AFEDDF) { // |x| ~<= 7/4\n          if (sign) {\n            sincos_sin =  cos_kernf(x + s3pio2);\n            sincos_cos = -sin_kernf(x + s3pio2);\n          } else {\n            sincos_sin = -cos_kernf(x - s3pio2);\n            sincos_cos =  sin_kernf(x - s3pio2);\n          }\n          return;\n        }\n        sincos_sin = sin_kernf(sign ? x + s4pio2 : x - s4pio2);\n        sincos_cos = cos_kernf(sign ? x + s4pio2 : x - s4pio2);\n        return;\n      }\n    }\n    // sin(Inf or NaN) is NaN\n    if (ix >= 0x7F800000) {\n      let xx = x - x;\n      sincos_sin = xx;\n      sincos_cos = xx;\n      return;\n    }\n    // general argument reduction needed\n    var n = rempio2f(x, ix, sign);\n    var y = rempio2f_y;\n    var s = sin_kernf(y);\n    var c = cos_kernf(y);\n    var sin = s, cos = c;\n    if (n & 1) {\n      sin =  c;\n      cos = -s;\n    }\n    if (n & 2) {\n      sin = -sin;\n      cos = -cos;\n    }\n    sincos_sin = sin;\n    sincos_cos = cos;\n  }\n}\n\nexport function ipow32(x: i32, e: i32): i32 {\n  var out = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i32>(1 << e, 0, <u32>e < 32);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i32>(-1, 1, e & 1);\n      return i32(e == 0) | i32(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 32) {\n      let log = 32 - clz(e);\n      // 32 = 2 ^ 5, so need only five cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\nexport function ipow64(x: i64, e: i64): i64 {\n  var out: i64 = 1;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (x == 2) {\n      return select<i64>(1 << e, 0, <u64>e < 64);\n    }\n    if (e <= 0) {\n      if (x == -1) return select<i64>(-1, 1, e & 1);\n      return i64(e == 0) | i64(x == 1);\n    }\n    else if (e == 1) return x;\n    else if (e == 2) return x * x;\n    else if (e < 64) {\n      let log = 64 - <i32>clz(e);\n      // 64 = 2 ^ 6, so need only six cases.\n      // But some extra cases needs for properly overflowing\n      switch (log) {\n        case 6: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 5: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 4: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 3: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 2: {\n          if (e & 1) out *= x;\n          e >>>= 1;\n          x *= x;\n        }\n        case 1: {\n          if (e & 1) out *= x;\n        }\n      }\n      return out;\n    }\n  }\n  while (e) {\n    if (e & 1) out *= x;\n    e >>>= 1;\n    x *= x;\n  }\n  return out;\n}\n\n/*\nTODO:\nIn compile time if only exponent is constant we could replace ipow32/ipow64 by shortest addition chains\nwhich usually faster than exponentiation by squaring\n\nfor ipow32 and e < 32:\n\nlet b: i32, c: i32, d: i32, h: i32, k: i32, g: i32;\nswitch (e) {\n  case  1: return x;\n  case  2: return x * x;\n  case  3: return x * x * x;\n  case  4: return (b = x * x) * b;\n  case  5: return (b = x * x) * b * x;\n  case  6: return (b = x * x) * b * b;\n  case  7: return (b = x * x) * b * b * x;\n  case  8: return (d = (b = x * x) * b) * d;\n  case  9: return (c = x * x * x) * c * c;\n  case 10: return (d = (b = x * x) * b) * d * b;\n  case 11: return (d = (b = x * x) * b) * d * b * x;\n  case 12: return (d = (b = x * x) * b) * d * d;\n  case 13: return (d = (b = x * x) * b) * d * d * x;\n  case 14: return (d = (b = x * x) * b) * d * d * b;\n  case 15: return (k = (b = x * x) * b * x) * k * k;\n  case 16: return (h = (d = (b = x * x) * b) * d) * h;\n  case 17: return (h = (d = (b = x * x) * b) * d) * h * x;\n  case 18: return (h = (d = (b = x * x) * b) * d * x) * h;\n  case 19: return (h = (d = (b = x * x) * b) * d * x) * h * x;\n  case 20: return (h = (k = (b = x * x) * b * x) * k) * h;\n  case 21: return (h = (k = (b = x * x) * b * x) * k) * h * x;\n  case 22: return (g = (h = (k = (b = x * x) * b * x) * k) * x) * g;\n  case 23: return (h = (d = (c = (b = x * x) * x) * b) * d) * h * c;\n  case 24: return (h = (d = (c = x * x * x) * c) * d) * h;\n  case 25: return (h = (d = (c = x * x * x) * c) * d) * h * x;\n  case 26: return (g = (h = (d = (c = x * x * x) * c) * d) * x) * g;\n  case 27: return (h = (d = (c = x * x * x) * c) * d) * h * c;\n  case 28: return (h = (d = (c = x * x * x) * c * x) * d) * h;\n  case 29: return (h = (d = (c = x * x * x) * c * x) * d) * h * x;\n  case 30: return (h = (d = (c = x * x * x) * c) * d * c) * h;\n  case 31: return (h = (d = (c = x * x * x) * c) * d * c) * h * x;\n}\n\nfor ipow64: TODO\nswitch (e) {\n  case 32:\n  ...\n  case 63:\n}\n*/\n","import { RenderContext } from \"./RenderContext\";\r\nimport { ImageData, WebGLProgram, WebGLUniformLocation, WebGLBuffer, GLint, WebGLTexture } from \"./WebGL\";\r\nimport { consoleLog } from \"../../netcode/netcode\";\r\nimport { RenderColor } from \"./RenderCommon\";\r\n\r\nconst kVertexShaderCode: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    attribute vec2 a_position;\r\n    attribute vec2 a_texcoord;\r\n    uniform vec2 u_xy;\r\n    uniform float u_scale;\r\n\r\n    // Output to fragment shader:\r\n    varying vec2 uv_coord;\r\n\r\n    void main() {\r\n        uv_coord = a_texcoord;\r\n        vec2 p = a_position * u_scale + u_xy;\r\n        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);\r\n    }\r\n`;\r\n\r\nconst kFragmentShaderCode: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    uniform vec3 u_foreground_color;\r\n    uniform vec3 u_stroke_color;\r\n\r\n    // Input from vertex shader:\r\n    uniform sampler2D u_sampler;\r\n    varying vec2 uv_coord;\r\n\r\n    void main() {\r\n        float sample = texture2D(u_sampler, uv_coord).r;\r\n\r\n        float dist = (sample - 0.5) * 16.0 + 0.5;\r\n\r\n        // Stroked text\r\n        float stroke_alpha = clamp(dist, 0.0, 1.0);\r\n        float back_alpha = clamp(dist + 0.5, 0.0, 1.0);\r\n\r\n        vec3 inner_color = mix(u_stroke_color, u_foreground_color, stroke_alpha);\r\n        gl_FragColor = vec4(inner_color, back_alpha);\r\n    }\r\n`;\r\n\r\n// One letter from the SDF JSON\r\nclass Letter {\r\n    // Offset to letter image\r\n    x: i32;\r\n    y: i32;\r\n\r\n    // Letter image size in pixels\r\n    w: i32;\r\n    h: i32;\r\n\r\n    // Offset from (x,y) to anchor (center/bottom) point on letter\r\n    originX: i32;\r\n    originY: i32;\r\n\r\n    // Offset between letters\r\n    advance: i32;\r\n\r\n    constructor(x: i32, y: i32, w: i32, h: i32, originX: i32, originY: i32, advance: i32) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.w = w;\r\n        this.h = h;\r\n        this.originX = originX;\r\n        this.originY = originY;\r\n        this.advance = advance;\r\n    }\r\n}\r\n\r\n// Data generated by RenderTextProgram and cached for each use\r\nexport class RenderTextData {\r\n    vertices: StaticArray<f32>;\r\n    indices: StaticArray<u16>;\r\n    width: f32;\r\n    height: f32;\r\n\r\n    constructor(quad_count: i32) {\r\n        // (x, y, u, v) * 4 per quad\r\n        this.vertices = new StaticArray<f32>(quad_count * 4 * 4);\r\n        // 6 indices per quad\r\n        this.indices = new StaticArray<u16>(quad_count * 6);\r\n    }\r\n}\r\n\r\nexport enum RenderTextHorizontal {\r\n    Left,\r\n    Center,\r\n    Right\r\n}\r\n\r\nexport enum RenderTextVertical {\r\n    Top,\r\n    Center,\r\n    Bottom\r\n}\r\n\r\n// Render program shared between all texts\r\nexport class RenderTextProgram {\r\n    image: ImageData;\r\n    texture_ready: bool = false;\r\n    texture: WebGLTexture;\r\n\r\n    texture_w: i32;\r\n    texture_h: i32;\r\n    letters: Map<i32, Letter> = new Map<i32, Letter>();\r\n    ws_advance: i32;\r\n    font_y_offset: i32;\r\n    font_h: i32;\r\n    scale_y_factor: f32;\r\n\r\n    shader_program: WebGLProgram;\r\n\r\n    // Vertex shader attributes/uniforms:\r\n    a_position: GLint;\r\n    a_texcoord: GLint;\r\n    u_xy: WebGLUniformLocation;\r\n    u_scale: WebGLUniformLocation;\r\n\r\n    // Fragment shader uniforms:\r\n    u_foreground_color: WebGLUniformLocation;\r\n    u_stroke_color: WebGLUniformLocation;\r\n    u_sampler: WebGLUniformLocation;\r\n\r\n    vertices_buffer: WebGLBuffer;\r\n    indices_buffer: WebGLBuffer;\r\n\r\n    InitFont(): void {\r\n        // Added by hand\r\n        this.ws_advance = 19;\r\n        this.font_y_offset = 28;\r\n        this.font_h = 35;\r\n        this.scale_y_factor = f32(this.font_h) / f32(this.ws_advance);\r\n\r\n        // Generated by `node scripts/convert_font_json.js`\r\n        this.texture_w = 1024\r\n        this.texture_h = 128\r\n        this.letters.set(48, new Letter(898, 0, 29, 37, 5, 30, 19));\r\n        this.letters.set(49, new Letter(617, 46, 28, 36, 4, 29, 19));\r\n        this.letters.set(50, new Letter(29, 46, 28, 37, 5, 30, 19));\r\n        this.letters.set(51, new Letter(927, 0, 29, 37, 5, 30, 19));\r\n        this.letters.set(52, new Letter(956, 0, 29, 37, 5, 30, 19));\r\n        this.letters.set(53, new Letter(57, 46, 28, 37, 5, 29, 19));\r\n        this.letters.set(54, new Letter(985, 0, 29, 37, 5, 30, 19));\r\n        this.letters.set(55, new Letter(85, 46, 28, 37, 4, 29, 19));\r\n        this.letters.set(56, new Letter(808, 0, 30, 37, 5, 30, 19));\r\n        this.letters.set(57, new Letter(545, 0, 29, 38, 5, 30, 19));\r\n        this.letters.set(33, new Letter(169, 46, 19, 37, 0, 29, 19));\r\n        this.letters.set(34, new Letter(445, 83, 23, 22, 2, 31, 19));\r\n        this.letters.set(35, new Letter(412, 46, 30, 36, 5, 29, 19));\r\n        this.letters.set(36, new Letter(0, 0, 29, 46, 5, 34, 19));\r\n        this.letters.set(37, new Letter(482, 0, 33, 38, 7, 30, 19));\r\n        this.letters.set(38, new Letter(715, 0, 31, 37, 5, 30, 19));\r\n        this.letters.set(39, new Letter(468, 83, 18, 22, -1, 31, 19));\r\n        this.letters.set(40, new Letter(105, 0, 24, 46, 3, 34, 19));\r\n        this.letters.set(41, new Letter(129, 0, 24, 46, 2, 34, 19));\r\n        this.letters.set(42, new Letter(308, 83, 31, 30, 6, 26, 19));\r\n        this.letters.set(43, new Letter(339, 83, 30, 29, 5, 24, 19));\r\n        this.letters.set(44, new Letter(369, 83, 20, 25, 1, 12, 19));\r\n        this.letters.set(45, new Letter(590, 83, 27, 16, 4, 18, 19));\r\n        this.letters.set(46, new Letter(508, 83, 20, 20, 0, 12, 19));\r\n        this.letters.set(47, new Letter(153, 0, 30, 44, 5, 33, 19));\r\n        this.letters.set(58, new Letter(288, 83, 20, 31, 0, 24, 19));\r\n        this.letters.set(59, new Letter(838, 46, 20, 36, 1, 23, 19));\r\n        this.letters.set(60, new Letter(945, 46, 28, 32, 4, 26, 19));\r\n        this.letters.set(61, new Letter(418, 83, 27, 22, 4, 21, 19));\r\n        this.letters.set(62, new Letter(973, 46, 28, 32, 4, 26, 19));\r\n        this.letters.set(63, new Letter(113, 46, 28, 37, 4, 30, 19));\r\n        this.letters.set(64, new Letter(307, 0, 33, 40, 7, 30, 19));\r\n        this.letters.set(65, new Letter(221, 46, 32, 36, 6, 29, 19));\r\n        this.letters.set(66, new Letter(472, 46, 29, 36, 4, 29, 19));\r\n        this.letters.set(67, new Letter(746, 0, 31, 37, 5, 30, 19));\r\n        this.letters.set(68, new Letter(501, 46, 29, 36, 4, 29, 19));\r\n        this.letters.set(69, new Letter(757, 46, 27, 36, 3, 29, 19));\r\n        this.letters.set(70, new Letter(645, 46, 28, 36, 3, 29, 19));\r\n        this.letters.set(71, new Letter(838, 0, 30, 37, 6, 30, 19));\r\n        this.letters.set(72, new Letter(673, 46, 28, 36, 4, 29, 19));\r\n        this.letters.set(73, new Letter(784, 46, 27, 36, 4, 29, 19));\r\n        this.letters.set(74, new Letter(141, 46, 28, 37, 5, 29, 19));\r\n        this.letters.set(75, new Letter(442, 46, 30, 36, 4, 29, 19));\r\n        this.letters.set(76, new Letter(811, 46, 27, 36, 3, 29, 19));\r\n        this.letters.set(77, new Letter(253, 46, 32, 36, 6, 29, 19));\r\n        this.letters.set(78, new Letter(701, 46, 28, 36, 4, 29, 19));\r\n        this.letters.set(79, new Letter(777, 0, 31, 37, 6, 30, 19));\r\n        this.letters.set(80, new Letter(729, 46, 28, 36, 3, 29, 19));\r\n        this.letters.set(81, new Letter(258, 0, 32, 43, 6, 30, 19));\r\n        this.letters.set(82, new Letter(530, 46, 29, 36, 4, 29, 19));\r\n        this.letters.set(83, new Letter(868, 0, 30, 37, 6, 30, 19));\r\n        this.letters.set(84, new Letter(381, 46, 31, 36, 6, 29, 19));\r\n        this.letters.set(85, new Letter(0, 46, 29, 37, 5, 29, 19));\r\n        this.letters.set(86, new Letter(285, 46, 32, 36, 6, 29, 19));\r\n        this.letters.set(87, new Letter(188, 46, 33, 36, 7, 29, 19));\r\n        this.letters.set(88, new Letter(317, 46, 32, 36, 6, 29, 19));\r\n        this.letters.set(89, new Letter(349, 46, 32, 36, 6, 29, 19));\r\n        this.letters.set(90, new Letter(559, 46, 29, 36, 5, 29, 19));\r\n        this.letters.set(91, new Letter(213, 0, 23, 44, 1, 34, 19));\r\n        this.letters.set(92, new Letter(183, 0, 30, 44, 5, 33, 19));\r\n        this.letters.set(93, new Letter(236, 0, 22, 44, 2, 34, 19));\r\n        this.letters.set(94, new Letter(389, 83, 29, 24, 5, 34, 19));\r\n        this.letters.set(95, new Letter(559, 83, 31, 16, 6, 3, 19));\r\n        this.letters.set(96, new Letter(486, 83, 22, 20, 1, 33, 19));\r\n        this.letters.set(97, new Letter(858, 46, 29, 32, 5, 24, 19));\r\n        this.letters.set(98, new Letter(399, 0, 28, 39, 4, 31, 19));\r\n        this.letters.set(99, new Letter(0, 83, 28, 32, 4, 24, 19));\r\n        this.letters.set(100, new Letter(427, 0, 28, 39, 5, 31, 19));\r\n        this.letters.set(101, new Letter(887, 46, 29, 32, 5, 24, 19));\r\n        this.letters.set(102, new Letter(574, 0, 29, 38, 4, 31, 19));\r\n        this.letters.set(103, new Letter(340, 0, 30, 40, 5, 26, 19));\r\n        this.letters.set(104, new Letter(688, 0, 27, 38, 4, 31, 19));\r\n        this.letters.set(105, new Letter(455, 0, 27, 39, 3, 32, 19));\r\n        this.letters.set(106, new Letter(29, 0, 26, 46, 4, 32, 19));\r\n        this.letters.set(107, new Letter(603, 0, 29, 38, 4, 31, 19));\r\n        this.letters.set(108, new Letter(370, 0, 29, 39, 5, 31, 19));\r\n        this.letters.set(109, new Letter(89, 83, 30, 31, 5, 24, 19));\r\n        this.letters.set(110, new Letter(207, 83, 27, 31, 4, 24, 19));\r\n        this.letters.set(111, new Letter(916, 46, 29, 32, 5, 24, 19));\r\n        this.letters.set(112, new Letter(632, 0, 28, 38, 4, 24, 19));\r\n        this.letters.set(113, new Letter(660, 0, 28, 38, 5, 24, 19));\r\n        this.letters.set(114, new Letter(179, 83, 28, 31, 4, 24, 19));\r\n        this.letters.set(115, new Letter(28, 83, 28, 32, 5, 24, 19));\r\n        this.letters.set(116, new Letter(588, 46, 29, 36, 5, 28, 19));\r\n        this.letters.set(117, new Letter(234, 83, 27, 31, 4, 24, 19));\r\n        this.letters.set(118, new Letter(119, 83, 30, 31, 5, 24, 19));\r\n        this.letters.set(119, new Letter(56, 83, 33, 31, 7, 24, 19));\r\n        this.letters.set(120, new Letter(149, 83, 30, 31, 5, 24, 19));\r\n        this.letters.set(121, new Letter(515, 0, 30, 38, 5, 24, 19));\r\n        this.letters.set(122, new Letter(261, 83, 27, 31, 4, 24, 19));\r\n        this.letters.set(123, new Letter(55, 0, 25, 46, 3, 34, 19));\r\n        this.letters.set(124, new Letter(290, 0, 17, 43, -1, 33, 19));\r\n        this.letters.set(125, new Letter(80, 0, 25, 46, 2, 34, 19));\r\n        this.letters.set(126, new Letter(528, 83, 31, 19, 6, 20, 19));\r\n    }\r\n\r\n    constructor(texture_image_location: string) {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        gl.getExtension('OES_standard_derivatives');\r\n        gl.getExtension('OES_texture_float_linear');\r\n        //gl.getExtension('OES_texture_border_clamp');\r\n\r\n        this.InitFont();\r\n\r\n        this.image = gl.createImage(texture_image_location);\r\n        this.texture = gl.createTexture();\r\n\r\n        const vertex_shader = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vertex_shader, kVertexShaderCode);\r\n        gl.compileShader(vertex_shader);\r\n        /*if (!gl.getShaderParameter(vertex_shader, gl.COMPILE_STATUS)) {\r\n            throw new Error(gl.getShaderInfoLog(vertex_shader));\r\n        }*/\r\n\r\n        const fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fragment_shader, kFragmentShaderCode);\r\n        gl.compileShader(fragment_shader);\r\n        /*if (!gl.getShaderParameter(fragment_shader, gl.COMPILE_STATUS)) {\r\n            throw new Error(gl.getShaderInfoLog(fragment_shader));\r\n        }*/\r\n\r\n        this.shader_program = gl.createProgram();\r\n        gl.attachShader(this.shader_program, vertex_shader);\r\n        gl.attachShader(this.shader_program, fragment_shader);\r\n        gl.linkProgram(this.shader_program);\r\n        gl.useProgram(this.shader_program);\r\n\r\n        this.a_position = gl.getAttribLocation(this.shader_program, \"a_position\");\r\n        this.a_texcoord = gl.getAttribLocation(this.shader_program, \"a_texcoord\");\r\n\r\n        this.u_xy = gl.getUniformLocation(this.shader_program, \"u_xy\");\r\n        this.u_scale = gl.getUniformLocation(this.shader_program, \"u_scale\");\r\n\r\n        this.u_foreground_color = gl.getUniformLocation(this.shader_program, \"u_foreground_color\");\r\n        this.u_stroke_color = gl.getUniformLocation(this.shader_program, \"u_stroke_color\");\r\n        this.u_sampler = gl.getUniformLocation(this.shader_program, \"u_sampler\");\r\n\r\n        this.vertices_buffer = gl.createBuffer();\r\n        this.indices_buffer = gl.createBuffer();\r\n    }\r\n\r\n    public BeginRender(): void {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        if (!gl.imageReady(this.image)) {\r\n            return;\r\n        }\r\n\r\n        gl.useProgram(this.shader_program);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        // Does not seem to be supported?\r\n        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        if (!this.texture_ready) {\r\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, +false);\r\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, +true);\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, this.image);\r\n\r\n            gl.uniform1i(this.u_sampler, 0);\r\n\r\n            this.texture_ready = true;\r\n        }\r\n\r\n        gl.enableVertexAttribArray(this.a_position);\r\n        gl.enableVertexAttribArray(this.a_texcoord);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n\r\n        // attribute | dimensions | data type | normalize | stride bytes | offset bytes\r\n        gl.vertexAttribPointer(this.a_position, 2, gl.FLOAT, +false, 16, 0);\r\n        gl.vertexAttribPointer(this.a_texcoord, 2, gl.FLOAT, +false, 16, 8);\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices_buffer);\r\n    }\r\n\r\n    public SetColor(\r\n        color: RenderColor,\r\n        stroke: RenderColor): void {\r\n        if (!this.texture_ready) {\r\n            return;\r\n        }\r\n\r\n        const gl = RenderContext.I.gl;\r\n\r\n        gl.uniform3f(this.u_foreground_color, color.r, color.g, color.b);\r\n        gl.uniform3f(this.u_stroke_color, stroke.r, stroke.g, stroke.b);\r\n    }\r\n\r\n    // Specify anchor point location for text\r\n    public GenerateLine(text: string): RenderTextData {\r\n        let count: i32 = 0;\r\n        for (let i: i32 = 0; i < text.length; ++i) {\r\n            const letter: i32 = text.charCodeAt(i);\r\n            if (this.letters.has(letter)) {\r\n                ++count;\r\n            }\r\n        }\r\n\r\n        // x | y | u | v\r\n        let data = new RenderTextData(count);\r\n        let vertices = data.vertices;\r\n        let indices = data.indices;\r\n\r\n        let index_offset: i32 = 0, vertex_offset: i32 = 0, vertex_index: i32 = 0;\r\n        let x: f32 = 0.0, y: f32 = 0.0;\r\n\r\n        const inv_w: f32 = 1.0 / f32(this.texture_w);\r\n        const inv_h: f32 = 1.0 / f32(this.texture_h);\r\n\r\n        for (let i: i32 = 0; i < text.length; ++i) {\r\n            const letter: i32 = text.charCodeAt(i);\r\n\r\n            if (!this.letters.has(letter)) {\r\n                x += 1.0;\r\n                continue;\r\n            }\r\n\r\n            const info = this.letters.get(letter);\r\n\r\n            const xy_left: f32 = x;\r\n            const xy_right: f32 = x + 1.0;\r\n            const xy_top: f32 = y;\r\n            const xy_bottom: f32 = y + this.scale_y_factor;\r\n\r\n            const uv_left: f32 = f32(info.x + info.originX) * inv_w;\r\n            const uv_right: f32 = uv_left + f32(info.advance) * inv_w;\r\n            const uv_top: f32 = f32(info.y + info.originY - this.font_y_offset) * inv_h;\r\n            const uv_bottom: f32 = uv_top + f32(this.font_h) * inv_h;\r\n\r\n            // 0: ul\r\n            vertices[vertex_offset + 0] = xy_left;\r\n            vertices[vertex_offset + 1] = xy_top;\r\n            vertices[vertex_offset + 2] = uv_left;\r\n            vertices[vertex_offset + 3] = uv_top;\r\n\r\n            // 1: ur\r\n            vertices[vertex_offset + 4] = xy_right;\r\n            vertices[vertex_offset + 5] = xy_top;\r\n            vertices[vertex_offset + 6] = uv_right;\r\n            vertices[vertex_offset + 7] = uv_top;\r\n\r\n            // 2: ll\r\n            vertices[vertex_offset + 8] = xy_left;\r\n            vertices[vertex_offset + 9] = xy_bottom;\r\n            vertices[vertex_offset + 10] = uv_left;\r\n            vertices[vertex_offset + 11] = uv_bottom;\r\n\r\n            // 3: lr\r\n            vertices[vertex_offset + 12] = xy_right;\r\n            vertices[vertex_offset + 13] = xy_bottom;\r\n            vertices[vertex_offset + 14] = uv_right;\r\n            vertices[vertex_offset + 15] = uv_bottom;\r\n\r\n            // triangle 0: ll, counter-clockwise winding\r\n            indices[index_offset + 0] = u16(vertex_index + 0);\r\n            indices[index_offset + 1] = u16(vertex_index + 2);\r\n            indices[index_offset + 2] = u16(vertex_index + 3);\r\n\r\n            // triangle 1: ur, counter-clockwise winding\r\n            indices[index_offset + 3] = u16(vertex_index + 0);\r\n            indices[index_offset + 4] = u16(vertex_index + 3);\r\n            indices[index_offset + 5] = u16(vertex_index + 1);\r\n\r\n            index_offset += 6;\r\n            vertex_offset += 16;\r\n            vertex_index += 4;\r\n\r\n            x += 1.0;\r\n        }\r\n\r\n        data.width = x;\r\n        data.height = this.scale_y_factor;\r\n\r\n        return data;\r\n    }\r\n\r\n    // Before calling Render(), call BeginRender() and SetColor().\r\n    // Multiply scale by 1/scale_y_factor to normalize by height instead of width.\r\n    // By default the x scale is 1.0 per character.\r\n    public Render(\r\n        align_x: RenderTextHorizontal, align_y: RenderTextVertical,\r\n        x: f32, y: f32,\r\n        scale: f32,\r\n        data: RenderTextData): void {\r\n        if (!this.texture_ready) {\r\n            return;\r\n        }\r\n\r\n        const gl = RenderContext.I.gl;\r\n\r\n        // Natural offset is upper left.\r\n        if (align_x == RenderTextHorizontal.Center) {\r\n            x -= data.width * 0.5 * scale;\r\n        } else if (align_x == RenderTextHorizontal.Right) {\r\n            x -= data.width * scale;\r\n        }\r\n        if (align_y == RenderTextVertical.Center) {\r\n            y -= data.height * 0.5 * scale;\r\n        } else if (align_y == RenderTextVertical.Bottom) {\r\n            y -= data.height * scale;\r\n        }\r\n\r\n        gl.uniform2f(this.u_xy, x, y);\r\n        gl.uniform1f(this.u_scale, scale);\r\n\r\n        // Use DYNAMIC_DRAW because we want to change this for each line we render\r\n        gl.bufferData<f32>(gl.ARRAY_BUFFER, data.vertices, gl.DYNAMIC_DRAW);\r\n        gl.bufferData<u16>(gl.ELEMENT_ARRAY_BUFFER, data.indices, gl.DYNAMIC_DRAW);\r\n\r\n        gl.drawElements(gl.TRIANGLES, data.indices.length, gl.UNSIGNED_SHORT, 0);\r\n     }\r\n}\r\n","// Based on Three.js r105, but renamed to MathUtils to match newer Three.\n// Update to newer Three later...\n\n/**\n * @author alteredq / http://alteredqualia.com/\n * @author mrdoob / http://mrdoob.com/\n * @author corruptedzulu / http://www.github.com/corruptedzulu\n * @author Joe Pea / http://github.com/trusktr\n * @author StEvUgnIn / https://github.com/StEvUgnIn\n */\n\n/**\n * @see <a href=\"https://github.com/mrdoob/three.js/blob/master/src/math/Math\">src/math/Math</a>\n */\n\nconst DEG2RAD: f32 = Mathf.PI / 180\nconst RAD2DEG: f32 = 180 / Mathf.PI\n\nexport function generateUUID(): string {\n\t//const lut: string[] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F']\n\tlet lut: string[] = []\n\tlet charVal: string = ''\n\tlet iVal: string = ''\n\tconst sixteen: i32 = 16\n\n\tfor (let i = 0; i < 256; i++) {\n\t\tcharVal = i < 16 ? '0' : ''\n\t\tiVal = i.toString(16)\n\t\tlut[i] = charVal + iVal\n\t}\n\n\tNativeMathf.seedRandom(12345678)\n\n\tconst d0: u32 = u32(Mathf.random() * 0xffffffff) //| 0\n\tconst d1: u32 = u32(Mathf.random() * 0xffffffff) //| 0\n\tconst d2: u32 = u32(Mathf.random() * 0xffffffff) //| 0\n\tconst d3: u32 = u32(Mathf.random() * 0xffffffff) //| 0\n\n\t// var uuid: string =\n\t// \tlut[d0 & 0xf] +\n\t// \tlut[(d0 >> 4) & 0xf] +\n\t// \tlut[(d0 >> 8) & 0xf] +\n\t// \tlut[(d0 >> 12) & 0xf] +\n\t// \tlut[(d0 >> 16) & 0xf] +\n\t// \tlut[(d0 >> 20) & 0xf] +\n\t// \tlut[(d0 >> 24) & 0xf] +\n\t// \tlut[(d0 >> 28) & 0xf] +\n\t// \t'-' +\n\t// \tlut[d1 & 0xf] +\n\t// \tlut[(d1 >> 4) & 0xf] +\n\t// \tlut[(d1 >> 8) & 0xf] +\n\t// \tlut[(d1 >> 12) & 0xf] +\n\t// \t'-' +\n\t// \tlut[((d1 >> 16) & 0x0f) | 0x40] +\n\t// \tlut[(d1 >> 20) & 0xf] +\n\t// \tlut[((d1 >> 16) & 0x0f) | 0x40] +\n\t// \tlut[(d1 >> 28) & 0xf] +\n\t// \t'-' +\n\t// \tlut[d2 & 0xf] +\n\t// \tlut[(d2 >> 4) & 0xf] +\n\t// \tlut[(d2 >> 8) & 0xf] +\n\t// \tlut[(d2 >> 12) & 0xf] +\n\t// \t'-' +\n\t// \tlut[(d2 >> 16) & 0xf] +\n\t// \tlut[(d2 >> 20) & 0xf] +\n\t// \tlut[(d2 >> 24) & 0xf] +\n\t// \tlut[(d2 >> 28) & 0xf] +\n\t// \tlut[d3 & 0xf] +\n\t// \tlut[(d3 >> 4) & 0xf] +\n\t// \tlut[(d3 >> 8) & 0xf] +\n\t// \tlut[(d3 >> 12) & 0xf] +\n\t// \tlut[(d3 >> 16) & 0xf] +\n\t// \tlut[(d3 >> 20) & 0xf] +\n\t// \tlut[(d3 >> 24) & 0xf] +\n\t// \tlut[(d3 >> 28) & 0xf]\n\n\tconst uuid =\n\t\tlut[d0 & 0xff] +\n\t\tlut[(d0 >> 8) & 0xff] +\n\t\tlut[(d0 >> 16) & 0xff] +\n\t\tlut[(d0 >> 24) & 0xff] +\n\t\t'-' +\n\t\tlut[d1 & 0xff] +\n\t\tlut[(d1 >> 8) & 0xff] +\n\t\t'-' +\n\t\tlut[((d1 >> 16) & 0x0f) | 0x40] +\n\t\tlut[(d1 >> 24) & 0xff] +\n\t\t'-' +\n\t\tlut[(d2 & 0x3f) | 0x80] +\n\t\tlut[(d2 >> 8) & 0xff] +\n\t\t'-' +\n\t\tlut[(d2 >> 16) & 0xff] +\n\t\tlut[(d2 >> 24) & 0xff] +\n\t\tlut[d3 & 0xff] +\n\t\tlut[(d3 >> 8) & 0xff] +\n\t\tlut[(d3 >> 16) & 0xff] +\n\t\tlut[(d3 >> 24) & 0xff]\n\n\t// use .toUpperCase() here to flatten concatenated strings to save heap memory space?\n\treturn uuid\n}\n\n/**\n * Clamps the x to be between a and b.\n *\n * @param value Value to be clamped.\n * @param min Minimum value\n * @param max Maximum value.\n */\nexport function clamp(value: f32, min: f32, max: f32): f32 {\n\treturn Mathf.max(min, Mathf.min(max, value))\n}\n\nexport function euclideanModulo(n: f32, m: f32): f32 {\n\treturn ((n % m) + m) % m\n}\n\n/**\n * Linear mapping of x from range [a1, a2] to range [b1, b2].\n *\n * @param x Value to be mapped.\n * @param a1 Minimum value for range A.\n * @param a2 Maximum value for range A.\n * @param b1 Minimum value for range B.\n * @param b2 Maximum value for range B.\n */\nexport function mapLinear(x: f32, a1: f32, a2: f32, b1: f32, b2: f32): f32 {\n\treturn b1 + ((x - a1) * (b2 - b1)) / (a2 - a1)\n}\n\n/**\n * Returns a value linearly interpolated from two known points based\n * on the given interval - t = 0 will return x and t = 1 will return y.\n *\n * @param x Start point.\n * @param y End point.\n * @param t interpolation factor in the closed interval [0, 1]\n * @return {f32}\n */\nexport function lerp(x: f32, y: f32, t: f32): f32 {\n\treturn (1 - t) * x + t * y\n}\n\nexport function smoothstep(x: f32, min: f32, max: f32): f32 {\n\tif (x <= min) return 0\n\tif (x >= max) return 1\n\n\tx = (x - min) / (max - min)\n\n\treturn x * x * (3 - 2 * x)\n}\n\nexport function smootherstep(x: f32, min: f32, max: f32): f32 {\n\tif (x <= min) return 0\n\tif (x >= max) return 1\n\n\tx = (x - min) / (max - min)\n\n\treturn x * x * x * (x * (x * 6 - 15) + 10)\n}\n\n/**\n * Random integer from low to high interval.\n */\nexport function randInt(low: f32, high: f32): f32 {\n\tNativeMathf.seedRandom(12345678)\n\treturn low + Mathf.floor(Mathf.random() * (high - low + 1))\n}\n\n/**\n * Random float from low to high interval.\n */\nexport function randFloat(low: f32, high: f32): f32 {\n\tNativeMathf.seedRandom(12345678)\n\treturn low + Mathf.random() * (high - low)\n}\n\n/**\n * Random float from - range / 2 to range / 2 interval.\n */\nexport function randFloatSpread(range: f32): f32 {\n\tNativeMathf.seedRandom(12345678)\n\treturn range * (0.5 - Mathf.random())\n}\n\nexport function degToRad(degrees: f32): f32 {\n\treturn degrees * DEG2RAD\n}\n\nexport function radToDeg(radians: f32): f32 {\n\treturn radians * RAD2DEG\n}\n\nexport function isPowerOfTwo(value: i64): boolean {\n\treturn (value & (value - 1)) === 0 && value !== 0\n}\n\nexport function ceilPowerOfTwo(value: f32): f32 {\n\treturn Mathf.pow(2, Mathf.ceil(Mathf.log(value) / Mathf.LN2))\n}\n\nexport function floorPowerOfTwo(value: f32): f32 {\n\treturn Mathf.pow(2, Mathf.floor(Mathf.log(value) / Mathf.LN2))\n}\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ILLEGALGENTYPE: string = \"Illegal generic type\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n","import {Vector3} from './Vector3'\nimport {Euler, EulerRotationOrder} from './Euler'\nimport {Quaternion} from './Quaternion'\n// import {BufferAttribute} from './../core/BufferAttribute'\n// import {Matrix} from './Matrix3'\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author jordi_ros / http://plattsoft.com\n * @author D1plo1d / http://github.com/D1plo1d\n * @author alteredq / http://alteredqualia.com/\n * @author mikael emtinger / http://gomo.se/\n * @author timknip / http://www.floorplanner.com/\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n * @author corruptedzulu / http://github.com/corruptedzulu\n * @author Joe Pea / http://github.com/trusktr\n */\n\n/**\n * A 4x4 Matrix.\n *\n * @example\n * // Simple rig for rotating around 3 axes\n * var m = new THREE.Matrix4();\n * var m1 = new THREE.Matrix4();\n * var m2 = new THREE.Matrix4();\n * var m3 = new THREE.Matrix4();\n * var alpha = 0;\n * var beta = Mathf.PI;\n * var gamma = Mathf.PI/2;\n * m1.makeRotationX( alpha );\n * m2.makeRotationY( beta );\n * m3.makeRotationZ( gamma );\n * m.multiplyMatrices( m1, m2 );\n * m.multiply( m3 );\n */\nexport class Matrix4 /*implements Matrix*/ {\n\t/**\n\t * Array with matrix values.\n\t */\n\telements: f32[] = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]\n\n\t/**\n\t * Sets all fields of this matrix.\n\t */\n\t// prettier-ignore\n\tset(\n\t\tn11: f32, n12: f32, n13: f32, n14: f32,\n\t\tn21: f32, n22: f32, n23: f32, n24: f32,\n\t\tn31: f32, n32: f32, n33: f32, n34: f32,\n\t\tn41: f32, n42: f32, n43: f32, n44: f32\n\t): Matrix4 {\n\t\tconst te = this.elements\n\n\t\tte[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14\n\t\tte[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24\n\t\tte[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34\n\t\tte[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Resets this matrix to identity.\n\t */\n\tidentity(): Matrix4 {\n\t\tthis.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n\n\t\treturn this\n\t}\n\n\tclone(): Matrix4 {\n\t\tconst m = new Matrix4()\n\t\tm.fromArray(this.elements)\n\t\treturn m\n\t}\n\n\tcopy(m: Matrix4): this {\n\t\tconst te = this.elements\n\t\tconst me = m.elements\n\n\t\tte[0] = me[0]\n\t\tte[1] = me[1]\n\t\tte[2] = me[2]\n\t\tte[3] = me[3]\n\t\tte[4] = me[4]\n\t\tte[5] = me[5]\n\t\tte[6] = me[6]\n\t\tte[7] = me[7]\n\t\tte[8] = me[8]\n\t\tte[9] = me[9]\n\t\tte[10] = me[10]\n\t\tte[11] = me[11]\n\t\tte[12] = me[12]\n\t\tte[13] = me[13]\n\t\tte[14] = me[14]\n\t\tte[15] = me[15]\n\n\t\treturn this\n\t}\n\n\t// copyPosition(m: Matrix4): Matrix4 {\n\t// \tvar te = this.elements,\n\t// \t\tme = m.elements\n\n\t// \tte[12] = me[12]\n\t// \tte[13] = me[13]\n\t// \tte[14] = me[14]\n\n\t// \treturn this\n\t// }\n\n\t// extractBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4 {\n\t// \txAxis.setFromMatrixColumn(this, 0)\n\t// \tyAxis.setFromMatrixColumn(this, 1)\n\t// \tzAxis.setFromMatrixColumn(this, 2)\n\n\t// \treturn this\n\t// }\n\n\t// makeBasis(xAxis: Vector3, yAxis: Vector3, zAxis: Vector3): Matrix4 {\n\t// \tthis.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1)\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Copies the rotation component of the supplied matrix m into this matrix rotation component.\n\t//  */\n\textractRotation(m: Matrix4): Matrix4 {\n\t\tconst v1 = new Vector3(0, 0, 0)\n\n\t\t// this method does not support reflection matrices\n\n\t\tconst te = this.elements\n\t\tconst me = m.elements\n\n\t\tconst scaleX: f32 = 1 / v1.setFromMatrixColumn(m, 0).length()\n\t\tconst scaleY: f32 = 1 / v1.setFromMatrixColumn(m, 1).length()\n\t\tconst scaleZ: f32 = 1 / v1.setFromMatrixColumn(m, 2).length()\n\n\t\tte[0] = me[0] * scaleX\n\t\tte[1] = me[1] * scaleX\n\t\tte[2] = me[2] * scaleX\n\t\tte[3] = 0\n\n\t\tte[4] = me[4] * scaleY\n\t\tte[5] = me[5] * scaleY\n\t\tte[6] = me[6] * scaleY\n\t\tte[7] = 0\n\n\t\tte[8] = me[8] * scaleZ\n\t\tte[9] = me[9] * scaleZ\n\t\tte[10] = me[10] * scaleZ\n\t\tte[11] = 0\n\n\t\tte[12] = 0\n\t\tte[13] = 0\n\t\tte[14] = 0\n\t\tte[15] = 1\n\n\t\treturn this\n\t}\n\n\tmakeRotationFromEuler(euler: Euler): this {\n\t\tconst te = this.elements\n\n\t\tconst x = euler.x,\n\t\t\ty = euler.y,\n\t\t\tz = euler.z\n\t\tMathf.sincos(x)\n\t\tconst a = Mathf.sincos_cos,\n\t\t\tb = Mathf.sincos_sin\n\t\tMathf.sincos(y)\n\t\tconst c = Mathf.sincos_cos,\n\t\t\td = Mathf.sincos_sin\n\t\tMathf.sincos(z)\n\t\tconst e = Mathf.sincos_cos,\n\t\t\tf = Mathf.sincos_sin\n\n\t\tif (euler.order === EulerRotationOrder.XYZ) {\n\t\t\tconst ae = a * e,\n\t\t\t\taf = a * f,\n\t\t\t\tbe = b * e,\n\t\t\t\tbf = b * f\n\n\t\t\tte[0] = c * e\n\t\t\tte[4] = -c * f\n\t\t\tte[8] = d\n\n\t\t\tte[1] = af + be * d\n\t\t\tte[5] = ae - bf * d\n\t\t\tte[9] = -b * c\n\n\t\t\tte[2] = bf - ae * d\n\t\t\tte[6] = be + af * d\n\t\t\tte[10] = a * c\n\t\t} else if (euler.order === EulerRotationOrder.YXZ) {\n\t\t\tconst ce = c * e,\n\t\t\t\tcf = c * f,\n\t\t\t\tde = d * e,\n\t\t\t\tdf = d * f\n\n\t\t\tte[0] = ce + df * b\n\t\t\tte[4] = de * b - cf\n\t\t\tte[8] = a * d\n\n\t\t\tte[1] = a * f\n\t\t\tte[5] = a * e\n\t\t\tte[9] = -b\n\n\t\t\tte[2] = cf * b - de\n\t\t\tte[6] = df + ce * b\n\t\t\tte[10] = a * c\n\t\t} else if (euler.order === EulerRotationOrder.ZXY) {\n\t\t\tconst ce = c * e,\n\t\t\t\tcf = c * f,\n\t\t\t\tde = d * e,\n\t\t\t\tdf = d * f\n\n\t\t\tte[0] = ce - df * b\n\t\t\tte[4] = -a * f\n\t\t\tte[8] = de + cf * b\n\n\t\t\tte[1] = cf + de * b\n\t\t\tte[5] = a * e\n\t\t\tte[9] = df - ce * b\n\n\t\t\tte[2] = -a * d\n\t\t\tte[6] = b\n\t\t\tte[10] = a * c\n\t\t} else if (euler.order === EulerRotationOrder.ZYX) {\n\t\t\tconst ae = a * e,\n\t\t\t\taf = a * f,\n\t\t\t\tbe = b * e,\n\t\t\t\tbf = b * f\n\n\t\t\tte[0] = c * e\n\t\t\tte[4] = be * d - af\n\t\t\tte[8] = ae * d + bf\n\n\t\t\tte[1] = c * f\n\t\t\tte[5] = bf * d + ae\n\t\t\tte[9] = af * d - be\n\n\t\t\tte[2] = -d\n\t\t\tte[6] = b * c\n\t\t\tte[10] = a * c\n\t\t} else if (euler.order === EulerRotationOrder.YZX) {\n\t\t\tconst ac = a * c,\n\t\t\t\tad = a * d,\n\t\t\t\tbc = b * c,\n\t\t\t\tbd = b * d\n\n\t\t\tte[0] = c * e\n\t\t\tte[4] = bd - ac * f\n\t\t\tte[8] = bc * f + ad\n\n\t\t\tte[1] = f\n\t\t\tte[5] = a * e\n\t\t\tte[9] = -b * e\n\n\t\t\tte[2] = -d * e\n\t\t\tte[6] = ad * f + bc\n\t\t\tte[10] = ac - bd * f\n\t\t} else if (euler.order === EulerRotationOrder.XZY) {\n\t\t\tconst ac = a * c,\n\t\t\t\tad = a * d,\n\t\t\t\tbc = b * c,\n\t\t\t\tbd = b * d\n\n\t\t\tte[0] = c * e\n\t\t\tte[4] = -f\n\t\t\tte[8] = d * e\n\n\t\t\tte[1] = ac * f + bd\n\t\t\tte[5] = a * e\n\t\t\tte[9] = ad * f - bc\n\n\t\t\tte[2] = bc * f - ad\n\t\t\tte[6] = b * e\n\t\t\tte[10] = bd * f + ac\n\t\t}\n\n\t\t// bottom row\n\t\tte[3] = 0\n\t\tte[7] = 0\n\t\tte[11] = 0\n\n\t\t// last column\n\t\tte[12] = 0\n\t\tte[13] = 0\n\t\tte[14] = 0\n\t\tte[15] = 1\n\n\t\treturn this\n\t}\n\n\tmakeRotationFromQuaternion(q: Quaternion): Matrix4 {\n\t\tconst zero = new Vector3(0, 0, 0)\n\t\tconst one = new Vector3(1, 1, 1)\n\n\t\treturn this.compose(zero, q, one)\n\t}\n\n\t// /**\n\t//  * Constructs a rotation matrix, looking from eye towards center with defined up vector.\n\t//  */\n\t// lookAt(eye: Vector3, target: Vector3, up: Vector3): Matrix4 {\n\t// \tvar x = new Vector3(0, 0, 0)\n\t// \tvar y = new Vector3(0, 0, 0)\n\t// \tvar z = new Vector3(0, 0, 0)\n\n\t// \tvar te = this.elements\n\n\t// \tz.subVectors(eye, target)\n\n\t// \tif (z.lengthSq() === 0) {\n\t// \t\t// eye and target are in the same position\n\n\t// \t\tz.z = 1\n\t// \t}\n\n\t// \tz.normalize()\n\t// \tx.crossVectors(up, z)\n\n\t// \tif (x.lengthSq() === 0) {\n\t// \t\t// up and z are parallel\n\n\t// \t\tif (Mathf.abs(up.z) === 1) {\n\t// \t\t\tz.x += 0.0001\n\t// \t\t} else {\n\t// \t\t\tz.z += 0.0001\n\t// \t\t}\n\n\t// \t\tz.normalize()\n\t// \t\tx.crossVectors(up, z)\n\t// \t}\n\n\t// \tx.normalize()\n\t// \ty.crossVectors(z, x)\n\n\t// \tte[0] = x.x\n\t// \tte[4] = y.x\n\t// \tte[8] = z.x\n\t// \tte[1] = x.y\n\t// \tte[5] = y.y\n\t// \tte[9] = z.y\n\t// \tte[2] = x.z\n\t// \tte[6] = y.z\n\t// \tte[10] = z.z\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Multiplies this matrix by m.\n\t//  */\n\t// multiply(m: Matrix4): Matrix4 {\n\t// \t// if ( n !== undefined ) {\n\n\t// \t// \tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\n\t// \t// \treturn this.multiplyMatrices( m, n );\n\n\t// \t// }\n\n\t// \treturn this.multiplyMatrices(this, m)\n\t// }\n\n\t// premultiply(m: Matrix4): Matrix4 {\n\t// \treturn this.multiplyMatrices(m, this)\n\t// }\n\n\t/**\n\t * Sets this matrix to a x b.\n\t */\n\tmultiplyMatrices(a: Matrix4, b: Matrix4): this {\n\t\tconst ae = a.elements\n\t\tconst be = b.elements\n\t\tconst te = this.elements\n\n\t\tconst a11 = ae[0],\n\t\t\ta12 = ae[4],\n\t\t\ta13 = ae[8],\n\t\t\ta14 = ae[12]\n\t\tconst a21 = ae[1],\n\t\t\ta22 = ae[5],\n\t\t\ta23 = ae[9],\n\t\t\ta24 = ae[13]\n\t\tconst a31 = ae[2],\n\t\t\ta32 = ae[6],\n\t\t\ta33 = ae[10],\n\t\t\ta34 = ae[14]\n\t\tconst a41 = ae[3],\n\t\t\ta42 = ae[7],\n\t\t\ta43 = ae[11],\n\t\t\ta44 = ae[15]\n\n\t\tconst b11 = be[0],\n\t\t\tb12 = be[4],\n\t\t\tb13 = be[8],\n\t\t\tb14 = be[12]\n\t\tconst b21 = be[1],\n\t\t\tb22 = be[5],\n\t\t\tb23 = be[9],\n\t\t\tb24 = be[13]\n\t\tconst b31 = be[2],\n\t\t\tb32 = be[6],\n\t\t\tb33 = be[10],\n\t\t\tb34 = be[14]\n\t\tconst b41 = be[3],\n\t\t\tb42 = be[7],\n\t\t\tb43 = be[11],\n\t\t\tb44 = be[15]\n\n\t\tte[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41\n\t\tte[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42\n\t\tte[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43\n\t\tte[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44\n\n\t\tte[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41\n\t\tte[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42\n\t\tte[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43\n\t\tte[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44\n\n\t\tte[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41\n\t\tte[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42\n\t\tte[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43\n\t\tte[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44\n\n\t\tte[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41\n\t\tte[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42\n\t\tte[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43\n\t\tte[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Multiplies this matrix by s.\n\t//  */\n\t// multiplyScalar(s: f32): Matrix4 {\n\t// \tvar te = this.elements\n\n\t// \tte[0] *= s\n\t// \tte[4] *= s\n\t// \tte[8] *= s\n\t// \tte[12] *= s\n\t// \tte[1] *= s\n\t// \tte[5] *= s\n\t// \tte[9] *= s\n\t// \tte[13] *= s\n\t// \tte[2] *= s\n\t// \tte[6] *= s\n\t// \tte[10] *= s\n\t// \tte[14] *= s\n\t// \tte[3] *= s\n\t// \tte[7] *= s\n\t// \tte[11] *= s\n\t// \tte[15] *= s\n\n\t// \treturn this\n\t// }\n\n\t// applyToBufferAttribute(attribute: BufferAttribute): BufferAttribute {\n\t// \tvar v1 = new Vector3(0, 0, 0)\n\n\t// \tfor (var i = 0, l = attribute.count; i < l; i++) {\n\t// \t\tv1.x = attribute.getX(i)\n\t// \t\tv1.y = attribute.getY(i)\n\t// \t\tv1.z = attribute.getZ(i)\n\n\t// \t\tv1.applyMatrix4(this)\n\n\t// \t\tattribute.setXYZ(i, v1.x, v1.y, v1.z)\n\t// \t}\n\n\t// \treturn attribute\n\t// }\n\n\t/**\n\t * Computes determinant of this matrix.\n\t * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t */\n\tdeterminant(): f32 {\n\t\tconst te = this.elements\n\n\t\tconst n11 = te[0],\n\t\t\tn12 = te[4],\n\t\t\tn13 = te[8],\n\t\t\tn14 = te[12]\n\t\tconst n21 = te[1],\n\t\t\tn22 = te[5],\n\t\t\tn23 = te[9],\n\t\t\tn24 = te[13]\n\t\tconst n31 = te[2],\n\t\t\tn32 = te[6],\n\t\t\tn33 = te[10],\n\t\t\tn34 = te[14]\n\t\tconst n41 = te[3],\n\t\t\tn42 = te[7],\n\t\t\tn43 = te[11],\n\t\t\tn44 = te[15]\n\n\t\t//TODO: make this more efficient\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\n\t\treturn (\n\t\t\tn41 *\n\t\t\t\t(+n14 * n23 * n32 -\n\t\t\t\t\tn13 * n24 * n32 -\n\t\t\t\t\tn14 * n22 * n33 +\n\t\t\t\t\tn12 * n24 * n33 +\n\t\t\t\t\tn13 * n22 * n34 -\n\t\t\t\t\tn12 * n23 * n34) +\n\t\t\tn42 *\n\t\t\t\t(+n11 * n23 * n34 -\n\t\t\t\t\tn11 * n24 * n33 +\n\t\t\t\t\tn14 * n21 * n33 -\n\t\t\t\t\tn13 * n21 * n34 +\n\t\t\t\t\tn13 * n24 * n31 -\n\t\t\t\t\tn14 * n23 * n31) +\n\t\t\tn43 *\n\t\t\t\t(+n11 * n24 * n32 -\n\t\t\t\t\tn11 * n22 * n34 -\n\t\t\t\t\tn14 * n21 * n32 +\n\t\t\t\t\tn12 * n21 * n34 +\n\t\t\t\t\tn14 * n22 * n31 -\n\t\t\t\t\tn12 * n24 * n31) +\n\t\t\tn44 *\n\t\t\t\t(-n13 * n22 * n31 -\n\t\t\t\t\tn11 * n23 * n32 +\n\t\t\t\t\tn11 * n22 * n33 +\n\t\t\t\t\tn13 * n21 * n32 -\n\t\t\t\t\tn12 * n21 * n33 +\n\t\t\t\t\tn12 * n23 * n31)\n\t\t)\n\t}\n\n\t// /**\n\t//  * Transposes this matrix.\n\t//  */\n\t// transpose(): Matrix4 {\n\t// \tvar te = this.elements\n\t// \tvar tmp\n\n\t// \ttmp = te[1]\n\t// \tte[1] = te[4]\n\t// \tte[4] = tmp\n\t// \ttmp = te[2]\n\t// \tte[2] = te[8]\n\t// \tte[8] = tmp\n\t// \ttmp = te[6]\n\t// \tte[6] = te[9]\n\t// \tte[9] = tmp\n\n\t// \ttmp = te[3]\n\t// \tte[3] = te[12]\n\t// \tte[12] = tmp\n\t// \ttmp = te[7]\n\t// \tte[7] = te[13]\n\t// \tte[13] = tmp\n\t// \ttmp = te[11]\n\t// \tte[11] = te[14]\n\t// \tte[14] = tmp\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Sets the position component for this matrix from vector v.\n\t//  */\n\tsetPosition(x: Vector3): Matrix4 {\n\t\tconst te = this.elements\n\n\t\tte[12] = x.x\n\t\tte[13] = x.y\n\t\tte[14] = x.z\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Sets this matrix to the inverse of matrix m.\n\t * Based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm.\n\t */\n\tgetInverse(m: Matrix4): bool {\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\t\t// prettier-ignore\n\t\tconst te = this.elements,\n\t\t\tme = m.elements,\n\n\t\t\tn11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3],\n\t\t\tn12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7],\n\t\t\tn13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11],\n\t\t\tn14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15],\n\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34\n\n\t\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14\n\n\t\tif (det === 0) {\n\t\t\tthis.identity()\n\t\t\treturn false\n\t\t}\n\n\t\tconst detInv: f32 = 1 / det\n\n\t\t// prettier-ignore\n\t\t{\n\t\t\tte[0] = t11 * detInv\n\t\t\tte[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv\n\t\t\tte[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv\n\t\t\tte[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv\n\n\t\t\tte[4] = t12 * detInv\n\t\t\tte[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv\n\t\t\tte[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv\n\t\t\tte[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv\n\n\t\t\tte[8] = t13 * detInv\n\t\t\tte[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv\n\t\t\tte[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv\n\t\t\tte[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv\n\n\t\t\tte[12] = t14 * detInv\n\t\t\tte[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv\n\t\t\tte[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv\n\t\t\tte[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv\n\t\t}\n\n\t\treturn true\n\t}\n\n\t// /**\n\t//  * Multiplies the columns of this matrix by vector v.\n\t//  */\n\t// scale(v: Vector3): Matrix4 {\n\t// \tvar te = this.elements\n\t// \tvar x = v.x,\n\t// \t\ty = v.y,\n\t// \t\tz = v.z\n\n\t// \tte[0] *= x\n\t// \tte[4] *= y\n\t// \tte[8] *= z\n\t// \tte[1] *= x\n\t// \tte[5] *= y\n\t// \tte[9] *= z\n\t// \tte[2] *= x\n\t// \tte[6] *= y\n\t// \tte[10] *= z\n\t// \tte[3] *= x\n\t// \tte[7] *= y\n\t// \tte[11] *= z\n\n\t// \treturn this\n\t// }\n\n\tgetMaxScaleOnAxis(): f32 {\n\t\tconst te = this.elements\n\n\t\tconst scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2]\n\t\tconst scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6]\n\t\tconst scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10]\n\n\t\t//Mathf.max only takes two arguments, have to do it twice.\n\t\tlet maxScale: f32 = Mathf.max(scaleXSq, scaleYSq)\n\t\tmaxScale = Mathf.max(maxScale, scaleZSq)\n\t\treturn Mathf.sqrt(maxScale)\n\t}\n\n\t/**\n\t * Sets this matrix as translation transform.\n\t */\n\tmakeTranslation(x: f32, y: f32, z: f32): Matrix4 {\n\t\tthis.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Sets this matrix as rotation transform around x axis by theta radians.\n\t *\n\t * @param theta Rotation angle in radians.\n\t */\n\tmakeRotationX(theta: f32): Matrix4 {\n\t\tMathf.sincos(theta)\n\t\tconst c = Mathf.sincos_cos,\n\t\t\ts = Mathf.sincos_sin\n\n\t\tthis.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Sets this matrix as rotation transform around y axis by theta radians.\n\t *\n\t * @param theta Rotation angle in radians.\n\t */\n\tmakeRotationY(theta: f32): Matrix4 {\n\t\tMathf.sincos(theta)\n\t\tconst c = Mathf.sincos_cos,\n\t\t\ts = Mathf.sincos_sin\n\n\t\tthis.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Sets this matrix as rotation transform around z axis by theta radians.\n\t *\n\t * @param theta Rotation angle in radians.\n\t */\n\tmakeRotationZ(theta: f32): Matrix4 {\n\t\tMathf.sincos(theta)\n\t\tconst c = Mathf.sincos_cos,\n\t\t\ts = Mathf.sincos_sin\n\n\t\tthis.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Sets this matrix as rotation transform around axis by angle radians.\n\t//  * Based on http://www.gamedev.net/reference/articles/article1199.asp.\n\t//  *\n\t//  * @param axis Rotation axis.\n\t//  * @param theta Rotation angle in radians.\n\t//  */\n\t// makeRotationAxis(axis: Vector3, angle: f32): Matrix4 {\n\t// \t// Based on http://www.gamedev.net/reference/articles/article1199.asp\n\n\t// \tvar c = Mathf.cos(angle)\n\t// \tvar s = Mathf.sin(angle)\n\t// \tvar t = 1 - c\n\t// \tvar x = axis.x,\n\t// \t\ty = axis.y,\n\t// \t\tz = axis.z\n\t// \tvar tx = t * x,\n\t// \t\tty = t * y\n\n\t// \tthis.set(\n\t// \t\ttx * x + c,\n\t// \t\ttx * y - s * z,\n\t// \t\ttx * z + s * y,\n\t// \t\t0,\n\t// \t\ttx * y + s * z,\n\t// \t\tty * y + c,\n\t// \t\tty * z - s * x,\n\t// \t\t0,\n\t// \t\ttx * z - s * y,\n\t// \t\tty * z + s * x,\n\t// \t\tt * z * z + c,\n\t// \t\t0,\n\t// \t\t0,\n\t// \t\t0,\n\t// \t\t0,\n\t// \t\t1\n\t// \t)\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Sets this matrix as scale transform.\n\t */\n\tmakeScale(x: f32, y: f32, z: f32): Matrix4 {\n\t\tthis.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1)\n\n\t\treturn this\n\t}\n\n\t// makeShear(x: f32, y: f32, z: f32): this {\n\t// \tthis.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1)\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Sets this matrix to the transformation composed of translation, rotation and scale.\n\t */\n\tcompose(position: Vector3, rotation: Quaternion, scale: Vector3): Matrix4 {\n\t\tconst te = this.elements\n\n\t\tconst x = rotation._x,\n\t\t\ty = rotation._y,\n\t\t\tz = rotation._z,\n\t\t\tw = rotation._w\n\t\tconst x2 = x + x,\n\t\t\ty2 = y + y,\n\t\t\tz2 = z + z\n\t\tconst xx = x * x2,\n\t\t\txy = x * y2,\n\t\t\txz = x * z2\n\t\tconst yy = y * y2,\n\t\t\tyz = y * z2,\n\t\t\tzz = z * z2\n\t\tconst wx = w * x2,\n\t\t\twy = w * y2,\n\t\t\twz = w * z2\n\n\t\tconst sx = scale.x,\n\t\t\tsy = scale.y,\n\t\t\tsz = scale.z\n\n\t\tte[0] = (1 - (yy + zz)) * sx\n\t\tte[1] = (xy + wz) * sx\n\t\tte[2] = (xz - wy) * sx\n\t\tte[3] = 0\n\n\t\tte[4] = (xy - wz) * sy\n\t\tte[5] = (1 - (xx + zz)) * sy\n\t\tte[6] = (yz + wx) * sy\n\t\tte[7] = 0\n\n\t\tte[8] = (xz + wy) * sz\n\t\tte[9] = (yz - wx) * sz\n\t\tte[10] = (1 - (xx + yy)) * sz\n\t\tte[11] = 0\n\n\t\tte[12] = position.x\n\t\tte[13] = position.y\n\t\tte[14] = position.z\n\t\tte[15] = 1\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Decomposes this matrix into the translation, rotation and scale components.\n\t//  * If parameters are not passed, new instances will be created.\n\t//  */\n\tdecompose(position: Vector3, rotation: Quaternion, scale: Vector3): Matrix4 {\n\t\tconst vector = new Vector3(0, 0, 0)\n\t\tconst matrix = new Matrix4()\n\n\t\tconst te = this.elements\n\n\t\t// if determine is negative, we need to invert one scale\n\t\tconst det: f32 = this.determinant()\n\n\t\tconst sx: f32 = det < 0 ? -vector.set(te[0], te[1], te[2]).length() : vector.set(te[0], te[1], te[2]).length()\n\t\tconst sy: f32 = vector.set(te[4], te[5], te[6]).length()\n\t\tconst sz: f32 = vector.set(te[8], te[9], te[10]).length()\n\n\t\tposition.x = te[12]\n\t\tposition.y = te[13]\n\t\tposition.z = te[14]\n\n\t\t// scale the rotation part\n\t\tmatrix.copy(this)\n\n\t\tconst invSX: f32 = 1 / sx\n\t\tconst invSY: f32 = 1 / sy\n\t\tconst invSZ: f32 = 1 / sz\n\n\t\tmatrix.elements[0] *= invSX\n\t\tmatrix.elements[1] *= invSX\n\t\tmatrix.elements[2] *= invSX\n\n\t\tmatrix.elements[4] *= invSY\n\t\tmatrix.elements[5] *= invSY\n\t\tmatrix.elements[6] *= invSY\n\n\t\tmatrix.elements[8] *= invSZ\n\t\tmatrix.elements[9] *= invSZ\n\t\tmatrix.elements[10] *= invSZ\n\n\t\trotation.setFromRotationMatrix(matrix)\n\n\t\tscale.x = sx\n\t\tscale.y = sy\n\t\tscale.z = sz\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Creates a frustum matrix.\n\t */\n\n\tmakePerspective(left: f32, right: f32, top: f32, bottom: f32, near: f32, far: f32): Matrix4 {\n\t\tconst te = this.elements\n\t\tconst x: f32 = (2 * near) / (right - left)\n\t\tconst y: f32 = (2 * near) / (top - bottom)\n\n\t\tconst a: f32 = (right + left) / (right - left)\n\t\tconst b: f32 = (top + bottom) / (top - bottom)\n\t\tconst c: f32 = -(far + near) / (far - near)\n\t\tconst d: f32 = (-2 * far * near) / (far - near)\n\n\t\t// prettier-ignore\n\t\t{\n\t\t\tte[0] = x; te[4] = 0; te[8] = a; te[12] = 0\n\t\t\tte[1] = 0; te[5] = y; te[9] = b; te[13] = 0\n\t\t\tte[2] = 0; te[6] = 0; te[10] = c; te[14] = d\n\t\t\tte[3] = 0; te[7] = 0; te[11] = -1; te[15] = 0\n\t\t}\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Creates a perspective projection matrix.\n\t//  */\n\t// // makePerspective(\n\t// // \tfov: f32,\n\t// // \taspect: f32,\n\t// // \tnear: f32,\n\t// // \tfar: f32\n\t// // ): Matrix4;\n\n\t// /**\n\t//  * Creates an orthographic projection matrix.\n\t//  */\n\tmakeOrthographic(left: f32, right: f32, top: f32, bottom: f32, near: f32, far: f32): Matrix4 {\n\t\tconst te = this.elements\n\t\tconst w: f32 = 1.0 / (right - left)\n\t\tconst h: f32 = 1.0 / (top - bottom)\n\t\tconst p: f32 = 1.0 / (far - near)\n\n\t\tconst x = (right + left) * w\n\t\tconst y = (top + bottom) * h\n\t\tconst z = (far + near) * p\n\n\t\tte[0] = 2 * w\n\t\tte[4] = 0\n\t\tte[8] = 0\n\t\tte[12] = -x\n\t\tte[1] = 0\n\t\tte[5] = 2 * h\n\t\tte[9] = 0\n\t\tte[13] = -y\n\t\tte[2] = 0\n\t\tte[6] = 0\n\t\tte[10] = -2 * p\n\t\tte[14] = -z\n\t\tte[3] = 0\n\t\tte[7] = 0\n\t\tte[11] = 0\n\t\tte[15] = 1\n\n\t\treturn this\n\t}\n\n\t// equals(matrix: Matrix4): boolean {\n\t// \tvar te = this.elements\n\t// \tvar me = matrix.elements\n\n\t// \tfor (var i = 0; i < 16; i++) {\n\t// \t\tif (te[i] !== me[i]) return false\n\t// \t}\n\n\t// \treturn true\n\t// }\n\n\t// TODO use `this` return type instead of `Matrix4` return type?\n\tfromArray(array: f32[], offset: i32 = 0): Matrix4 {\n\t\tfor (let i: i32 = 0; i < 16; i++) {\n\t\t\tthis.elements[i] = array[i + offset]\n\t\t}\n\n\t\treturn this\n\t}\n\n\t// toArray(array: f32[], offset: f32): f32[] {\n\t// \tif (array === undefined) array = []\n\t// \tif (offset === undefined) offset = 0\n\n\t// \tvar te = this.elements\n\n\t// \tarray[offset] = te[0]\n\t// \tarray[offset + 1] = te[1]\n\t// \tarray[offset + 2] = te[2]\n\t// \tarray[offset + 3] = te[3]\n\n\t// \tarray[offset + 4] = te[4]\n\t// \tarray[offset + 5] = te[5]\n\t// \tarray[offset + 6] = te[6]\n\t// \tarray[offset + 7] = te[7]\n\n\t// \tarray[offset + 8] = te[8]\n\t// \tarray[offset + 9] = te[9]\n\t// \tarray[offset + 10] = te[10]\n\t// \tarray[offset + 11] = te[11]\n\n\t// \tarray[offset + 12] = te[12]\n\t// \tarray[offset + 13] = te[13]\n\t// \tarray[offset + 14] = te[14]\n\t// \tarray[offset + 15] = te[15]\n\n\t// \treturn array\n\t// }\n}\n\nexport function matrixEquals4(a: Matrix4, b: Matrix4, tolerance: f32 = 0.0001): bool {\n\tif (a.elements.length != b.elements.length) {\n\t\treturn false\n\t}\n\n\tfor (let i = 0, il = a.elements.length; i < il; i++) {\n\t\tconst delta = a.elements[i] - b.elements[i]\n\t\tif (delta > tolerance) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n","// This file is shared with the compiler and must remain portable\n\n//  Typeinfo interpretation \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//   __rtti_base\n//                              count                             \n//  \n//                       Typeinfo#flags [id=0]                     id < count\n//                                 \n//                       Typeinfo#base  [id=0]                    \n// \n//                               ...                              \n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n  /** Base class id or `0` if none. */\n  base: u32 = 0;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { OBJECT, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ptr: usize, classId: u32): bool { // keyword\n  var id = changetype<OBJECT>(ptr - TOTAL_OVERHEAD).rtId;\n  var rttiBase = __rtti_base;\n  if (id <= load<u32>(rttiBase)) {\n    do if (id == classId) return true;\n    while (id = changetype<Typeinfo>(rttiBase + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  var buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  var buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  var array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n\n  /** Gets a pointer to a static chunk of memory of the given size. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function data<T>(size: T, align?: i32): usize;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __data_end: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare var __stack_pointer: usize;\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __heap_base: usize;\n\n/** Heap memory interface. */\nexport namespace heap {\n\n  /** Allocates a chunk of memory of at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function alloc(size: usize): usize {\n    return __alloc(size);\n  }\n\n  /** Reallocates a chunk of memory to have at least the specified size. */\n  // @ts-ignore: decorator\n  @unsafe export function realloc(ptr: usize, size: usize): usize {\n    return __realloc(ptr, size);\n  }\n\n  /** Frees a chunk of memory. Does hardly anything (most recent block only) with the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function free(ptr: usize): void {\n    __free(ptr);\n  }\n\n  /** Dangerously resets the entire heap. Specific to the stub runtime. */\n  // @ts-ignore: decorator\n  @unsafe export function reset(): void {\n    if (isDefined(__reset)) {\n      __reset();\n    } else {\n      throw new Error(E_NOTIMPLEMENTED);\n    }\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  var w: u32, x: u32;\n\n  // copy 1 byte each until src is aligned to 4 bytes\n  while (n && (src & 3)) {\n    store<u8>(dest++, load<u8>(src++));\n    n--;\n  }\n\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\n  if ((dest & 3) == 0) {\n    while (n >= 16) {\n      store<u32>(dest     , load<u32>(src     ));\n      store<u32>(dest +  4, load<u32>(src +  4));\n      store<u32>(dest +  8, load<u32>(src +  8));\n      store<u32>(dest + 12, load<u32>(src + 12));\n      src += 16; dest += 16; n -= 16;\n    }\n    if (n & 8) {\n      store<u32>(dest    , load<u32>(src    ));\n      store<u32>(dest + 4, load<u32>(src + 4));\n      dest += 8; src += 8;\n    }\n    if (n & 4) {\n      store<u32>(dest, load<u32>(src));\n      dest += 4; src += 4;\n    }\n    if (n & 2) { // drop to 2 bytes each\n      store<u16>(dest, load<u16>(src));\n      dest += 2; src += 2;\n    }\n    if (n & 1) { // drop to 1 byte\n      store<u8>(dest++, load<u8>(src++));\n    }\n    return;\n  }\n\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\n  if (n >= 32) {\n    switch (<u32>dest & 3) {\n      // known to be != 0\n      case 1: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 3;\n        while (n >= 17) {\n          x = load<u32>(src + 1);\n          store<u32>(dest, w >> 24 | x << 8);\n          w = load<u32>(src + 5);\n          store<u32>(dest + 4, x >> 24 | w << 8);\n          x = load<u32>(src + 9);\n          store<u32>(dest + 8, w >> 24 | x << 8);\n          w = load<u32>(src + 13);\n          store<u32>(dest + 12, x >> 24 | w << 8);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 2: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        store<u8>(dest++, load<u8>(src++));\n        n -= 2;\n        while (n >= 18) {\n          x = load<u32>(src + 2);\n          store<u32>(dest, w >> 16 | x << 16);\n          w = load<u32>(src + 6);\n          store<u32>(dest + 4, x >> 16 | w << 16);\n          x = load<u32>(src + 10);\n          store<u32>(dest + 8, w >> 16 | x << 16);\n          w = load<u32>(src + 14);\n          store<u32>(dest + 12, x >> 16 | w << 16);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n      case 3: {\n        w = load<u32>(src);\n        store<u8>(dest++, load<u8>(src++));\n        n -= 1;\n        while (n >= 19) {\n          x = load<u32>(src + 3);\n          store<u32>(dest, w >> 8 | x << 24);\n          w = load<u32>(src + 7);\n          store<u32>(dest + 4, x >> 8 | w << 24);\n          x = load<u32>(src + 11);\n          store<u32>(dest + 8, w >> 8 | x << 24);\n          w = load<u32>(src + 15);\n          store<u32>(dest + 12, x >> 8 | w << 24);\n          src += 16; dest += 16; n -= 16;\n        }\n        break;\n      }\n    }\n  }\n\n  // copy remaining bytes one by one\n  if (n & 16) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 8) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 4) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 2) {\n    store<u8>(dest++, load<u8>(src++));\n    store<u8>(dest++, load<u8>(src++));\n  }\n  if (n & 1) {\n    store<u8>(dest++, load<u8>(src++));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src - dest - n <= -(n << 1)) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while (dest & 7) {\n          if (!n) return;\n          --n;\n          store<u8>(dest++, load<u8>(src++));\n        }\n        while (n >= 8) {\n          store<u64>(dest, load<u64>(src));\n          n    -= 8;\n          dest += 8;\n          src  += 8;\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if (ASC_SHRINK_LEVEL < 2) {\n      if ((src & 7) == (dest & 7)) {\n        while ((dest + n) & 7) {\n          if (!n) return;\n          store<u8>(dest + --n, load<u8>(src + n));\n        }\n        while (n >= 8) {\n          n -= 8;\n          store<u64>(dest + n, load<u64>(src + n));\n        }\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    let dend = dest + n;\n    store<u8>(dest, c);\n    store<u8>(dend - 1, c);\n    if (n <= 2) return;\n    store<u8>(dest, c, 1);\n    store<u8>(dest, c, 2);\n    store<u8>(dend - 2, c);\n    store<u8>(dend - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest, c, 3);\n    store<u8>(dend - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    dend = dest + n;\n    store<u32>(dest, c32);\n    store<u32>(dend - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest, c32, 4);\n    store<u32>(dest, c32, 8);\n    store<u32>(dend - 12, c32);\n    store<u32>(dend - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest, c32, 12);\n    store<u32>(dest, c32, 16);\n    store<u32>(dest, c32, 20);\n    store<u32>(dest, c32, 24);\n    store<u32>(dend - 28, c32);\n    store<u32>(dend - 24, c32);\n    store<u32>(dend - 20, c32);\n    store<u32>(dend - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest, c64, 8);\n      store<u64>(dest, c64, 16);\n      store<u64>(dest, c64, 24);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 {\n  if (vl == vr) return 0;\n  if (ASC_SHRINK_LEVEL < 2) {\n    if ((vl & 7) == (vr & 7)) {\n      while (vl & 7) {\n        if (!n) return 0;\n        let a = <i32>load<u8>(vl);\n        let b = <i32>load<u8>(vr);\n        if (a != b) return a - b;\n        n--; vl++; vr++;\n      }\n      while (n >= 8) {\n        if (load<u64>(vl) != load<u64>(vr)) break;\n        vl += 8;\n        vr += 8;\n        n  -= 8;\n      }\n    }\n  }\n  while (n--) {\n    let a = <i32>load<u8>(vl);\n    let b = <i32>load<u8>(vr);\n    if (a != b) return a - b;\n    vl++; vr++;\n  }\n  return 0;\n}\n","/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n * @author Joe Pea / http://github.com/trusktr\n */\n\nimport {Matrix4} from './Matrix4'\nimport {Quaternion} from './Quaternion'\nimport {Vector3} from './Vector3'\nimport {clamp} from './MathUtils'\n\nexport enum EulerRotationOrder {\n\tXYZ,\n\tYZX,\n\tZXY,\n\tXZY,\n\tYXZ,\n\tZYX,\n}\n\n// type EulerRotationOrder = 'XYZ' | 'YZX' | 'ZXY' | 'XZY' | 'YXZ' | 'ZYX'\ntype ChangeCallback = () => void\n\nconst matrix = new Matrix4()\nconst quaternion = new Quaternion()\n\nexport class Euler {\n\t// static RotationOrders: EulerRotationOrder[] = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']\n\tstatic DefaultOrder: EulerRotationOrder = EulerRotationOrder.XYZ\n\n\treadonly isEuler: boolean = true\n\n\t_x: f32\n\t_y: f32\n\t_z: f32\n\t_order: EulerRotationOrder\n\n\tconstructor(x: f32 = 0, y: f32 = 0, z: f32 = 0, order: EulerRotationOrder = Euler.DefaultOrder) {\n\t\tthis._x = x\n\t\tthis._y = y\n\t\tthis._z = z\n\t\tthis._order = order\n\t}\n\n\tget x(): f32 {\n\t\treturn this._x\n\t}\n\n\tset x(value: f32) {\n\t\tthis._x = value\n\t\tthis.onChangeCallback()\n\t}\n\n\tget y(): f32 {\n\t\treturn this._y\n\t}\n\n\tset y(value: f32) {\n\t\tthis._y = value\n\t\tthis.onChangeCallback()\n\t}\n\n\tget z(): f32 {\n\t\treturn this._z\n\t}\n\n\tset z(value: f32) {\n\t\tthis._z = value\n\t\tthis.onChangeCallback()\n\t}\n\n\tget order(): EulerRotationOrder {\n\t\treturn this._order\n\t}\n\n\tset order(value: EulerRotationOrder) {\n\t\tthis._order = value\n\t\tthis.onChangeCallback()\n\t}\n\n\tonChangeCallback: ChangeCallback = () => {}\n\n\tset(x: f32, y: f32, z: f32, order: EulerRotationOrder = this._order): this {\n\t\tthis._x = x\n\t\tthis._y = y\n\t\tthis._z = z\n\t\tthis._order = order\n\n\t\tthis.onChangeCallback()\n\n\t\treturn this\n\t}\n\n\tclone(): Euler {\n\t\treturn new Euler(this._x, this._y, this._z, this._order)\n\t}\n\n\tcopy(euler: Euler): this {\n\t\tthis._x = euler._x\n\t\tthis._y = euler._y\n\t\tthis._z = euler._z\n\t\tthis._order = euler._order\n\n\t\tthis.onChangeCallback()\n\n\t\treturn this\n\t}\n\n\tsetFromRotationMatrix(m: Matrix4, order: EulerRotationOrder = this._order, update: boolean = true): this {\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t\tconst te = m.elements\n\t\tconst m11 = te[0],\n\t\t\tm12 = te[4],\n\t\t\tm13 = te[8]\n\t\tconst m21 = te[1],\n\t\t\tm22 = te[5],\n\t\t\tm23 = te[9]\n\t\tconst m31 = te[2],\n\t\t\tm32 = te[6],\n\t\t\tm33 = te[10]\n\n\t\tif (order === EulerRotationOrder.XYZ) {\n\t\t\tthis._y = Mathf.asin(clamp(m13, -1, 1))\n\n\t\t\tif (Mathf.abs(m13) < 0.99999) {\n\t\t\t\tthis._x = Mathf.atan2(-m23, m33)\n\t\t\t\tthis._z = Mathf.atan2(-m12, m11)\n\t\t\t} else {\n\t\t\t\tthis._x = Mathf.atan2(m32, m22)\n\t\t\t\tthis._z = 0\n\t\t\t}\n\t\t} else if (order === EulerRotationOrder.YXZ) {\n\t\t\tthis._x = Mathf.asin(-clamp(m23, -1, 1))\n\n\t\t\tif (Mathf.abs(m23) < 0.99999) {\n\t\t\t\tthis._y = Mathf.atan2(m13, m33)\n\t\t\t\tthis._z = Mathf.atan2(m21, m22)\n\t\t\t} else {\n\t\t\t\tthis._y = Mathf.atan2(-m31, m11)\n\t\t\t\tthis._z = 0\n\t\t\t}\n\t\t} else if (order === EulerRotationOrder.ZXY) {\n\t\t\tthis._x = Mathf.asin(clamp(m32, -1, 1))\n\n\t\t\tif (Mathf.abs(m32) < 0.99999) {\n\t\t\t\tthis._y = Mathf.atan2(-m31, m33)\n\t\t\t\tthis._z = Mathf.atan2(-m12, m22)\n\t\t\t} else {\n\t\t\t\tthis._y = 0\n\t\t\t\tthis._z = Mathf.atan2(m21, m11)\n\t\t\t}\n\t\t} else if (order === EulerRotationOrder.ZYX) {\n\t\t\tthis._y = Mathf.asin(-clamp(m31, -1, 1))\n\n\t\t\tif (Mathf.abs(m31) < 0.99999) {\n\t\t\t\tthis._x = Mathf.atan2(m32, m33)\n\t\t\t\tthis._z = Mathf.atan2(m21, m11)\n\t\t\t} else {\n\t\t\t\tthis._x = 0\n\t\t\t\tthis._z = Mathf.atan2(-m12, m22)\n\t\t\t}\n\t\t} else if (order === EulerRotationOrder.YZX) {\n\t\t\tthis._z = Mathf.asin(clamp(m21, -1, 1))\n\n\t\t\tif (Mathf.abs(m21) < 0.99999) {\n\t\t\t\tthis._x = Mathf.atan2(-m23, m22)\n\t\t\t\tthis._y = Mathf.atan2(-m31, m11)\n\t\t\t} else {\n\t\t\t\tthis._x = 0\n\t\t\t\tthis._y = Mathf.atan2(m13, m33)\n\t\t\t}\n\t\t} else if (order === EulerRotationOrder.XZY) {\n\t\t\tthis._z = Mathf.asin(-clamp(m12, -1, 1))\n\n\t\t\tif (Mathf.abs(m12) < 0.99999) {\n\t\t\t\tthis._x = Mathf.atan2(m32, m22)\n\t\t\t\tthis._y = Mathf.atan2(m13, m11)\n\t\t\t} else {\n\t\t\t\tthis._x = Mathf.atan2(-m23, m33)\n\t\t\t\tthis._y = 0\n\t\t\t}\n\t\t} else {\n\t\t\tconst _order = i32(order)\n\t\t\t// throw new Error('Euler.setFromRotationMatrix() given unsupported order: ' + _order.toString())\n\t\t\tthrow new Error('Euler.setFromRotationMatrix() given unsupported order.')\n\t\t}\n\n\t\tthis._order = order\n\n\t\tif (update) this.onChangeCallback()\n\n\t\treturn this\n\t}\n\n\tsetFromQuaternion(q: Quaternion, order: EulerRotationOrder = this._order, update: boolean = true): this {\n\t\tmatrix.makeRotationFromQuaternion(q)\n\n\t\treturn this.setFromRotationMatrix(matrix, order, update)\n\t}\n\n\tsetFromVector3(v: Vector3, order: EulerRotationOrder = this._order): this {\n\t\treturn this.set(v.x, v.y, v.z, order)\n\t}\n\n\t// reorder(newOrder: EulerRotationOrder): this {\n\t// \t// WARNING: this discards revolution information -bhouston\n\n\t// \tquaternion.setFromEuler(this)\n\n\t// \treturn this.setFromQuaternion(quaternion, newOrder)\n\t// }\n\n\tequals(euler: Euler): boolean {\n\t\treturn euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order\n\t}\n\n\t// /**\n\t//  * TODO, pending https://github.com/AssemblyScript/assemblyscript/issues/643\n\t//  */\n\t// // fromArray(array: any[]): this {\n\t// // \tthis._x = array[0]\n\t// // \tthis._y = array[1]\n\t// // \tthis._z = array[2]\n\t// // \tif (array[3] !== undefined) this._order = array[3]\n\n\t// // \tthis.onChangeCallback()\n\n\t// // \treturn this\n\t// // }\n\n\t// /**\n\t//  * TODO, pending https://github.com/AssemblyScript/assemblyscript/issues/643\n\t//  */\n\t// // toArray(array: f32[] = [], offset: i32 = 0): f32[] {\n\t// // \tarray[offset] = this._x\n\t// // \tarray[offset + 1] = this._y\n\t// // \tarray[offset + 2] = this._z\n\t// // \tarray[offset + 3] = this._order\n\n\t// // \treturn array\n\t// // }\n\n\ttoVector3(optionalResult: Vector3 = new Vector3()): Vector3 {\n\t\treturn optionalResult.set(this._x, this._y, this._z)\n\t}\n\n\tonChange(callback: ChangeCallback): this {\n\t\tthis.onChangeCallback = callback\n\n\t\treturn this\n\t}\n}\n\nexport function eulerEquals(a: Euler, b: Euler, tolerance: f32 = 0.0001): boolean {\n\tconst diff = Mathf.abs(a.x - b.x) + Mathf.abs(a.y - b.y) + Mathf.abs(a.z - b.z)\n\treturn diff < tolerance\n}\n","/**\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author bhouston / http://clara.io\n * @author Joe Pea / http://github.com/trusktr\n */\n\nimport * as MathUtils from './MathUtils'\nimport {Euler, EulerRotationOrder} from './Euler'\n// import {Vector3} from './Vector3'\nimport {Matrix4} from './Matrix4'\n\ntype ChangeCallback = () => void\n\n/**\n * Implementation of a quaternion. This is used for rotating things without\n * incurring the dreaded gimbal lock issue, amongst other advantages.\n *\n * @example\n * const quaternion = new THREE.Quaternion();\n * quaternion.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), Mathf.PI / 2 );\n * const vector = new THREE.Vector3( 1, 0, 0 );\n * vector.applyQuaternion( quaternion );\n */\nexport class Quaternion {\n\t_x: f32\n\t_y: f32\n\t_z: f32\n\t_w: f32\n\n\treadonly isQuaternion: boolean = true\n\n\tonChangeCallback: ChangeCallback = (): void => {}\n\n\t/**\n\t * @param x x coordinate\n\t * @param y y coordinate\n\t * @param z z coordinate\n\t * @param w w coordinate\n\t */\n\tconstructor(x: f32 = 0, y: f32 = 0, z: f32 = 0, w: f32 = 1) {\n\t\tthis._x = x\n\t\tthis._y = y\n\t\tthis._z = z\n\t\tthis._w = w\n\t}\n\n\tget x(): f32 {\n\t\treturn this._x\n\t}\n\tset x(value: f32) {\n\t\tthis._x = value\n\t\tthis.onChangeCallback()\n\t}\n\n\tget y(): f32 {\n\t\treturn this._y\n\t}\n\tset y(value: f32) {\n\t\tthis._y = value\n\t\tthis.onChangeCallback()\n\t}\n\n\tget z(): f32 {\n\t\treturn this._z\n\t}\n\tset z(value: f32) {\n\t\tthis._z = value\n\t\tthis.onChangeCallback()\n\t}\n\n\tget w(): f32 {\n\t\treturn this._w\n\t}\n\tset w(value: f32) {\n\t\tthis._w = value\n\t\tthis.onChangeCallback()\n\t}\n\n\t// /**\n\t//  * Sets values of this quaternion.\n\t//  * @param x x coordinate\n\t//  * @param y y coordinate\n\t//  * @param z z coordinate\n\t//  * @param w w coordinate\n\t//  */\n\t// set(x: f32, y: f32, z: f32, w: f32): this {\n\t// \tthis._x = x\n\t// \tthis._y = y\n\t// \tthis._z = z\n\t// \tthis._w = w\n\n\t// \tthis.onChangeCallback()\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Clones this quaternion, returning a new one with all the same property values.\n\t//  */\n\t// clone(): Quaternion {\n\t// \treturn new Quaternion(this._x, this._y, this._z, this._w)\n\t// }\n\n\t/**\n\t * Copies all data of the source quaternion to this quaternion.\n\t * @param source The quaternion to copy from.\n\t */\n\tcopy(source: Quaternion): this {\n\t\tthis._x = source.x\n\t\tthis._y = source.y\n\t\tthis._z = source.z\n\t\tthis._w = source.w\n\n\t\tthis.onChangeCallback()\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Sets this quaternion from rotation specified by Euler angles.\n\t * Adapted from http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n\t * @param euler The Euler angles from which to get rotation from.\n\t * @param update\n\t */\n\tsetFromEuler(euler: Euler, update: boolean = true): this {\n\t\t// if (!(euler && euler.isEuler)) {\n\t\t// \tthrow new Error(\n\t\t// \t\t'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.'\n\t\t// \t)\n\t\t// }\n\t\tconst x = euler._x,\n\t\t\ty = euler._y,\n\t\t\tz = euler._z,\n\t\t\torder = euler.order\n\n\t\tMathf.sincos(x / 2)\n\t\tconst c1 = Mathf.sincos_cos,\n\t\t\ts1 = Mathf.sincos_sin\n\n\t\tMathf.sincos(y / 2)\n\t\tconst c2 = Mathf.sincos_cos,\n\t\t\ts2 = Mathf.sincos_sin\n\n\t\tMathf.sincos(z / 2)\n\t\tconst c3 = Mathf.sincos_cos,\n\t\t\ts3 = Mathf.sincos_sin\n\n\t\tif (order === EulerRotationOrder.XYZ) {\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3\n\t\t} else if (order === EulerRotationOrder.YXZ) {\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3\n\t\t} else if (order === EulerRotationOrder.ZXY) {\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3\n\t\t} else if (order === EulerRotationOrder.ZYX) {\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3\n\t\t} else if (order === EulerRotationOrder.YZX) {\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3\n\t\t} else if (order === EulerRotationOrder.XZY) {\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3\n\t\t}\n\n\t\tif (update) this.onChangeCallback()\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Sets this quaternion from rotation specified by *axis* and *angle*.\n\t//  * Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm.\n\t//  * Axis have to be normalized, angle is in radians.\n\t//  * @param axis A vector representing the axis of rotation, assumed to be normalized.\n\t//  * @param angle The angle of rotation around the axis.\n\t//  */\n\t// setFromAxisAngle(axis: Vector3, angle: f32): this {\n\t// \tconst halfAngle = angle / 2\n\t// \tconst s = Mathf.sin(halfAngle)\n\n\t// \tthis._x = axis.x * s\n\t// \tthis._y = axis.y * s\n\t// \tthis._z = axis.z * s\n\t// \tthis._w = Mathf.cos(halfAngle)\n\n\t// \tthis.onChangeCallback()\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Sets this quaternion from rotation component of *m*.\n\t//  * Adapted from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm.\n\t//  * @param m The matrix containing the rotation. The upper 3x3 of m is assumed\n\t//  * to be a pure rotation matrix (i.e, unscaled).\n\t//  */\n\tsetFromRotationMatrix(m: Matrix4): Quaternion {\n\t\tconst te = m.elements,\n\t\t\tm11 = te[0],\n\t\t\tm12 = te[4],\n\t\t\tm13 = te[8],\n\t\t\tm21 = te[1],\n\t\t\tm22 = te[5],\n\t\t\tm23 = te[9],\n\t\t\tm31 = te[2],\n\t\t\tm32 = te[6],\n\t\t\tm33 = te[10],\n\t\t\ttrace = m11 + m22 + m33\n\n\t\tlet s: f32 = 0\n\n\t\tif (trace > 0) {\n\t\t\ts = 0.5 / Mathf.sqrt(trace + 1.0)\n\n\t\t\tthis._w = 0.25 / s\n\t\t\tthis._x = (m32 - m23) * s\n\t\t\tthis._y = (m13 - m31) * s\n\t\t\tthis._z = (m21 - m12) * s\n\t\t} else if (m11 > m22 && m11 > m33) {\n\t\t\ts = 2.0 * Mathf.sqrt(1.0 + m11 - m22 - m33)\n\n\t\t\tthis._w = (m32 - m23) / s\n\t\t\tthis._x = 0.25 * s\n\t\t\tthis._y = (m12 + m21) / s\n\t\t\tthis._z = (m13 + m31) / s\n\t\t} else if (m22 > m33) {\n\t\t\ts = 2.0 * Mathf.sqrt(1.0 + m22 - m11 - m33)\n\n\t\t\tthis._w = (m13 - m31) / s\n\t\t\tthis._x = (m12 + m21) / s\n\t\t\tthis._y = 0.25 * s\n\t\t\tthis._z = (m23 + m32) / s\n\t\t} else {\n\t\t\ts = 2.0 * Mathf.sqrt(1.0 + m33 - m11 - m22)\n\n\t\t\tthis._w = (m21 - m12) / s\n\t\t\tthis._x = (m13 + m31) / s\n\t\t\tthis._y = (m23 + m32) / s\n\t\t\tthis._z = 0.25 * s\n\t\t}\n\n\t\tthis.onChangeCallback()\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Sets this quaternion from the rotation found between vectors, where rotation is from *vFrom* to *vTo*.\n\t//  * Assumes direction vectors *vFrom* and *vTo* are normalized.\n\t//  * @param vFrom The vector that rotation starts from.\n\t//  * @param vTo The vector that rotation goes to.\n\t//  */\n\t// setFromUnitVectors(vFrom: Vector3, vTo: Vector3): this {\n\t// \tconst EPS = 0.000001\n\n\t// \tlet r = vFrom.dot(vTo) + 1\n\n\t// \tif (r < EPS) {\n\t// \t\tr = 0\n\n\t// \t\tif (Mathf.abs(vFrom.x) > Mathf.abs(vFrom.z)) {\n\t// \t\t\tthis._x = -vFrom.y\n\t// \t\t\tthis._y = vFrom.x\n\t// \t\t\tthis._z = 0\n\t// \t\t\tthis._w = r\n\t// \t\t} else {\n\t// \t\t\tthis._x = 0\n\t// \t\t\tthis._y = -vFrom.z\n\t// \t\t\tthis._z = vFrom.y\n\t// \t\t\tthis._w = r\n\t// \t\t}\n\t// \t} else {\n\t// \t\t// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3\n\n\t// \t\tthis._x = vFrom.y * vTo.z - vFrom.z * vTo.y\n\t// \t\tthis._y = vFrom.z * vTo.x - vFrom.x * vTo.z\n\t// \t\tthis._z = vFrom.x * vTo.y - vFrom.y * vTo.x\n\t// \t\tthis._w = r\n\t// \t}\n\n\t// \treturn this.normalize()\n\t// }\n\n\t// /**\n\t//  * Returns the angle between this quaternion and quaternion *q* in radians.\n\t//  * @param q Another quaternion.\n\t//  */\n\t// angleTo(q: Quaternion): f32 {\n\t// \treturn 2 * Mathf.acos(Mathf.abs(_Math.clamp(this.dot(q), -1, 1)))\n\t// }\n\n\t// /**\n\t//  * Rotates this quaternion by a given angular step to the defined quaternion q. The method ensures that the final quaternion will not overshoot q.\n\t//  * @param q The target quaternion.\n\t//  * @param step The angular step in radians.\n\t//  */\n\t// rotateTowards(q: Quaternion, step: f32): this {\n\t// \tvar angle = this.angleTo(q)\n\n\t// \tif (angle === 0) return this\n\n\t// \tvar t = Mathf.min(1, step / angle)\n\n\t// \tthis.slerp(q, t)\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Inverts this quaternion (). The quaternion is assumed to have unit length.\n\t//  */\n\t// inverse(): this {\n\t// \treturn this.conjugate()\n\t// }\n\n\t// /**\n\t//  * Returns the rotational conjugate of this quaternion. The conjugate of a\n\t//  * quaternion represents the same rotation in the opposite direction about the\n\t//  * rotational axis.\n\t//  */\n\t// conjugate(): this {\n\t// \tthis._x *= -1\n\t// \tthis._y *= -1\n\t// \tthis._z *= -1\n\n\t// \tthis.onChangeCallback()\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Calculates the [dot](https://en.wikipedia.org/wiki/Dot_product) product of\n\t//  * quaternion *v* and this one.\n\t//  * @param v Another quaternion.\n\t//  */\n\t// dot(v: Quaternion): f32 {\n\t// \treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w\n\t// }\n\n\t// /**\n\t//  * Computes the [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance) (straight-line\n\t//  * length) of this quaternion, squared, considered as a 4 dimensional vector (what's a\n\t//  * straight line in 4D?). This can be useful if you are comparing the lengths\n\t//  * of two quaternions, as this is a slightly more efficient calculation than\n\t//  * [page:.length length]().\n\t//  */\n\t// lengthSq(): f32 {\n\t// \treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w\n\t// }\n\n\t/**\n\t * Computes the [Euclidean length](https://en.wikipedia.org/wiki/Euclidean_distance) (straight-line\n\t * length) of this quaternion, considered as a 4 dimensional vector (what's a\n\t * straight line in 4D?).\n\t */\n\tlength(): f32 {\n\t\treturn Mathf.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)\n\t}\n\n\t// /**\n\t//  * [Normalizes](https://en.wikipedia.org/wiki/Normalized_vector) this\n\t//  * quaternion - that is, calculates the quaternion that performs the same\n\t//  * rotation as this one, but has [page:.length length] equal to *1*.\n\t//  */\n\t// normalize(): this {\n\t// \tvar l = this.length()\n\n\t// \tif (l === 0) {\n\t// \t\tthis._x = 0\n\t// \t\tthis._y = 0\n\t// \t\tthis._z = 0\n\t// \t\tthis._w = 1\n\t// \t} else {\n\t// \t\tl = 1 / l\n\n\t// \t\tthis._x = this._x * l\n\t// \t\tthis._y = this._y * l\n\t// \t\tthis._z = this._z * l\n\t// \t\tthis._w = this._w * l\n\t// \t}\n\n\t// \tthis.onChangeCallback()\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Multiplies this quaternion by *q*.\n\t//  */\n\t// multiply(q: Quaternion): this {\n\t// \treturn this.multiplyQuaternions(this, q)\n\t// }\n\n\t// /**\n\t//  * Pre-multiplies this quaternion by *q*.\n\t//  */\n\t// premultiply(q: Quaternion): this {\n\t// \treturn this.multiplyQuaternions(q, this)\n\t// }\n\n\t// /**\n\t//  * Sets this quaternion to a x b\n\t//  * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm.\n\t//  */\n\t// multiplyQuaternions(a: Quaternion, b: Quaternion): this {\n\t// \tvar qax = a._x,\n\t// \t\tqay = a._y,\n\t// \t\tqaz = a._z,\n\t// \t\tqaw = a._w\n\t// \tvar qbx = b._x,\n\t// \t\tqby = b._y,\n\t// \t\tqbz = b._z,\n\t// \t\tqbw = b._w\n\n\t// \tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby\n\t// \tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz\n\t// \tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx\n\t// \tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz\n\n\t// \tthis.onChangeCallback()\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Handles the spherical linear interpolation between quaternions. *t*\n\t//  * represents the amount of rotation between this quaternion (where *t* is 0)\n\t//  * and *qb* (where *t* is 1). This quaternion is set to the result. Also see\n\t//  * the static version of *slerp*.\n\t//  * Adapted from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/.\n\t//  * @param qb The other quaternion rotation.\n\t//  * @param t Interpolation factor in the closed interval [0, 1].\n\t//  */\n\t// slerp(qb: Quaternion, t: f32): this {\n\t// \tif (t === 0) return this\n\t// \tif (t === 1) return this.copy(qb)\n\n\t// \tvar x = this._x,\n\t// \t\ty = this._y,\n\t// \t\tz = this._z,\n\t// \t\tw = this._w\n\n\t// \tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z\n\n\t// \tif (cosHalfTheta < 0) {\n\t// \t\tthis._w = -qb._w\n\t// \t\tthis._x = -qb._x\n\t// \t\tthis._y = -qb._y\n\t// \t\tthis._z = -qb._z\n\n\t// \t\tcosHalfTheta = -cosHalfTheta\n\t// \t} else {\n\t// \t\tthis.copy(qb)\n\t// \t}\n\n\t// \tif (cosHalfTheta >= 1.0) {\n\t// \t\tthis._w = w\n\t// \t\tthis._x = x\n\t// \t\tthis._y = y\n\t// \t\tthis._z = z\n\n\t// \t\treturn this\n\t// \t}\n\n\t// \tvar sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta\n\n\t// \t// TODO is it possible to have a number smaller than f32.EPSILON\n\t// \tif (sqrSinHalfTheta <= F64.EPSILON) {\n\t// \t\tvar s = 1 - t\n\t// \t\tthis._w = s * w + t * this._w\n\t// \t\tthis._x = s * x + t * this._x\n\t// \t\tthis._y = s * y + t * this._y\n\t// \t\tthis._z = s * z + t * this._z\n\n\t// \t\treturn this.normalize()\n\t// \t}\n\n\t// \tvar sinHalfTheta = Mathf.sqrt(sqrSinHalfTheta)\n\t// \tvar halfTheta = Mathf.atan2(sinHalfTheta, cosHalfTheta)\n\t// \tvar ratioA = Mathf.sin((1 - t) * halfTheta) / sinHalfTheta,\n\t// \t\tratioB = Mathf.sin(t * halfTheta) / sinHalfTheta\n\n\t// \tthis._w = w * ratioA + this._w * ratioB\n\t// \tthis._x = x * ratioA + this._x * ratioB\n\t// \tthis._y = y * ratioA + this._y * ratioB\n\t// \tthis._z = z * ratioA + this._z * ratioB\n\n\t// \tthis.onChangeCallback()\n\n\t// \treturn this\n\t// }\n\n\t// equals(q: Quaternion): boolean {\n\t// \treturn q._x === this._x && q._y === this._y && q._z === this._z && q._w === this._w\n\t// }\n\n\t// fromArray(array: f32[], offset: i32 = 0): this {\n\t// \tthis._x = array[offset]\n\t// \tthis._y = array[offset + 1]\n\t// \tthis._z = array[offset + 2]\n\t// \tthis._w = array[offset + 3]\n\n\t// \tthis.onChangeCallback()\n\n\t// \treturn this\n\t// }\n\n\t// toArray(array: f32[] = [], offset: i32 = 0): f32[] {\n\t// \tif (array === undefined) array = []\n\t// \tif (offset === undefined) offset = 0\n\n\t// \tarray[offset] = this._x\n\t// \tarray[offset + 1] = this._y\n\t// \tarray[offset + 2] = this._z\n\t// \tarray[offset + 3] = this._w\n\n\t// \treturn array\n\t// }\n\n\tonChange(callback: ChangeCallback): Quaternion {\n\t\tthis.onChangeCallback = callback\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Static version of *slerp* that helps assign the result on a re-usable cache object.\n\t//  */\n\t// static slerp(qa: Quaternion, qb: Quaternion, qm: Quaternion, t: f32): Quaternion {\n\t// \treturn qm.copy(qa).slerp(qb, t)\n\t// }\n\n\t// /**\n\t//  * Fuzz-free, array-based Quaternion SLERP operation.\n\t//  * @param dst\n\t//  * @param dstOffset\n\t//  * @param src0\n\t//  * @param srcOffset0\n\t//  * @param src1\n\t//  * @param srcOffset1\n\t//  * @param t\n\t//  */\n\t// static slerpFlat(\n\t// \tdst: f32[],\n\t// \tdstOffset: i32,\n\t// \tsrc0: f32[],\n\t// \tsrcOffset0: i32,\n\t// \tsrc1: f32[],\n\t// \tsrcOffset1: i32,\n\t// \tt: f32\n\t// ): void {\n\t// \tvar x0 = src0[srcOffset0 + 0],\n\t// \t\ty0 = src0[srcOffset0 + 1],\n\t// \t\tz0 = src0[srcOffset0 + 2],\n\t// \t\tw0 = src0[srcOffset0 + 3],\n\t// \t\tx1 = src1[srcOffset1 + 0],\n\t// \t\ty1 = src1[srcOffset1 + 1],\n\t// \t\tz1 = src1[srcOffset1 + 2],\n\t// \t\tw1 = src1[srcOffset1 + 3]\n\n\t// \tif (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n\t// \t\tvar s = 1 - t,\n\t// \t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\n\t// \t\t\tdir = cos >= 0 ? 1 : -1,\n\t// \t\t\tsqrSin = 1 - cos * cos\n\n\t// \t\t// Skip the Slerp for tiny steps to avoid numeric problems:\n\t// \t\tif (sqrSin > F64.EPSILON) {\n\t// \t\t\tvar sin = Mathf.sqrt(sqrSin),\n\t// \t\t\t\tlen = Mathf.atan2(sin, cos * dir)\n\n\t// \t\t\ts = Mathf.sin(s * len) / sin\n\t// \t\t\tt = Mathf.sin(t * len) / sin\n\t// \t\t}\n\n\t// \t\tvar tDir = t * dir\n\n\t// \t\tx0 = x0 * s + x1 * tDir\n\t// \t\ty0 = y0 * s + y1 * tDir\n\t// \t\tz0 = z0 * s + z1 * tDir\n\t// \t\tw0 = w0 * s + w1 * tDir\n\n\t// \t\t// Normalize in case we just did a lerp:\n\t// \t\tif (s === 1 - t) {\n\t// \t\t\tvar f = 1 / Mathf.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0)\n\n\t// \t\t\tx0 *= f\n\t// \t\t\ty0 *= f\n\t// \t\t\tz0 *= f\n\t// \t\t\tw0 *= f\n\t// \t\t}\n\t// \t}\n\n\t// \tdst[dstOffset] = x0\n\t// \tdst[dstOffset + 1] = y0\n\t// \tdst[dstOffset + 2] = z0\n\t// \tdst[dstOffset + 3] = w0\n\t// }\n}\n\nexport function quatEquals(a: Quaternion, b: Quaternion, tolerance: f32 = 0.0001): boolean {\n\tconst diff = Mathf.abs(a.x - b.x) + Mathf.abs(a.y - b.y) + Mathf.abs(a.z - b.z) + Mathf.abs(a.w - b.w)\n\treturn diff < tolerance\n}\n","/**\n * @author supereggbert / http://www.paulbrunt.co.uk/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author corruptedzulu / http://github.com/corruptedzulu\n * @author Joe Pea / http://github.com/trusktr\n */\n\n/**\n * @deprecated use {@link Vector3 THREE.Vector3} instead.\n */\n\nimport {Matrix4} from './Matrix4'\n// import {Quaternion} from './Quaternion'\n// import {Matrix3} from './Matrix3'\n// import {BufferAttribute} from './../core/BufferAttribute'\n// import {Vector} from './Vector2'\n\nconst min: Vector4 | null = null\nconst max: Vector4 | null = null\n\n/**\n * 4D vector.\n *\n * ( class Vector4 implements Vector<Vector4> )\n */\nexport class Vector4 /*implements Vector*/ {\n\tx: f32\n\ty: f32\n\tz: f32\n\tw: f32\n\treadonly isVector4: bool = true\n\n\tconstructor(x: f32 = 0, y: f32 = 0, z: f32 = 0, w: f32 = 1) {\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.z = z\n\t\tthis.w = w\n\t}\n\n\t/**\n\t * Sets value of this vector.\n\t */\n\tset(x: f32, y: f32, z: f32, w: f32): this {\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.z = z\n\t\tthis.w = w\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Sets all values of this vector.\n\t//  */\n\t// setScalar(scalar: f32): this {\n\t// \tthis.x = scalar\n\t// \tthis.y = scalar\n\t// \tthis.z = scalar\n\t// \tthis.w = scalar\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Sets X component of this vector.\n\t//  */\n\t// setX(x: f32): this {\n\t// \tthis.x = x\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Sets Y component of this vector.\n\t//  */\n\t// setY(y: f32): this {\n\t// \tthis.y = y\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Sets Z component of this vector.\n\t//  */\n\t// setZ(z: f32): this {\n\t// \tthis.z = z\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Sets w component of this vector.\n\t//  */\n\t// setW(w: f32): this {\n\t// \tthis.w = w\n\n\t// \treturn this\n\t// }\n\n\t// setComponent(index: f32, value: f32): this {\n\t// \tswitch (index) {\n\t// \t\tcase 0:\n\t// \t\t\tthis.x = value\n\t// \t\t\tbreak\n\t// \t\tcase 1:\n\t// \t\t\tthis.y = value\n\t// \t\t\tbreak\n\t// \t\tcase 2:\n\t// \t\t\tthis.z = value\n\t// \t\t\tbreak\n\t// \t\tcase 3:\n\t// \t\t\tthis.w = value\n\t// \t\t\tbreak\n\t// \t\tdefault:\n\t// \t\t\tthrow new Error('index is out of range: ' + index)\n\t// \t}\n\n\t// \treturn this\n\t// }\n\n\t// getComponent(index: i32): f32 {\n\t// \tswitch (index) {\n\t// \t\tcase 0:\n\t// \t\t\treturn this.x\n\t// \t\tcase 1:\n\t// \t\t\treturn this.y\n\t// \t\tcase 2:\n\t// \t\t\treturn this.z\n\t// \t\tcase 3:\n\t// \t\t\treturn this.w\n\t// \t\tdefault:\n\t// \t\t\tthrow new Error('index is out of range: ' + index)\n\t// \t}\n\t// }\n\n\t/**\n\t * Clones this vector.\n\t */\n\tclone(): Vector4 {\n\t\treturn new Vector4(this.x, this.y, this.z, this.w)\n\t}\n\n\t/**\n\t * Copies value of v to this vector.\n\t */\n\tcopy(v: Vector4): this {\n\t\tthis.x = v.x\n\t\tthis.y = v.y\n\t\tthis.z = v.z\n\t\tthis.w = v.w\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Adds v to this vector.\n\t//  */\n\t// add(v: Vector4): this {\n\t// \tthis.x += v.x\n\t// \tthis.y += v.y\n\t// \tthis.z += v.z\n\t// \tthis.w += v.w\n\n\t// \treturn this\n\t// }\n\n\t// addScalar(scalar: f32): this {\n\t// \tthis.x += scalar\n\t// \tthis.y += scalar\n\t// \tthis.z += scalar\n\t// \tthis.w += scalar\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Sets this vector to a + b.\n\t//  */\n\t// addVectors(a: Vector4, b: Vector4): this {\n\t// \tthis.x = a.x + b.x\n\t// \tthis.y = a.y + b.y\n\t// \tthis.z = a.z + b.z\n\t// \tthis.w = a.w + b.w\n\n\t// \treturn this\n\t// }\n\n\t// addScaledVector(v: Vector4, scale: f32): this {\n\t// \tthis.x += v.x * scale\n\t// \tthis.y += v.y * scale\n\t// \tthis.z += v.z * scale\n\t// \tthis.w += v.w * scale\n\n\t// \treturn this\n\t// }\n\t// /**\n\t//  * Subtracts v from this vector.\n\t//  */\n\t// sub(v: Vector4): this {\n\t// \tthis.x -= v.x\n\t// \tthis.y -= v.y\n\t// \tthis.z -= v.z\n\t// \tthis.w -= v.w\n\n\t// \treturn this\n\t// }\n\n\t// subScalar(scalar: f32): this {\n\t// \tthis.x -= scalar\n\t// \tthis.y -= scalar\n\t// \tthis.z -= scalar\n\t// \tthis.w -= scalar\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Sets this vector to a - b.\n\t//  */\n\t// subVectors(a: Vector4, b: Vector4): this {\n\t// \tthis.x = a.x - b.x\n\t// \tthis.y = a.y - b.y\n\t// \tthis.z = a.z - b.z\n\t// \tthis.w = a.w - b.w\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Multiplies this vector by scalar s.\n\t */\n\tmultiplyScalar(scalar: f32): this {\n\t\tthis.x *= scalar\n\t\tthis.y *= scalar\n\t\tthis.z *= scalar\n\t\tthis.w *= scalar\n\n\t\treturn this\n\t}\n\n\tapplyMatrix4(m: Matrix4): this {\n\t\tconst x = this.x\n\t\tconst y = this.y\n\t\tconst z = this.z\n\t\tconst w = this.w\n\t\tconst e = m.elements\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w\n\t\tthis.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Divides this vector by scalar s.\n\t//  * Set vector to ( 0, 0, 0 ) if s == 0.\n\t//  */\n\t// divideScalar(scalar: f32): this {\n\t// \treturn this.multiplyScalar(1 / scalar)\n\t// }\n\n\t// /**\n\t//  * http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\t//  * @param q is assumed to be normalized\n\t//  */\n\t// setAxisAngleFromQuaternion(q: Quaternion): this {\n\t// \t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\n\n\t// \t// q is assumed to be normalized\n\n\t// \tthis.w = 2 * Mathf.acos(q.w)\n\n\t// \tvar s = Mathf.sqrt(1 - q.w * q.w)\n\n\t// \tif (s < 0.0001) {\n\t// \t\tthis.x = 1\n\t// \t\tthis.y = 0\n\t// \t\tthis.z = 0\n\t// \t} else {\n\t// \t\tthis.x = q.x / s\n\t// \t\tthis.y = q.y / s\n\t// \t\tthis.z = q.z / s\n\t// \t}\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\t//  * @param m assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t//  */\n\t// setAxisAngleFromRotationMatrix(m: Matrix3): this {\n\t// \t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\n\n\t// \t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\t// \tvar angle,\n\t// \t\tx,\n\t// \t\ty,\n\t// \t\tz, // variables for result\n\t// \t\tepsilon = 0.01, // margin to allow for rounding errors\n\t// \t\tepsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees\n\t// \t\tte = m.elements,\n\t// \t\tm11 = te[0],\n\t// \t\tm12 = te[4],\n\t// \t\tm13 = te[8],\n\t// \t\tm21 = te[1],\n\t// \t\tm22 = te[5],\n\t// \t\tm23 = te[9],\n\t// \t\tm31 = te[2],\n\t// \t\tm32 = te[6],\n\t// \t\tm33 = te[10]\n\n\t// \tif (Mathf.abs(m12 - m21) < epsilon && Mathf.abs(m13 - m31) < epsilon && Mathf.abs(m23 - m32) < epsilon) {\n\t// \t\t// singularity found\n\t// \t\t// first check for identity matrix which must have +1 for all terms\n\t// \t\t// in leading diagonal and zero in other terms\n\n\t// \t\tif (\n\t// \t\t\tMathf.abs(m12 + m21) < epsilon2 &&\n\t// \t\t\tMathf.abs(m13 + m31) < epsilon2 &&\n\t// \t\t\tMathf.abs(m23 + m32) < epsilon2 &&\n\t// \t\t\tMathf.abs(m11 + m22 + m33 - 3) < epsilon2\n\t// \t\t) {\n\t// \t\t\t// this singularity is identity matrix so angle = 0\n\n\t// \t\t\tthis.set(1, 0, 0, 0)\n\n\t// \t\t\treturn this // zero angle, arbitrary axis\n\t// \t\t}\n\n\t// \t\t// otherwise this singularity is angle = 180\n\n\t// \t\tangle = Mathf.PI\n\n\t// \t\tvar xx = (m11 + 1) / 2\n\t// \t\tvar yy = (m22 + 1) / 2\n\t// \t\tvar zz = (m33 + 1) / 2\n\t// \t\tvar xy = (m12 + m21) / 4\n\t// \t\tvar xz = (m13 + m31) / 4\n\t// \t\tvar yz = (m23 + m32) / 4\n\n\t// \t\tif (xx > yy && xx > zz) {\n\t// \t\t\t// m11 is the largest diagonal term\n\n\t// \t\t\tif (xx < epsilon) {\n\t// \t\t\t\tx = 0\n\t// \t\t\t\ty = 0.707106781\n\t// \t\t\t\tz = 0.707106781\n\t// \t\t\t} else {\n\t// \t\t\t\tx = Mathf.sqrt(xx)\n\t// \t\t\t\ty = xy / x\n\t// \t\t\t\tz = xz / x\n\t// \t\t\t}\n\t// \t\t} else if (yy > zz) {\n\t// \t\t\t// m22 is the largest diagonal term\n\n\t// \t\t\tif (yy < epsilon) {\n\t// \t\t\t\tx = 0.707106781\n\t// \t\t\t\ty = 0\n\t// \t\t\t\tz = 0.707106781\n\t// \t\t\t} else {\n\t// \t\t\t\ty = Mathf.sqrt(yy)\n\t// \t\t\t\tx = xy / y\n\t// \t\t\t\tz = yz / y\n\t// \t\t\t}\n\t// \t\t} else {\n\t// \t\t\t// m33 is the largest diagonal term so base result on this\n\n\t// \t\t\tif (zz < epsilon) {\n\t// \t\t\t\tx = 0.707106781\n\t// \t\t\t\ty = 0.707106781\n\t// \t\t\t\tz = 0\n\t// \t\t\t} else {\n\t// \t\t\t\tz = Mathf.sqrt(zz)\n\t// \t\t\t\tx = xz / z\n\t// \t\t\t\ty = yz / z\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t\tthis.set(x, y, z, angle)\n\n\t// \t\treturn this // return 180 deg rotation\n\t// \t}\n\n\t// \t// as we have reached here there are no singularities so we can handle normally\n\n\t// \tvar s = Mathf.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)) // used to normalize\n\n\t// \tif (Mathf.abs(s) < 0.001) s = 1\n\n\t// \t// prevent divide by zero, should not happen if matrix is orthogonal and should be\n\t// \t// caught by singularity test above, but I've left it in just in case\n\n\t// \tthis.x = (m32 - m23) / s\n\t// \tthis.y = (m13 - m31) / s\n\t// \tthis.z = (m21 - m12) / s\n\t// \tthis.w = Mathf.acos((m11 + m22 + m33 - 1) / 2)\n\n\t// \treturn this\n\t// }\n\n\t// min(v: Vector4): this {\n\t// \tthis.x = Mathf.min(this.x, v.x)\n\t// \tthis.y = Mathf.min(this.y, v.y)\n\t// \tthis.z = Mathf.min(this.z, v.z)\n\t// \tthis.w = Mathf.min(this.w, v.w)\n\n\t// \treturn this\n\t// }\n\n\t// max(v: Vector4): this {\n\t// \tthis.x = Mathf.max(this.x, v.x)\n\t// \tthis.y = Mathf.max(this.y, v.y)\n\t// \tthis.z = Mathf.max(this.z, v.z)\n\t// \tthis.w = Mathf.max(this.w, v.w)\n\n\t// \treturn this\n\t// }\n\n\t// clamp(min: Vector4, max: Vector4): this {\n\t// \t// assumes min < max, componentwise\n\n\t// \tthis.x = Mathf.max(min.x, Mathf.min(max.x, this.x))\n\t// \tthis.y = Mathf.max(min.y, Mathf.min(max.y, this.y))\n\t// \tthis.z = Mathf.max(min.z, Mathf.min(max.z, this.z))\n\t// \tthis.w = Mathf.max(min.w, Mathf.min(max.w, this.w))\n\n\t// \treturn this\n\t// }\n\n\t// clampScalar(minVal: f32, maxVal: f32): this {\n\t// \tif (min == null || max == null) {\n\t// \t\tmin = new Vector4()\n\t// \t\tmax = new Vector4()\n\t// \t}\n\n\t// \tmin.set(minVal, minVal, minVal, minVal)\n\t// \tmax.set(maxVal, maxVal, maxVal, maxVal)\n\n\t// \treturn this.clamp(min, max)\n\t// }\n\n\t// clampLength(min: f32, max: f32) {\n\t// \tvar length = this.length()\n\n\t// \treturn this.divideScalar(length || 1).multiplyScalar(Mathf.max(min, Mathf.min(max, length)))\n\t// }\n\n\t// floor(): this {\n\t// \tthis.x = Mathf.floor(this.x)\n\t// \tthis.y = Mathf.floor(this.y)\n\t// \tthis.z = Mathf.floor(this.z)\n\t// \tthis.w = Mathf.floor(this.w)\n\n\t// \treturn this\n\t// }\n\n\t// ceil(): this {\n\t// \tthis.x = Mathf.ceil(this.x)\n\t// \tthis.y = Mathf.ceil(this.y)\n\t// \tthis.z = Mathf.ceil(this.z)\n\t// \tthis.w = Mathf.ceil(this.w)\n\n\t// \treturn this\n\t// }\n\n\t// round(): this {\n\t// \tthis.x = Mathf.round(this.x)\n\t// \tthis.y = Mathf.round(this.y)\n\t// \tthis.z = Mathf.round(this.z)\n\t// \tthis.w = Mathf.round(this.w)\n\n\t// \treturn this\n\t// }\n\n\t// roundToZero(): this {\n\t// \tthis.x = this.x < 0 ? Mathf.ceil(this.x) : Mathf.floor(this.x)\n\t// \tthis.y = this.y < 0 ? Mathf.ceil(this.y) : Mathf.floor(this.y)\n\t// \tthis.z = this.z < 0 ? Mathf.ceil(this.z) : Mathf.floor(this.z)\n\t// \tthis.w = this.w < 0 ? Mathf.ceil(this.w) : Mathf.floor(this.w)\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Inverts this vector.\n\t//  */\n\t// negate(): this {\n\t// \tthis.x = -this.x\n\t// \tthis.y = -this.y\n\t// \tthis.z = -this.z\n\t// \tthis.w = -this.w\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Computes dot product of this vector and v.\n\t//  */\n\t// dot(v: Vector4): f32 {\n\t// \treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w\n\t// }\n\n\t// /**\n\t//  * Computes squared length of this vector.\n\t//  */\n\t// lengthSq(): f32 {\n\t// \treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w\n\t// }\n\n\t// /**\n\t//  * Computes length of this vector.\n\t//  */\n\t// length(): f32 {\n\t// \treturn Mathf.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)\n\t// }\n\n\t// /**\n\t//  * Computes the Manhattan length of this vector.\n\t//  *\n\t//  * @return {f32}\n\t//  *\n\t//  * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}\n\t//  */\n\t// manhattanLength(): f32 {\n\t// \treturn Mathf.abs(this.x) + Mathf.abs(this.y) + Mathf.abs(this.z) + Mathf.abs(this.w)\n\t// }\n\n\t// /**\n\t//  * Normalizes this vector.\n\t//  */\n\t// normalize(): this {\n\t// \treturn this.divideScalar(this.length() || 1)\n\t// }\n\n\t// /**\n\t//  * Normalizes this vector and multiplies it by l.\n\t//  */\n\t// setLength(length: f32): this {\n\t// \treturn this.normalize().multiplyScalar(length)\n\t// }\n\n\t// /**\n\t//  * Linearly interpolate between this vector and v with alpha factor.\n\t//  */\n\t// lerp(v: Vector4, alpha: f32): this {\n\t// \tthis.x += (v.x - this.x) * alpha\n\t// \tthis.y += (v.y - this.y) * alpha\n\t// \tthis.z += (v.z - this.z) * alpha\n\t// \tthis.w += (v.w - this.w) * alpha\n\n\t// \treturn this\n\t// }\n\n\t// lerpVectors(v1: Vector4, v2: Vector4, alpha: f32): this {\n\t// \treturn this.subVectors(v2, v1)\n\t// \t\t.multiplyScalar(alpha)\n\t// \t\t.add(v1)\n\t// }\n\n\t/**\n\t * Checks for strict equality of this vector and v.\n\t */\n\tequals(v: Vector4): boolean {\n\t\treturn v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w\n\t}\n\n\t// fromArray(array: [f32, f32, f32, f32], offset: i32 = 0): this {\n\t// \tthis.x = array[offset]\n\t// \tthis.y = array[offset + 1]\n\t// \tthis.z = array[offset + 2]\n\t// \tthis.w = array[offset + 3]\n\n\t// \treturn this\n\t// }\n\n\t// toArray(array: [f32, f32, f32, f32] = [0, 0, 0, 0], offset: i32 = 0): f32[] {\n\t// \tarray[offset] = this.x\n\t// \tarray[offset + 1] = this.y\n\t// \tarray[offset + 2] = this.z\n\t// \tarray[offset + 3] = this.w\n\n\t// \treturn array\n\t// }\n\n\t// fromBufferAttribute(attribute: BufferAttribute, index: i32): this {\n\t// \tthis.x = attribute.getX(index)\n\t// \tthis.y = attribute.getY(index)\n\t// \tthis.z = attribute.getZ(index)\n\t// \tthis.w = attribute.getW(index)\n\n\t// \treturn this\n\t// }\n}\n","/**\n * @author mrdoob / http://mrdoob.com/\n * @author Joe Pea / http://github.com/trusktr\n */\n\nimport * as MathUtils from './MathUtils'\n\nfunction hue2rgb(p: f32, q: f32, t: f32): f32 {\n\tif (t < 0) t += 1\n\tif (t > 1) t -= 1\n\tif (t < 1 / 6) return p + (q - p) * 6 * t\n\tif (t < 1 / 2) return q\n\tif (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t)\n\treturn p\n}\n\n// function handleAlpha(string: ColorKeyword) {\n// \tif (string === undefined) return\n\n// \tif (parseFloat(string) < 1) {\n// \t\tconsole.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.')\n// \t}\n// }\n\nfunction SRGBToLinear(c: f32): f32 {\n\treturn c < 0.04045 ? c * 0.0773993808 : Mathf.pow(c * 0.9478672986 + 0.0521327014, 2.4)\n}\n\nfunction LinearToSRGB(c: f32): f32 {\n\treturn c < 0.0031308 ? c * 12.92 : 1.055 * Mathf.pow(c, 0.41666) - 0.055\n}\n\nexport class HSL {\n\th: f32 = 0\n\ts: f32 = 0\n\tl: f32 = 0\n}\n\nconst hsl: HSL = {h: 0, s: 0, l: 0}\nconst hslA: HSL = {h: 0, s: 0, l: 0}\nconst hslB: HSL = {h: 0, s: 0, l: 0}\n\nexport class Colors {\n\tstatic aliceblue: i32 = 0xf0f8ff\n\tstatic antiquewhite: i32 = 0xfaebd7\n\tstatic aqua: i32 = 0x00ffff\n\tstatic aquamarine: i32 = 0x7fffd4\n\tstatic azure: i32 = 0xf0ffff\n\tstatic beige: i32 = 0xf5f5dc\n\tstatic bisque: i32 = 0xffe4c4\n\tstatic black: i32 = 0x000000\n\tstatic blanchedalmond: i32 = 0xffebcd\n\tstatic blue: i32 = 0x0000ff\n\tstatic blueviolet: i32 = 0x8a2be2\n\tstatic brown: i32 = 0xa52a2a\n\tstatic burlywood: i32 = 0xdeb887\n\tstatic cadetblue: i32 = 0x5f9ea0\n\tstatic chartreuse: i32 = 0x7fff00\n\tstatic chocolate: i32 = 0xd2691e\n\tstatic coral: i32 = 0xff7f50\n\tstatic cornflowerblue: i32 = 0x6495ed\n\tstatic cornsilk: i32 = 0xfff8dc\n\tstatic crimson: i32 = 0xdc143c\n\tstatic cyan: i32 = 0x00ffff\n\tstatic darkblue: i32 = 0x00008b\n\tstatic darkcyan: i32 = 0x008b8b\n\tstatic darkgoldenrod: i32 = 0xb8860b\n\tstatic darkgray: i32 = 0xa9a9a9\n\tstatic darkgreen: i32 = 0x006400\n\tstatic darkgrey: i32 = 0xa9a9a9\n\tstatic darkkhaki: i32 = 0xbdb76b\n\tstatic darkmagenta: i32 = 0x8b008b\n\tstatic darkolivegreen: i32 = 0x556b2f\n\tstatic darkorange: i32 = 0xff8c00\n\tstatic darkorchid: i32 = 0x9932cc\n\tstatic darkred: i32 = 0x8b0000\n\tstatic darksalmon: i32 = 0xe9967a\n\tstatic darkseagreen: i32 = 0x8fbc8f\n\tstatic darkslateblue: i32 = 0x483d8b\n\tstatic darkslategray: i32 = 0x2f4f4f\n\tstatic darkslategrey: i32 = 0x2f4f4f\n\tstatic darkturquoise: i32 = 0x00ced1\n\tstatic darkviolet: i32 = 0x9400d3\n\tstatic deeppink: i32 = 0xff1493\n\tstatic deepskyblue: i32 = 0x00bfff\n\tstatic dimgray: i32 = 0x696969\n\tstatic dimgrey: i32 = 0x696969\n\tstatic dodgerblue: i32 = 0x1e90ff\n\tstatic firebrick: i32 = 0xb22222\n\tstatic floralwhite: i32 = 0xfffaf0\n\tstatic forestgreen: i32 = 0x228b22\n\tstatic fuchsia: i32 = 0xff00ff\n\tstatic gainsboro: i32 = 0xdcdcdc\n\tstatic ghostwhite: i32 = 0xf8f8ff\n\tstatic gold: i32 = 0xffd700\n\tstatic goldenrod: i32 = 0xdaa520\n\tstatic gray: i32 = 0x808080\n\tstatic green: i32 = 0x008000\n\tstatic greenyellow: i32 = 0xadff2f\n\tstatic grey: i32 = 0x808080\n\tstatic honeydew: i32 = 0xf0fff0\n\tstatic hotpink: i32 = 0xff69b4\n\tstatic indianred: i32 = 0xcd5c5c\n\tstatic indigo: i32 = 0x4b0082\n\tstatic ivory: i32 = 0xfffff0\n\tstatic khaki: i32 = 0xf0e68c\n\tstatic lavender: i32 = 0xe6e6fa\n\tstatic lavenderblush: i32 = 0xfff0f5\n\tstatic lawngreen: i32 = 0x7cfc00\n\tstatic lemonchiffon: i32 = 0xfffacd\n\tstatic lightblue: i32 = 0xadd8e6\n\tstatic lightcoral: i32 = 0xf08080\n\tstatic lightcyan: i32 = 0xe0ffff\n\tstatic lightgoldenrodyellow: i32 = 0xfafad2\n\tstatic lightgray: i32 = 0xd3d3d3\n\tstatic lightgreen: i32 = 0x90ee90\n\tstatic lightgrey: i32 = 0xd3d3d3\n\tstatic lightpink: i32 = 0xffb6c1\n\tstatic lightsalmon: i32 = 0xffa07a\n\tstatic lightseagreen: i32 = 0x20b2aa\n\tstatic lightskyblue: i32 = 0x87cefa\n\tstatic lightslategray: i32 = 0x778899\n\tstatic lightslategrey: i32 = 0x778899\n\tstatic lightsteelblue: i32 = 0xb0c4de\n\tstatic lightyellow: i32 = 0xffffe0\n\tstatic lime: i32 = 0x00ff00\n\tstatic limegreen: i32 = 0x32cd32\n\tstatic linen: i32 = 0xfaf0e6\n\tstatic magenta: i32 = 0xff00ff\n\tstatic maroon: i32 = 0x800000\n\tstatic mediumaquamarine: i32 = 0x66cdaa\n\tstatic mediumblue: i32 = 0x0000cd\n\tstatic mediumorchid: i32 = 0xba55d3\n\tstatic mediumpurple: i32 = 0x9370db\n\tstatic mediumseagreen: i32 = 0x3cb371\n\tstatic mediumslateblue: i32 = 0x7b68ee\n\tstatic mediumspringgreen: i32 = 0x00fa9a\n\tstatic mediumturquoise: i32 = 0x48d1cc\n\tstatic mediumvioletred: i32 = 0xc71585\n\tstatic midnightblue: i32 = 0x191970\n\tstatic mintcream: i32 = 0xf5fffa\n\tstatic mistyrose: i32 = 0xffe4e1\n\tstatic moccasin: i32 = 0xffe4b5\n\tstatic navajowhite: i32 = 0xffdead\n\tstatic navy: i32 = 0x000080\n\tstatic oldlace: i32 = 0xfdf5e6\n\tstatic olive: i32 = 0x808000\n\tstatic olivedrab: i32 = 0x6b8e23\n\tstatic orange: i32 = 0xffa500\n\tstatic orangered: i32 = 0xff4500\n\tstatic orchid: i32 = 0xda70d6\n\tstatic palegoldenrod: i32 = 0xeee8aa\n\tstatic palegreen: i32 = 0x98fb98\n\tstatic paleturquoise: i32 = 0xafeeee\n\tstatic palevioletred: i32 = 0xdb7093\n\tstatic papayawhip: i32 = 0xffefd5\n\tstatic peachpuff: i32 = 0xffdab9\n\tstatic peru: i32 = 0xcd853f\n\tstatic pink: i32 = 0xffc0cb\n\tstatic plum: i32 = 0xdda0dd\n\tstatic powderblue: i32 = 0xb0e0e6\n\tstatic purple: i32 = 0x800080\n\tstatic rebeccapurple: i32 = 0x663399\n\tstatic red: i32 = 0xff0000\n\tstatic rosybrown: i32 = 0xbc8f8f\n\tstatic royalblue: i32 = 0x4169e1\n\tstatic saddlebrown: i32 = 0x8b4513\n\tstatic salmon: i32 = 0xfa8072\n\tstatic sandybrown: i32 = 0xf4a460\n\tstatic seagreen: i32 = 0x2e8b57\n\tstatic seashell: i32 = 0xfff5ee\n\tstatic sienna: i32 = 0xa0522d\n\tstatic silver: i32 = 0xc0c0c0\n\tstatic skyblue: i32 = 0x87ceeb\n\tstatic slateblue: i32 = 0x6a5acd\n\tstatic slategray: i32 = 0x708090\n\tstatic slategrey: i32 = 0x708090\n\tstatic snow: i32 = 0xfffafa\n\tstatic springgreen: i32 = 0x00ff7f\n\tstatic steelblue: i32 = 0x4682b4\n\tstatic tan: i32 = 0xd2b48c\n\tstatic teal: i32 = 0x008080\n\tstatic thistle: i32 = 0xd8bfd8\n\tstatic tomato: i32 = 0xff6347\n\tstatic turquoise: i32 = 0x40e0d0\n\tstatic violet: i32 = 0xee82ee\n\tstatic wheat: i32 = 0xf5deb3\n\tstatic white: i32 = 0xffffff\n\tstatic whitesmoke: i32 = 0xf5f5f5\n\tstatic yellow: i32 = 0xffff00\n\tstatic yellowgreen: i32 = 0x9acd32\n}\n\n/**\n * Represents a color. See also {@link ColorUtils}.\n *\n * @example\n * const color = new THREE.Color( 0xff0000 );\n *\n * @see <a href=\"https://github.com/mrdoob/three.js/blob/master/src/math/Color\">src/math/Color</a>\n */\nexport class Color {\n\t/**\n\t * Red channel value between 0 and 1. Default is 1.\n\t */\n\tr: f32\n\n\t/**\n\t * Green channel value between 0 and 1. Default is 1.\n\t */\n\tg: f32\n\n\t/**\n\t * Blue channel value between 0 and 1. Default is 1.\n\t */\n\tb: f32\n\n\t// TODO: dynamic signature: `constructor(r?: Color | ColorKeyword | f32, g?:\n\t// f32, b?: f32)` See:\n\t// https://github.com/AssemblyScript/assemblyscript/issues/646 and\n\t// https://github.com/AssemblyScript/assemblyscript/issues/639\n\tconstructor(r: f32 = 0, g: f32 = 0, b: f32 = 0) {\n\t\tthis.setRGB(r, g, b)\n\t}\n\n\treadonly isColor: boolean = true\n\n\t/**\n\t * Allows multiple ways of creating a color. F.e. `new\n\t * Color().set(otherColor)`, `new Color(r, g, b)`, `new\n\t * Color().set('blue')`, `new Color().set('#ff6600')`, or `new\n\t * Color().set(0xff6600)`\n\t */\n\t// set(color: Color): this\n\t// set(color: i32): this\n\t// set(r: f32, g: f32, b: f32): this\n\t// set(color: string): this TODO\n\tset<T>(colorOrR: T, g: f32 = 0, b: f32 = 0): this {\n\t\tif (colorOrR instanceof Color) this.copy(colorOrR)\n\t\telse if (isInteger(colorOrR)) this.setHex(colorOrR)\n\t\telse if (isFloat(colorOrR)) this.setRGB(f32(colorOrR), g, b)\n\t\t// TODO, no strings yet, because setStyle uses RegExp, and AS doesn't\n\t\t// have RegExp yet, but we can try to use assemblyscript-regex\n\t\t// which may eventually make it into AS.\n\t\t// https://github.com/ColinEberhardt/assemblyscript-regex else if\n\t\t// (isString<T>(color)) this.setStyle(color)\n\t\telse throw new Error('Color.set: invalid arg')\n\n\t\treturn this\n\t}\n\n\tsetScalar(scalar: f32): this {\n\t\tthis.r = scalar\n\t\tthis.g = scalar\n\t\tthis.b = scalar\n\n\t\treturn this\n\t}\n\n\tsetHex(hex: i32): this {\n\t\tthis.r = f32((hex >> 16) & 255) / 255\n\t\tthis.g = f32((hex >> 8) & 255) / 255\n\t\tthis.b = f32((hex >> 0) & 255) / 255\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Sets this color from RGB values.\n\t * @param r Red channel value between 0 and 1.\n\t * @param g Green channel value between 0 and 1.\n\t * @param b Blue channel value between 0 and 1.\n\t */\n\tsetRGB(r: f32, g: f32, b: f32): this {\n\t\tthis.r = r\n\t\tthis.g = g\n\t\tthis.b = b\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Sets this color from HSL values.\n\t * Based on MochiKit implementation by Bob Ippolito.\n\t *\n\t * @param h Hue channel value between 0 and 1.\n\t * @param s Saturation value channel between 0 and 1.\n\t * @param l Value channel value between 0 and 1.\n\t */\n\t// TODO, test not working, see test.\n\t// setHSL(h: f32, s: f32, l: f32): this {\n\t// \t// h,s,l ranges are in 0.0 - 1.0\n\t// \th = _Math.euclideanModulo(h, 1)\n\t// \ts = _Math.clamp(s, 0, 1)\n\t// \tl = _Math.clamp(l, 0, 1)\n\n\t// \tif (s === 0) {\n\t// \t\tthis.r = this.g = this.b = l\n\t// \t} else {\n\t// \t\tconst p = l <= 0.5 ? l * (1 + s) : l + s - l * s\n\t// \t\tconst q = 2 * l - p\n\n\t// \t\tthis.r = hue2rgb(q, p, h + 1 / 3)\n\t// \t\tthis.g = hue2rgb(q, p, h)\n\t// \t\tthis.b = hue2rgb(q, p, h - 1 / 3)\n\t// \t}\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Sets this color from a CSS context style string.\n\t * @param contextStyle Color in CSS context style format.\n\t */\n\t// TODO, regexp handling is TODO in AS. We could manually parse the strings.\n\t// setStyle(style: string): this {\n\t// \tconst m\n\n\t// \tif ((m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec(style))) {\n\t// \t\t// rgb / hsl\n\n\t// \t\tconst color\n\t// \t\tconst name = m[1]\n\t// \t\tconst components = m[2]\n\n\t// \t\tswitch (name) {\n\t// \t\t\tcase 'rgb':\n\t// \t\t\tcase 'rgba':\n\t// \t\t\t\tif ((color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components))) {\n\t// \t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\n\t// \t\t\t\t\tthis.r = Mathf.min(255, parseInt(color[1], 10)) / 255\n\t// \t\t\t\t\tthis.g = Mathf.min(255, parseInt(color[2], 10)) / 255\n\t// \t\t\t\t\tthis.b = Mathf.min(255, parseInt(color[3], 10)) / 255\n\n\t// \t\t\t\t\thandleAlpha(color[5])\n\n\t// \t\t\t\t\treturn this\n\t// \t\t\t\t}\n\n\t// \t\t\t\tif (\n\t// \t\t\t\t\t(color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(components))\n\t// \t\t\t\t) {\n\t// \t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\n\t// \t\t\t\t\tthis.r = Mathf.min(100, parseInt(color[1], 10)) / 100\n\t// \t\t\t\t\tthis.g = Mathf.min(100, parseInt(color[2], 10)) / 100\n\t// \t\t\t\t\tthis.b = Mathf.min(100, parseInt(color[3], 10)) / 100\n\n\t// \t\t\t\t\thandleAlpha(color[5])\n\n\t// \t\t\t\t\treturn this\n\t// \t\t\t\t}\n\n\t// \t\t\t\tbreak\n\n\t// \t\t\tcase 'hsl':\n\t// \t\t\tcase 'hsla':\n\t// \t\t\t\tif (\n\t// \t\t\t\t\t(color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec(\n\t// \t\t\t\t\t\tcomponents\n\t// \t\t\t\t\t))\n\t// \t\t\t\t) {\n\t// \t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\n\t// \t\t\t\t\tconst h = parseFloat(color[1]) / 360\n\t// \t\t\t\t\tconst s = parseInt(color[2], 10) / 100\n\t// \t\t\t\t\tconst l = parseInt(color[3], 10) / 100\n\n\t// \t\t\t\t\thandleAlpha(color[5])\n\n\t// \t\t\t\t\treturn this.setHSL(h, s, l)\n\t// \t\t\t\t}\n\n\t// \t\t\t\tbreak\n\t// \t\t}\n\t// \t} else if ((m = /^\\#([A-Fa-f0-9]+)$/.exec(style))) {\n\t// \t\t// hex color\n\n\t// \t\tconst hex = m[1]\n\t// \t\tconst size = hex.length\n\n\t// \t\tif (size === 3) {\n\t// \t\t\t// #ff0\n\t// \t\t\tthis.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255\n\t// \t\t\tthis.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255\n\t// \t\t\tthis.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255\n\n\t// \t\t\treturn this\n\t// \t\t} else if (size === 6) {\n\t// \t\t\t// #ff0000\n\t// \t\t\tthis.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255\n\t// \t\t\tthis.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255\n\t// \t\t\tthis.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255\n\n\t// \t\t\treturn this\n\t// \t\t}\n\t// \t}\n\n\t// \tif (style && style.length > 0) {\n\t// \t\t// color keywords\n\t// \t\tconst hex = ColorKeywords[style]\n\n\t// \t\tif (hex !== undefined) {\n\t// \t\t\t// red\n\t// \t\t\tthis.setHex(hex)\n\t// \t\t} else {\n\t// \t\t\t// unknown color\n\t// \t\t\tconsole.warn('THREE.Color: Unknown color ' + style)\n\t// \t\t}\n\t// \t}\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Clones this color.\n\t */\n\tclone(): Color {\n\t\treturn new Color(this.r, this.g, this.b)\n\t}\n\n\t/**\n\t * Copies given color.\n\t * @param color Color to copy.\n\t */\n\tcopy(color: Color): this {\n\t\tthis.r = color.r\n\t\tthis.g = color.g\n\t\tthis.b = color.b\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Copies given color making conversion from gamma to linear space.\n\t * @param color Color to copy.\n\t */\n\tcopyGammaToLinear(color: Color, gammaFactor: f32 = 2): this {\n\t\tthis.r = Mathf.pow(color.r, gammaFactor)\n\t\tthis.g = Mathf.pow(color.g, gammaFactor)\n\t\tthis.b = Mathf.pow(color.b, gammaFactor)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Copies given color making conversion from linear to gamma space.\n\t * @param color Color to copy.\n\t */\n\tcopyLinearToGamma(color: Color, gammaFactor: f32 = 2): this {\n\t\tconst safeInverse: f32 = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0\n\n\t\tthis.r = Mathf.pow(color.r, safeInverse)\n\t\tthis.g = Mathf.pow(color.g, safeInverse)\n\t\tthis.b = Mathf.pow(color.b, safeInverse)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Converts this color from gamma to linear space.\n\t */\n\tconvertGammaToLinear(gammaFactor: f32 = 2): this {\n\t\tthis.copyGammaToLinear(this, gammaFactor)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Converts this color from linear to gamma space.\n\t */\n\tconvertLinearToGamma(gammaFactor: f32 = 2): this {\n\t\tthis.copyLinearToGamma(this, gammaFactor)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Copies given color making conversion from sRGB to linear space.\n\t * @param color Color to copy.\n\t */\n\tcopySRGBToLinear(color: Color): this {\n\t\tthis.r = SRGBToLinear(color.r)\n\t\tthis.g = SRGBToLinear(color.g)\n\t\tthis.b = SRGBToLinear(color.b)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Copies given color making conversion from linear to sRGB space.\n\t * @param color Color to copy.\n\t */\n\tcopyLinearToSRGB(color: Color): this {\n\t\tthis.r = LinearToSRGB(color.r)\n\t\tthis.g = LinearToSRGB(color.g)\n\t\tthis.b = LinearToSRGB(color.b)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Converts this color from sRGB to linear space.\n\t */\n\tconvertSRGBToLinear(): this {\n\t\tthis.copySRGBToLinear(this)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Converts this color from linear to sRGB space.\n\t */\n\tconvertLinearToSRGB(): this {\n\t\tthis.copyLinearToSRGB(this)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Returns the hexadecimal value of this color.\n\t */\n\tgetHex(): i32 {\n\t\t// prettier-ignore\n\t\treturn (\n\t\t\t(i32(this.r * 255.0) << 16) ^\n\t\t\t(i32(this.g * 255.0) << 8) ^\n\t\t\t(i32(this.b * 255.0) << 0)\n\t\t)\n\t}\n\n\t/**\n\t * Returns the string formated hexadecimal value of this color.\n\t */\n\tgetHexString(): string {\n\t\treturn ('000000' + this.getHex().toString(16)).slice(-6)\n\t}\n\n\t// TODO, not working, see test\n\t// getHSL(target: HSL): HSL {\n\t// \t// h,s,l ranges are in 0.0 - 1.0\n\n\t// \tconst r: f32 = this.r,\n\t// \t\tg: f32 = this.g,\n\t// \t\tb: f32 = this.b\n\n\t// \tconst maxRG: f32 = Mathf.max(r, g)\n\t// \tconst max: f32 = Mathf.max(maxRG, b)\n\n\t// \tconst minRG: f32 = Mathf.max(r, g)\n\t// \tconst min: f32 = Mathf.min(minRG, b)\n\n\t// \tlet hue: f32 = 0\n\t// \tlet saturation: f32 = 0\n\t// \tconst lightness: f32 = (min + max) / 2.0\n\n\t// \tif (min === max) {\n\t// \t\thue = 0\n\t// \t\tsaturation = 0\n\t// \t} else {\n\t// \t\tconst delta = max - min\n\n\t// \t\tsaturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min)\n\n\t// \t\t// switch (max) {\n\t// \t\t// \tcase r:\n\t// \t\t// \t\thue = (g - b) / delta + (g < b ? 6 : 0)\n\t// \t\t// \t\tbreak\n\t// \t\t// \tcase g:\n\t// \t\t// \t\thue = (b - r) / delta + 2\n\t// \t\t// \t\tbreak\n\t// \t\t// \tcase b:\n\t// \t\t// \t\thue = (r - g) / delta + 4\n\t// \t\t// \t\tbreak\n\t// \t\t// }\n\n\t// \t\tif (max == r) {\n\t// \t\t\thue = (g - b) / delta + (g < b ? 6 : 0)\n\t// \t\t} else if (max == g) {\n\t// \t\t\thue = (b - r) / delta + 2\n\t// \t\t} else if (max == b) {\n\t// \t\t\thue = (r - g) / delta + 4\n\t// \t\t}\n\n\t// \t\thue /= 6\n\t// \t}\n\n\t// \ttarget.h = hue\n\t// \ttarget.s = saturation\n\t// \ttarget.l = lightness\n\n\t// \treturn target\n\t// }\n\n\t/**\n\t * Returns the value of this color in CSS context style.\n\t * Example: rgb(r, g, b)\n\t */\n\tgetStyle(): string {\n\t\tconst R = i32(this.r * 255)\n\t\tconst G = i32(this.g * 255)\n\t\tconst B = i32(this.b * 255)\n\n\t\treturn 'rgb(' + R.toString() + ',' + G.toString() + ',' + B.toString() + ')'\n\t}\n\n\t// TODO\n\t// offsetHSL(h: f32, s: f32, l: f32): this {\n\t// \tthis.getHSL(hsl)\n\n\t// \thsl.h += h\n\t// \thsl.s += s\n\t// \thsl.l += l\n\n\t// \tthis.setHSL(hsl.h, hsl.s, hsl.l)\n\n\t// \treturn this\n\t// }\n\n\tadd(color: Color): this {\n\t\tthis.r += color.r\n\t\tthis.g += color.g\n\t\tthis.b += color.b\n\n\t\treturn this\n\t}\n\n\taddColors(color1: Color, color2: Color): this {\n\t\tthis.r = color1.r + color2.r\n\t\tthis.g = color1.g + color2.g\n\t\tthis.b = color1.b + color2.b\n\n\t\treturn this\n\t}\n\n\taddScalar(s: f32): this {\n\t\tthis.r += s\n\t\tthis.g += s\n\t\tthis.b += s\n\n\t\treturn this\n\t}\n\n\tsub(color: Color): this {\n\t\tthis.r = Mathf.max(0, this.r - color.r)\n\t\tthis.g = Mathf.max(0, this.g - color.g)\n\t\tthis.b = Mathf.max(0, this.b - color.b)\n\n\t\treturn this\n\t}\n\n\tmultiply(color: Color): this {\n\t\tthis.r *= color.r\n\t\tthis.g *= color.g\n\t\tthis.b *= color.b\n\n\t\treturn this\n\t}\n\n\tmultiplyScalar(s: f32): this {\n\t\tthis.r *= s\n\t\tthis.g *= s\n\t\tthis.b *= s\n\n\t\treturn this\n\t}\n\n\tlerp(color: Color, alpha: f32): this {\n\t\tthis.r += (color.r - this.r) * alpha\n\t\tthis.g += (color.g - this.g) * alpha\n\t\tthis.b += (color.b - this.b) * alpha\n\n\t\treturn this\n\t}\n\n\t// lerpHSL(color: Color, alpha: f32): this {\n\t// \tthis.getHSL(hslA)\n\t// \tcolor.getHSL(hslB)\n\n\t// \tconst h = _Math.lerp(hslA.h, hslB.h, alpha)\n\t// \tconst s = _Math.lerp(hslA.s, hslB.s, alpha)\n\t// \tconst l = _Math.lerp(hslA.l, hslB.l, alpha)\n\n\t// \tthis.setHSL(h, s, l)\n\n\t// \treturn this\n\t// }\n\n\tequals(c: Color): boolean {\n\t\treturn c.r === this.r && c.g === this.g && c.b === this.b\n\t}\n\n\tfromArray(array: f32[], offset: i32 = 0): this {\n\t\tthis.r = array[offset]\n\t\tthis.g = array[offset + 1]\n\t\tthis.b = array[offset + 2]\n\n\t\treturn this\n\t}\n\n\ttoArray(array: f32[] = [], offset: i32 = 0): f32[] {\n\t\tarray[offset] = this.r\n\t\tarray[offset + 1] = this.g\n\t\tarray[offset + 2] = this.b\n\n\t\treturn array\n\t}\n\n\ttoJSON(): i32 {\n\t\treturn this.getHex()\n\t}\n}\n","/**\n * @author mrdoob / http://mrdoob.com/\n * @author kile / http://kile.stravaganza.org/\n * @author philogb / http://blog.thejit.org/\n * @author mikael emtinger / http://gomo.se/\n * @author egraether / http://egraether.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author corruptedzulu / http://github.com/corruptedzulu\n * @author Joe Pea / http://github.com/trusktr\n */\n\n// import {Quaternion} from './Quaternion'\nimport * as MathUtils from './MathUtils'\n// import {Euler} from './Euler'\nimport {Matrix3} from './Matrix3'\nimport {Matrix4} from './Matrix4'\n// import {Camera} from './../cameras/Camera'\n// import {Spherical} from './Spherical'\n// import {Cylindrical} from './Cylindrical'\n// import {Vector} from './Vector2'\n// import {BufferAttribute} from '../core/BufferAttribute'\n\n/**\n * 3D vector.\n *\n * @example\n * const a = new THREE.Vector3( 1, 0, 0 );\n * const b = new THREE.Vector3( 0, 1, 0 );\n * const c = new THREE.Vector3();\n * c.crossVectors( a, b );\n *\n * @see <a href=\"https://github.com/mrdoob/three.js/blob/master/src/math/Vector3\">src/math/Vector3</a>\n *\n * ( class Vector3 implements Vector<Vector3> )\n */\nexport class Vector3 /*implements Vector*/ {\n\tx: f32\n\ty: f32\n\tz: f32\n\tisVector3: bool = true\n\n\tconstructor(x: f32 = 0, y: f32 = 0, z: f32 = 0) {\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.z = z\n\t}\n\n\t/**\n\t * Sets value of this vector.\n\t */\n\tset(x: f32, y: f32, z: f32): this {\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.z = z\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Sets all values of this vector.\n\t//  */\n\t// setScalar(scalar: f32): this {\n\t// \tthis.x = scalar\n\t// \tthis.y = scalar\n\t// \tthis.z = scalar\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Sets x value of this vector.\n\t */\n\tsetX(x: f32): this {\n\t\tthis.x = x\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Sets y value of this vector.\n\t */\n\tsetY(y: f32): this {\n\t\tthis.y = y\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Sets z value of this vector.\n\t */\n\tsetZ(z: f32): this {\n\t\tthis.z = z\n\n\t\treturn this\n\t}\n\n\tprivate __xChar: u32 = u32('x'.charCodeAt(0))\n\tprivate __yChar: u32 = u32('y'.charCodeAt(0))\n\tprivate __zChar: u32 = u32('z'.charCodeAt(0))\n\tprivate __invalidNameMsg: string = 'Invalid component name. Exected \"x\", \"y\", or \"z\".'\n\n\tsetComponent(name: string, value: f32): this {\n\t\tif (name.length != 1) throw new Error(this.__invalidNameMsg)\n\n\t\t// prettier-ignore\n\t\t// Note, AS only supports u32 values (f.e. enums) in switch statements, that's why we cast.\n\t\tswitch (u32(name.charCodeAt(0))) {\n\t\t\tcase this.__xChar: return this.setX(value)\n\t\t\tcase this.__yChar: return this.setY(value)\n\t\t\tcase this.__zChar: return this.setZ(value)\n\t\t\tdefault: throw new Error(this.__invalidNameMsg)\n\t\t}\n\t}\n\n\tgetComponent(name: string): f32 {\n\t\tif (name.length != 1) throw new Error(this.__invalidNameMsg)\n\n\t\t// prettier-ignore\n\t\t// Note, AS only supports u32 values (f.e. enums) in switch statements, that's why we cast.\n\t\tswitch (u32(name.charCodeAt(0))) {\n\t\t\tcase this.__xChar: return this.x\n\t\t\tcase this.__yChar: return this.y\n\t\t\tcase this.__zChar: return this.z\n\t\t\tdefault: throw new Error(this.__invalidNameMsg)\n\t\t}\n\t}\n\n\t// /**\n\t//  * Clones this vector.\n\t//  */\n\tclone(): Vector3 {\n\t\treturn new Vector3(this.x, this.y, this.z)\n\t}\n\n\t/**\n\t * Copies value of v to this vector.\n\t */\n\tcopy(v: Vector3): this {\n\t\tthis.x = v.x\n\t\tthis.y = v.y\n\t\tthis.z = v.z\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Adds v to this vector.\n\t */\n\tadd(a: Vector3): this {\n\t\tthis.x += a.x\n\t\tthis.y += a.y\n\t\tthis.z += a.z\n\n\t\treturn this\n\t}\n\n\taddScalar(s: f32): this {\n\t\tthis.x += s\n\t\tthis.y += s\n\t\tthis.z += s\n\n\t\treturn this\n\t}\n\n\t// addScaledVector(v: Vector3, s: f32): this {\n\t// \tthis.x += v.x * s\n\t// \tthis.y += v.y * s\n\t// \tthis.z += v.z * s\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Sets this vector to a + b.\n\t */\n\taddVectors(a: Vector3, b: Vector3): this {\n\t\tthis.x = a.x + b.x\n\t\tthis.y = a.y + b.y\n\t\tthis.z = a.z + b.z\n\n\t\treturn this\n\t}\n\n\t// /**\n\t//  * Subtracts v from this vector.\n\t//  */\n\tsub(a: Vector3): this {\n\t\t// if ( w !== undefined ) {\n\n\t\t// \tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\n\t\t// \treturn this.subVectors( v, w );\n\n\t\t// }\n\n\t\tthis.x -= a.x\n\t\tthis.y -= a.y\n\t\tthis.z -= a.z\n\n\t\treturn this\n\t}\n\n\t// subScalar(s: f32): this {\n\t// \tthis.x -= s\n\t// \tthis.y -= s\n\t// \tthis.z -= s\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Sets this vector to a - b.\n\t */\n\tsubVectors(a: Vector3, b: Vector3): this {\n\t\tthis.x = a.x - b.x\n\t\tthis.y = a.y - b.y\n\t\tthis.z = a.z - b.z\n\n\t\treturn this\n\t}\n\n\t// multiply(v: Vector3): this {\n\t// \t// if ( w !== undefined ) {\n\n\t// \t// \tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\n\t// \t// \treturn this.multiplyVectors( v, w );\n\n\t// \t// }\n\n\t// \tthis.x *= v.x\n\t// \tthis.y *= v.y\n\t// \tthis.z *= v.z\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Multiplies this vector by scalar s.\n\t */\n\tmultiplyScalar(scalar: f32): this {\n\t\tthis.x *= scalar\n\t\tthis.y *= scalar\n\t\tthis.z *= scalar\n\n\t\treturn this\n\t}\n\n\t// multiplyVectors(a: Vector3, b: Vector3): this {\n\t// \tthis.x = a.x * b.x\n\t// \tthis.y = a.y * b.y\n\t// \tthis.z = a.z * b.z\n\n\t// \treturn this\n\t// }\n\n\t// applyEuler(euler: Euler): this {\n\t// \tvar quaternion = new Quaternion()\n\n\t// \t// if ( ! ( euler && euler.isEuler ) ) {\n\n\t// \t//     console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\n\n\t// \t// }\n\n\t// \treturn this.applyQuaternion(quaternion.setFromEuler(euler))\n\t// }\n\n\t// applyAxisAngle(axis: Vector3, angle: f32): this {\n\t// \tvar quaternion = new Quaternion()\n\n\t// \treturn this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle))\n\t// }\n\n\tapplyMatrix3(m: Matrix3): this {\n\t\tconst x = this.x,\n\t\t\ty = this.y,\n\t\t\tz = this.z\n\t\tconst e = m.elements\n\n\t\tthis.x = e[0] * x + e[3] * y + e[6] * z\n\t\tthis.y = e[1] * x + e[4] * y + e[7] * z\n\t\tthis.z = e[2] * x + e[5] * y + e[8] * z\n\n\t\treturn this\n\t}\n\n\tapplyMatrix4(m: Matrix4): this {\n\t\tconst x = this.x,\n\t\t\ty = this.y,\n\t\t\tz = this.z\n\t\tconst e = m.elements\n\n\t\tconst w = f32(1 / (e[3] * x + e[7] * y + e[11] * z + e[15]))\n\n\t\tthis.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w\n\t\tthis.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w\n\t\tthis.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w\n\n\t\treturn this\n\t}\n\n\t// applyQuaternion(q: Quaternion): this {\n\t// \tvar x = this.x,\n\t// \t\ty = this.y,\n\t// \t\tz = this.z\n\t// \tvar qx = q.x,\n\t// \t\tqy = q.y,\n\t// \t\tqz = q.z,\n\t// \t\tqw = q.w\n\n\t// \t// calculate quat * vector\n\n\t// \tvar ix = qw * x + qy * z - qz * y\n\t// \tvar iy = qw * y + qz * x - qx * z\n\t// \tvar iz = qw * z + qx * y - qy * x\n\t// \tvar iw = -qx * x - qy * y - qz * z\n\n\t// \t// calculate result * inverse quat\n\n\t// \tthis.x = ix * qw + iw * -qx + iy * -qz - iz * -qy\n\t// \tthis.y = iy * qw + iw * -qy + iz * -qx - ix * -qz\n\t// \tthis.z = iz * qw + iw * -qz + ix * -qy - iy * -qx\n\n\t// \treturn this\n\t// }\n\n\t// project(camera: Camera): this {\n\t// \treturn this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix)\n\t// }\n\n\t// unproject(camera: Camera): this {\n\t// \treturn this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld)\n\t// }\n\n\ttransformDirection(m: Matrix4): this {\n\t\t// input: THREE.Matrix4 affine matrix\n\t\t// vector interpreted as a direction\n\n\t\tconst x = this.x,\n\t\t\ty = this.y,\n\t\t\tz = this.z\n\t\tconst e = m.elements\n\n\t\tthis.x = e[0] * x + e[4] * y + e[8] * z\n\t\tthis.y = e[1] * x + e[5] * y + e[9] * z\n\t\tthis.z = e[2] * x + e[6] * y + e[10] * z\n\n\t\treturn this.normalize()\n\t}\n\n\t// divide(v: Vector3): this {\n\t// \tthis.x /= v.x\n\t// \tthis.y /= v.y\n\t// \tthis.z /= v.z\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Divides this vector by scalar.\n\t * Set vector to ( 0, 0, 0 ) if s == 0.\n\t */\n\tdivideScalar(scalar: f32): this {\n\t\treturn this.multiplyScalar(1 / scalar)\n\t}\n\n\tmin(v: Vector3): this {\n\t\tthis.x = Mathf.min(this.x, v.x)\n\t\tthis.y = Mathf.min(this.y, v.y)\n\t\tthis.z = Mathf.min(this.z, v.z)\n\n\t\treturn this\n\t}\n\n\tmax(v: Vector3): this {\n\t\tthis.x = Mathf.max(this.x, v.x)\n\t\tthis.y = Mathf.max(this.y, v.y)\n\t\tthis.z = Mathf.max(this.z, v.z)\n\n\t\treturn this\n\t}\n\n\t// clamp(min: Vector3, max: Vector3): this {\n\t// \tthis.x = Mathf.max(min.x, Mathf.min(max.x, this.x))\n\t// \tthis.y = Mathf.max(min.y, Mathf.min(max.y, this.y))\n\t// \tthis.z = Mathf.max(min.z, Mathf.min(max.z, this.z))\n\n\t// \treturn this\n\t// }\n\n\t// clampScalar(min: f32, max: f32): this {\n\t// \tthis.x = Mathf.max(min, Mathf.min(max, this.x))\n\t// \tthis.y = Mathf.max(min, Mathf.min(max, this.y))\n\t// \tthis.z = Mathf.max(min, Mathf.min(max, this.z))\n\n\t// \treturn this\n\t// }\n\n\t// clampLength(min: f32, max: f32): this {\n\t// \tvar length = this.length\n\n\t// \treturn this.divideScalar(length || 1).multiplyScalar(Mathf.max(min, Mathf.min(max, length)))\n\t// }\n\n\t// floor(): this {\n\t// \tthis.x = Mathf.floor(this.x)\n\t// \tthis.y = Mathf.floor(this.y)\n\t// \tthis.z = Mathf.floor(this.z)\n\n\t// \treturn this\n\t// }\n\n\t// ceil(): this {\n\t// \tthis.x = Mathf.ceil(this.x)\n\t// \tthis.y = Mathf.ceil(this.y)\n\t// \tthis.z = Mathf.ceil(this.z)\n\n\t// \treturn this\n\t// }\n\n\t// round(): this {\n\t// \tthis.x = Mathf.round(this.x)\n\t// \tthis.y = Mathf.round(this.y)\n\t// \tthis.z = Mathf.round(this.z)\n\n\t// \treturn this\n\t// }\n\n\t// roundToZero(): this {\n\t// \tthis.x = this.x < 0 ? Mathf.ceil(this.x) : Mathf.floor(this.x)\n\t// \tthis.y = this.y < 0 ? Mathf.ceil(this.y) : Mathf.floor(this.y)\n\t// \tthis.z = this.z < 0 ? Mathf.ceil(this.z) : Mathf.floor(this.z)\n\n\t// \treturn this\n\t// }\n\n\t/**\n\t * Inverts this vector.\n\t */\n\tnegate(): this {\n\t\tthis.x = -this.x\n\t\tthis.y = -this.y\n\t\tthis.z = -this.z\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Computes dot product of this vector and v.\n\t */\n\tdot(v: Vector3): f32 {\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z\n\t}\n\n\t// /**\n\t//  * Computes squared length of this vector.\n\t//  */\n\tlengthSq(): f32 {\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z\n\t}\n\n\t/**\n\t * Computes length of this vector.\n\t */\n\tlength(): f32 {\n\t\treturn Mathf.sqrt(this.lengthSq())\n\t}\n\n\t// /**\n\t//  * Computes the Manhattan length of this vector.\n\t//  *\n\t//  * @return {f32}\n\t//  *\n\t//  * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}\n\t//  */\n\t// manhattanLength(): f32 {\n\t// \treturn Mathf.abs(this.x) + Mathf.abs(this.y) + Mathf.abs(this.z)\n\t// }\n\n\t/**\n\t * Normalizes this vector.\n\t */\n\tnormalize(): this {\n\t\treturn this.divideScalar(this.length() || 1)\n\t}\n\n\t// /**\n\t//  * Normalizes this vector and multiplies it by l.\n\t//  */\n\t// setLength(length: f32): this {\n\t// \treturn this.normalize().multiplyScalar(length)\n\t// }\n\n\t// lerp(v: Vector3, alpha: f32): this {\n\t// \tthis.x += (v.x - this.x) * alpha\n\t// \tthis.y += (v.y - this.y) * alpha\n\t// \tthis.z += (v.z - this.z) * alpha\n\n\t// \treturn this\n\t// }\n\n\t// lerpVectors(v1: Vector3, v2: Vector3, alpha: f32): this {\n\t// \treturn this.subVectors(v2, v1)\n\t// \t\t.multiplyScalar(alpha)\n\t// \t\t.add(v1)\n\t// }\n\n\t/**\n\t * Sets this vector to cross product of itself and v.\n\t */\n\tcross(a: Vector3): this {\n\t\t// if ( w !== undefined ) {\n\n\t\t// \tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\n\t\t// \treturn this.crossVectors( v, w );\n\n\t\t// }\n\n\t\treturn this.crossVectors(this, a)\n\t}\n\n\t/**\n\t * Sets this vector to cross product of a and b.\n\t */\n\tcrossVectors(a: Vector3, b: Vector3): this {\n\t\tconst ax = a.x,\n\t\t\tay = a.y,\n\t\t\taz = a.z\n\t\tconst bx = b.x,\n\t\t\tby = b.y,\n\t\t\tbz = b.z\n\n\t\tthis.x = ay * bz - az * by\n\t\tthis.y = az * bx - ax * bz\n\t\tthis.z = ax * by - ay * bx\n\n\t\treturn this\n\t}\n\n\t// projectOnVector(vector: Vector3): this {\n\t// \tvar scalar = vector.dot(this) / vector.lengthSq()\n\n\t// \treturn this.copy(vector).multiplyScalar(scalar)\n\t// }\n\n\t// projectOnPlane(planeNormal: Vector3): this {\n\t// \tvar v1 = new Vector3(0, 0, 0)\n\n\t// \tv1.copy(this).projectOnVector(planeNormal)\n\n\t// \treturn this.sub(v1)\n\t// }\n\n\t// reflect(vector: Vector3): this {\n\t// \t// reflect incident vector off plane orthogonal to normal\n\t// \t// normal is assumed to have unit length\n\n\t// \tvar v1 = new Vector3(0, 0, 0)\n\t// \tvar normal = new Vector3(1, 1, 1)\n\n\t// \treturn this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)))\n\t// }\n\n\t// angleTo(v: Vector3): f32 {\n\t// \tvar theta = this.dot(v) / Mathf.sqrt(this.lengthSq() * v.lengthSq())\n\n\t// \t// clamp, to handle numerical problems\n\n\t// \treturn Mathf.acos(_Math.clamp(theta, -1, 1))\n\t// }\n\n\t/**\n\t * Computes distance of this vector to v.\n\t */\n\tdistanceTo(v: Vector3): f32 {\n\t\treturn Mathf.sqrt(this.distanceToSquared(v))\n\t}\n\n\t/**\n\t * Computes squared distance of this vector to v.\n\t */\n\tdistanceToSquared(v: Vector3): f32 {\n\t\tconst dx = this.x - v.x,\n\t\t\tdy = this.y - v.y,\n\t\t\tdz = this.z - v.z\n\n\t\treturn dx * dx + dy * dy + dz * dz\n\t}\n\n\t// /**\n\t//  * Computes the Manhattan length (distance) from this vector to the given vector v\n\t//  *\n\t//  * @param {Vector3} v\n\t//  *\n\t//  * @return {f32}\n\t//  *\n\t//  * @see {@link http://en.wikipedia.org/wiki/Taxicab_geometry|Wikipedia: Taxicab Geometry}\n\t//  */\n\t// manhattanDistanceTo(v: Vector3): f32 {\n\t// \treturn Mathf.abs(this.x - v.x) + Mathf.abs(this.y - v.y) + Mathf.abs(this.z - v.z)\n\t// }\n\n\t// setFromSpherical(s: Spherical): this {\n\t// \treturn this.setFromSphericalCoords(s.radius, s.phi, s.theta)\n\t// }\n\n\t// setFromSphericalCoords(radius: f32, phi: f32, theta: f32): this {\n\t// \tvar sinPhiRadius = Mathf.sin(phi) * radius\n\n\t// \tthis.x = sinPhiRadius * Mathf.sin(theta)\n\t// \tthis.y = Mathf.cos(phi) * radius\n\t// \tthis.z = sinPhiRadius * Mathf.cos(theta)\n\n\t// \treturn this\n\t// }\n\n\t// setFromCylindrical(c: Cylindrical): this {\n\t// \treturn this.setFromCylindricalCoords(c.radius, c.theta, c.y)\n\t// }\n\n\t// setFromCylindricalCoords(radius: f32, theta: f32, y: f32): this {\n\t// \tthis.x = radius * Mathf.sin(theta)\n\t// \tthis.y = y\n\t// \tthis.z = radius * Mathf.cos(theta)\n\n\t// \treturn this\n\t// }\n\n\tsetFromMatrixPosition(m: Matrix4): this {\n\t\tconst e = m.elements\n\n\t\tthis.x = e[12]\n\t\tthis.y = e[13]\n\t\tthis.z = e[14]\n\n\t\treturn this\n\t}\n\n\t// setFromMatrixScale(m: Matrix4): this {\n\t// \tvar sx = this.setFromMatrixColumn(m, 0).length\n\t// \tvar sy = this.setFromMatrixColumn(m, 1).length\n\t// \tvar sz = this.setFromMatrixColumn(m, 2).length\n\n\t// \tthis.x = sx\n\t// \tthis.y = sy\n\t// \tthis.z = sz\n\n\t// \treturn this\n\t// }\n\n\tsetFromMatrixColumn(matrix: Matrix4, index: i32): Vector3 {\n\t\treturn this.fromArray(matrix.elements, index * 4)\n\t}\n\n\t/**\n\t * Checks for strict equality of this vector and v.\n\t */\n\tequals(v: Vector3): boolean {\n\t\treturn v.x === this.x && v.y === this.y && v.z === this.z\n\t}\n\n\tfromArray(array: f32[], offset: i32 = 0): Vector3 {\n\t\tthis.x = array[offset]\n\t\tthis.y = array[offset + 1]\n\t\tthis.z = array[offset + 2]\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Returns an array [x, y, z], or copies x, y and z into the provided array.\n\t * @param array (optional) array to store the vector to. If this is not provided, a new array will be created.\n\t * @param offset (optional) optional offset into the array.\n\t * @return The created or provided array.\n\t */\n\ttoArray(array: f32[] = [], offset: i32 = 0): f32[] {\n\t\tarray[offset] = this.x\n\t\tarray[offset + 1] = this.y\n\t\tarray[offset + 2] = this.z\n\n\t\treturn array\n\t}\n\n\t// /**\n\t//  * Copies x, y and z into the provided array-like.\n\t//  * @param array array-like to store the vector to.\n\t//  * @param offset (optional) optional offset into the array.\n\t//  * @return The provided array-like.\n\t//  */\n\t// // toArray( xyz: ArrayLike<f32>, offset?: f32 ): ArrayLike<f32>;\n\n\t// fromBufferAttribute(attribute: BufferAttribute, index: f32, offset?: f32): this {\n\t// \tthis.x = attribute.getX(index)\n\t// \tthis.y = attribute.getY(index)\n\t// \tthis.z = attribute.getZ(index)\n\n\t// \treturn this\n\t// }\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  var b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  var base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = value >>> 31;\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  var out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  var sign = u32(value >>> 63);\n  if (sign) value = -value;\n  var out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value) + sign;\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1 + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix) + sign;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy var _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy var _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = i32((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n  exp = select<i32>(exp, 1, exp) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp, exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n\n  var p1 = u32(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var size = dtoa_core(dtoa_buf, value) << 1;\n  var result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  var sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      value = changetype<T>(-value);\n      store<u16>(buffer, CharCode.MINUS);\n    }\n  }\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(buffer + (sign << 1), value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  var decimals = sign;\n  if (sizeof<T>() <= 4) {\n    decimals += decimalCount32(value);\n    utoa32_dec_core(buffer, value, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals += decimalCount32(val32);\n      utoa32_dec_core(buffer, val32, decimals);\n    } else {\n      decimals += decimalCount64High(value);\n      utoa64_dec_core(buffer, value, decimals);\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_buffered(buffer: usize, value: f64): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa, itoa_buffered, dtoa_buffered, MAX_DOUBLE_LENGTH } from \"./number\";\nimport { ipow32 } from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    // @ts-ignore: cast\n    return ((c | 0x80) == 0xA0) | (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  var found = false;\n  var pos = index;\n  var minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  var maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  var c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  var sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (!num) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  var len = str.length;\n  if (!len) return NaN;\n\n  var ptr  = changetype<usize>(str);\n  var code = <u32>load<u16>(ptr);\n\n  var sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  var savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0;\n  const capacity = 19; // int(64 * 0.3010)\n  var pointed = false;\n  var consumed = 0;\n  var position = 0;\n  var x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  var sepLen = separator.length;\n  var valueLen = 5; // max possible length of element len(\"false\")\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  var sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  var sepLen = separator.length;\n  var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  var result = changetype<string>(__new(estLen << 1, idof<string>()));\n  var offset = 0;\n  var value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  var estLen = 0;\n  var value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    // @ts-ignore: type\n    if (value !== null) estLen += value.length;\n  }\n  var offset = 0;\n  var sepLen = separator.length;\n  var result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (value !== null) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (value !== null) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  var lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  var value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value !== null ? value.toString() : \"\";\n  }\n  var result = \"\";\n  var sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value !== null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value !== null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  var significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  var shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  var b = <u64>ipow32(5, -exp);\n  var q = significand / b;\n  var r = significand % b;\n  var s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  var shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  var sign = 1, magnitude = 0;\n  var code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy var __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  var low  = (a & 0xFFFFFFFF) * b;\n  var high = (a >> 32) * b + (low >> 32);\n  var overflow = <u32>(high >> 32);\n  var space = clz(overflow);\n  var revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    var hasSur = surr > 0;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    var length = units.length;\n    var out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    var ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    assert(<u32>code <= 0x10FFFF);\n    var hasSur = code > 0xFFFF;\n    var out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = (code >>> 10) | 0xD800;\n      store<u32>(changetype<usize>(out), lo | (hi << 16));\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    var len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    var len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (left === right) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return false;\n    var rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (left === right) return false;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    var leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    var res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (other === this) return 0; // compare pointers\n    var len: isize = this.length;\n    var otherLen: isize = other.length;\n    if (otherLen != len) return select(1, -1, len > otherLen);\n    if (!otherLen) return 0; // \"\" == \"\"\n    // @ts-ignore: string <-> String\n    return compareImpl(this, 0, other, 0, otherLen);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    var size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    var size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    var len = this.length;\n    var size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var thisLen: usize = this.length;\n    var searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    var replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    var out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (separator === null) return [this];\n    var length: isize = this.length;\n    var sepLen = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    var result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // ''\n          //  maps to  but except at the end of a word where it maps to \n          let sigma = 0x03C3; // \n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // \n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    var len = <usize>this.length;\n    if (!len) return this;\n    var codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    var specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    var specialsLen = SPECIALS_UPPER.length;\n    var j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      var bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false): usize {\n      var strEnd = str + (<usize>len << 1);\n      var bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && str + 2 < strEnd) {\n            let c2 = <u32>load<u16>(str, 2);\n            if ((c2 & 0xFC00) == 0xDC00) {\n              c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n              let b0 = c1 >> 18 | 240;\n              let b1 = c1 >> 12 & 63 | 128;\n              let b2 = c1 >> 6  & 63 | 128;\n              let b3 = c1       & 63 | 128;\n              store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n              bufOff += 4; str += 4;\n              continue;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      var strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      var size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      var str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","/**\n * @author bhouston / http://clara.io\n * @author WestLangley / http://github.com/WestLangley\n * @author Joe Pea / http://github.com/trusktr\n */\nimport {Vector3} from './Vector3'\n// import {Object3D} from '../core/Object3D'\n// import {Sphere} from './Sphere'\n// import {Plane} from './Plane'\nimport {Matrix4} from './Matrix4'\n\nconst points: Vector3[] = [\n\tnew Vector3(),\n\tnew Vector3(),\n\tnew Vector3(),\n\tnew Vector3(),\n\tnew Vector3(),\n\tnew Vector3(),\n\tnew Vector3(),\n\tnew Vector3(),\n]\n\nexport class Box3 {\n\tmax: Vector3\n\tmin: Vector3\n\treadonly isBox3: boolean = true\n\n\tconstructor(\n\t\tmin: Vector3 = new Vector3(+Infinity, +Infinity, +Infinity),\n\t\tmax: Vector3 = new Vector3(-Infinity, -Infinity, -Infinity)\n\t) {\n\t\tthis.min = min\n\t\tthis.max = max\n\t}\n\n\t// expandByVector(vector: Vector3): this\n\t// expandByObject(object: Object3D): this\n\t// containsPoint(point: Vector3): boolean\n\t// containsBox(box: Box3): boolean\n\t// getParameter(point: Vector3): Vector3\n\t// intersectsBox(box: Box3): boolean\n\t// intersectsSphere(sphere: Sphere): boolean\n\t// intersectsPlane(plane: Plane): boolean\n\t// clampPoint(point: Vector3, target: Vector3): Vector3\n\t// distanceToPoint(point: Vector3): f32\n\t// getBoundingSphere(target: Sphere): Sphere\n\t// intersect(box: Box3): this\n\t// union(box: Box3): this\n\n\tset(min: Vector3, max: Vector3): this {\n\t\tthis.min.copy(min)\n\t\tthis.max.copy(max)\n\n\t\treturn this\n\t}\n\n\t// setFromArray(array: ArrayLike<f32>): this {\n\t// \tvar minX = +Infinity\n\t// \tvar minY = +Infinity\n\t// \tvar minZ = +Infinity\n\n\t// \tvar maxX = -Infinity\n\t// \tvar maxY = -Infinity\n\t// \tvar maxZ = -Infinity\n\n\t// \tfor (var i = 0, l = array.length; i < l; i += 3) {\n\t// \t\tvar x = array[i]\n\t// \t\tvar y = array[i + 1]\n\t// \t\tvar z = array[i + 2]\n\n\t// \t\tif (x < minX) minX = x\n\t// \t\tif (y < minY) minY = y\n\t// \t\tif (z < minZ) minZ = z\n\n\t// \t\tif (x > maxX) maxX = x\n\t// \t\tif (y > maxY) maxY = y\n\t// \t\tif (z > maxZ) maxZ = z\n\t// \t}\n\n\t// \tthis.min.set(minX, minY, minZ)\n\t// \tthis.max.set(maxX, maxY, maxZ)\n\n\t// \treturn this\n\t// },\n\n\t// setFromBufferAttribute: function(attribute) {\n\t// \tvar minX = +Infinity\n\t// \tvar minY = +Infinity\n\t// \tvar minZ = +Infinity\n\n\t// \tvar maxX = -Infinity\n\t// \tvar maxY = -Infinity\n\t// \tvar maxZ = -Infinity\n\n\t// \tfor (var i = 0, l = attribute.count; i < l; i++) {\n\t// \t\tvar x = attribute.getX(i)\n\t// \t\tvar y = attribute.getY(i)\n\t// \t\tvar z = attribute.getZ(i)\n\n\t// \t\tif (x < minX) minX = x\n\t// \t\tif (y < minY) minY = y\n\t// \t\tif (z < minZ) minZ = z\n\n\t// \t\tif (x > maxX) maxX = x\n\t// \t\tif (y > maxY) maxY = y\n\t// \t\tif (z > maxZ) maxZ = z\n\t// \t}\n\n\t// \tthis.min.set(minX, minY, minZ)\n\t// \tthis.max.set(maxX, maxY, maxZ)\n\n\t// \treturn this\n\t// },\n\n\tsetFromPoints(points: Vector3[]): this {\n\t\tthis.makeEmpty()\n\n\t\tfor (let i = 0, il = points.length; i < il; i++) {\n\t\t\tthis.expandByPoint(points[i])\n\t\t}\n\n\t\treturn this\n\t}\n\n\t// setFromCenterAndSize(center: Vector3, size: Vector3): this\n\t// setFromCenterAndSize: (function() {\n\t// \tvar v1 = new Vector3()\n\n\t// \treturn function setFromCenterAndSize(center, size) {\n\t// \t\tvar halfSize = v1.copy(size).multiplyScalar(0.5)\n\n\t// \t\tthis.min.copy(center).sub(halfSize)\n\t// \t\tthis.max.copy(center).add(halfSize)\n\n\t// \t\treturn this\n\t// \t}\n\t// })(),\n\n\t// setFromObject(object: Object3D): this {\n\t// \tthis.makeEmpty()\n\n\t// \treturn this.expandByObject(object)\n\t// },\n\n\tclone(): Box3 {\n\t\tconst b = new Box3()\n\t\tb.copy(this)\n\t\treturn b\n\t}\n\n\tcopy(box: Box3): this {\n\t\tthis.min.copy(box.min)\n\t\tthis.max.copy(box.max)\n\n\t\treturn this\n\t}\n\n\tmakeEmpty(): this {\n\t\tthis.min.x = this.min.y = this.min.z = +Infinity\n\t\tthis.max.x = this.max.y = this.max.z = -Infinity\n\n\t\treturn this\n\t}\n\n\tisEmpty(): boolean {\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z\n\t}\n\n\tgetCenter(target: Vector3): Vector3 {\n\t\treturn this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5)\n\t}\n\n\tgetSize(target: Vector3): Vector3 {\n\t\treturn this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min)\n\t}\n\n\texpandByPoint(point: Vector3): this {\n\t\tthis.min.min(point)\n\t\tthis.max.max(point)\n\n\t\treturn this\n\t}\n\n\t// expandByVector: function(vector) {\n\t// \tthis.min.sub(vector)\n\t// \tthis.max.add(vector)\n\n\t// \treturn this\n\t// },\n\n\texpandByScalar(scalar: f32): this {\n\t\tthis.min.addScalar(-scalar)\n\t\tthis.max.addScalar(scalar)\n\n\t\treturn this\n\t}\n\n\t// expandByObject: (function() {\n\t// \t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t// \t// accounting for both the object's, and children's, world transforms\n\n\t// \tvar scope, i, l\n\n\t// \tvar v1 = new Vector3()\n\n\t// \tfunction traverse(node) {\n\t// \t\tvar geometry = node.geometry\n\n\t// \t\tif (geometry !== undefined) {\n\t// \t\t\tif (geometry.isGeometry) {\n\t// \t\t\t\tvar vertices = geometry.vertices\n\n\t// \t\t\t\tfor (i = 0, l = vertices.length; i < l; i++) {\n\t// \t\t\t\t\tv1.copy(vertices[i])\n\t// \t\t\t\t\tv1.applyMatrix4(node.matrixWorld)\n\n\t// \t\t\t\t\tscope.expandByPoint(v1)\n\t// \t\t\t\t}\n\t// \t\t\t} else if (geometry.isBufferGeometry) {\n\t// \t\t\t\tvar attribute = geometry.attributes.position\n\n\t// \t\t\t\tif (attribute !== undefined) {\n\t// \t\t\t\t\tfor (i = 0, l = attribute.count; i < l; i++) {\n\t// \t\t\t\t\t\tv1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld)\n\n\t// \t\t\t\t\t\tscope.expandByPoint(v1)\n\t// \t\t\t\t\t}\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \treturn function expandByObject(object) {\n\t// \t\tscope = this\n\n\t// \t\tobject.updateMatrixWorld(true)\n\n\t// \t\tobject.traverse(traverse)\n\n\t// \t\treturn this\n\t// \t}\n\t// })(),\n\n\t// containsPoint: function(point) {\n\t// \treturn point.x < this.min.x ||\n\t// \t\tpoint.x > this.max.x ||\n\t// \t\tpoint.y < this.min.y ||\n\t// \t\tpoint.y > this.max.y ||\n\t// \t\tpoint.z < this.min.z ||\n\t// \t\tpoint.z > this.max.z\n\t// \t\t? false\n\t// \t\t: true\n\t// },\n\n\t// containsBox: function(box) {\n\t// \treturn (\n\t// \t\tthis.min.x <= box.min.x &&\n\t// \t\tbox.max.x <= this.max.x &&\n\t// \t\tthis.min.y <= box.min.y &&\n\t// \t\tbox.max.y <= this.max.y &&\n\t// \t\tthis.min.z <= box.min.z &&\n\t// \t\tbox.max.z <= this.max.z\n\t// \t)\n\t// },\n\n\t// getParameter: function(point, target) {\n\t// \t// This can potentially have a divide by zero if the box\n\t// \t// has a size dimension of 0.\n\n\t// \tif (target === undefined) {\n\t// \t\tconsole.warn('THREE.Box3: .getParameter() target is now required')\n\t// \t\ttarget = new Vector3()\n\t// \t}\n\n\t// \treturn target.set(\n\t// \t\t(point.x - this.min.x) / (this.max.x - this.min.x),\n\t// \t\t(point.y - this.min.y) / (this.max.y - this.min.y),\n\t// \t\t(point.z - this.min.z) / (this.max.z - this.min.z)\n\t// \t)\n\t// },\n\n\t// intersectsBox: function(box) {\n\t// \t// using 6 splitting planes to rule out intersections.\n\t// \treturn box.max.x < this.min.x ||\n\t// \t\tbox.min.x > this.max.x ||\n\t// \t\tbox.max.y < this.min.y ||\n\t// \t\tbox.min.y > this.max.y ||\n\t// \t\tbox.max.z < this.min.z ||\n\t// \t\tbox.min.z > this.max.z\n\t// \t\t? false\n\t// \t\t: true\n\t// },\n\n\t// intersectsSphere: (function() {\n\t// \tvar closestPoint = new Vector3()\n\n\t// \treturn function intersectsSphere(sphere) {\n\t// \t\t// Find the point on the AABB closest to the sphere center.\n\t// \t\tthis.clampPoint(sphere.center, closestPoint)\n\n\t// \t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t// \t\treturn closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius\n\t// \t}\n\t// })(),\n\n\t// intersectsPlane: function(plane) {\n\t// \t// We compute the minimum and maximum dot product values. If those values\n\t// \t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t// \tvar min, max\n\n\t// \tif (plane.normal.x > 0) {\n\t// \t\tmin = plane.normal.x * this.min.x\n\t// \t\tmax = plane.normal.x * this.max.x\n\t// \t} else {\n\t// \t\tmin = plane.normal.x * this.max.x\n\t// \t\tmax = plane.normal.x * this.min.x\n\t// \t}\n\n\t// \tif (plane.normal.y > 0) {\n\t// \t\tmin += plane.normal.y * this.min.y\n\t// \t\tmax += plane.normal.y * this.max.y\n\t// \t} else {\n\t// \t\tmin += plane.normal.y * this.max.y\n\t// \t\tmax += plane.normal.y * this.min.y\n\t// \t}\n\n\t// \tif (plane.normal.z > 0) {\n\t// \t\tmin += plane.normal.z * this.min.z\n\t// \t\tmax += plane.normal.z * this.max.z\n\t// \t} else {\n\t// \t\tmin += plane.normal.z * this.max.z\n\t// \t\tmax += plane.normal.z * this.min.z\n\t// \t}\n\n\t// \treturn min <= -plane.constant && max >= -plane.constant\n\t// },\n\n\t// intersectsTriangle: (function() {\n\t// \t// triangle centered vertices\n\t// \tvar v0 = new Vector3()\n\t// \tvar v1 = new Vector3()\n\t// \tvar v2 = new Vector3()\n\n\t// \t// triangle edge vectors\n\t// \tvar f0 = new Vector3()\n\t// \tvar f1 = new Vector3()\n\t// \tvar f2 = new Vector3()\n\n\t// \tvar testAxis = new Vector3()\n\n\t// \tvar center = new Vector3()\n\t// \tvar extents = new Vector3()\n\n\t// \tvar triangleNormal = new Vector3()\n\n\t// \tfunction satForAxes(axes) {\n\t// \t\tvar i, j\n\n\t// \t\tfor (i = 0, j = axes.length - 3; i <= j; i += 3) {\n\t// \t\t\ttestAxis.fromArray(axes, i)\n\t// \t\t\t// project the aabb onto the seperating axis\n\t// \t\t\tvar r =\n\t// \t\t\t\textents.x * Mathf.abs(testAxis.x) +\n\t// \t\t\t\textents.y * Mathf.abs(testAxis.y) +\n\t// \t\t\t\textents.z * Mathf.abs(testAxis.z)\n\t// \t\t\t// project all 3 vertices of the triangle onto the seperating axis\n\t// \t\t\tvar p0 = v0.dot(testAxis)\n\t// \t\t\tvar p1 = v1.dot(testAxis)\n\t// \t\t\tvar p2 = v2.dot(testAxis)\n\t// \t\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t// \t\t\tif (Mathf.max(-Mathf.max(p0, p1, p2), Mathf.min(p0, p1, p2)) > r) {\n\t// \t\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t// \t\t\t\t// the axis is seperating and we can exit\n\t// \t\t\t\treturn false\n\t// \t\t\t}\n\t// \t\t}\n\n\t// \t\treturn true\n\t// \t}\n\n\t// \treturn function intersectsTriangle(triangle) {\n\t// \t\tif (this.isEmpty()) {\n\t// \t\t\treturn false\n\t// \t\t}\n\n\t// \t\t// compute box center and extents\n\t// \t\tthis.getCenter(center)\n\t// \t\textents.subVectors(this.max, center)\n\n\t// \t\t// translate triangle to aabb origin\n\t// \t\tv0.subVectors(triangle.a, center)\n\t// \t\tv1.subVectors(triangle.b, center)\n\t// \t\tv2.subVectors(triangle.c, center)\n\n\t// \t\t// compute edge vectors for triangle\n\t// \t\tf0.subVectors(v1, v0)\n\t// \t\tf1.subVectors(v2, v1)\n\t// \t\tf2.subVectors(v0, v2)\n\n\t// \t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t// \t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t// \t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t// \t\tvar axes = [\n\t// \t\t\t0,\n\t// \t\t\t-f0.z,\n\t// \t\t\tf0.y,\n\t// \t\t\t0,\n\t// \t\t\t-f1.z,\n\t// \t\t\tf1.y,\n\t// \t\t\t0,\n\t// \t\t\t-f2.z,\n\t// \t\t\tf2.y,\n\t// \t\t\tf0.z,\n\t// \t\t\t0,\n\t// \t\t\t-f0.x,\n\t// \t\t\tf1.z,\n\t// \t\t\t0,\n\t// \t\t\t-f1.x,\n\t// \t\t\tf2.z,\n\t// \t\t\t0,\n\t// \t\t\t-f2.x,\n\t// \t\t\t-f0.y,\n\t// \t\t\tf0.x,\n\t// \t\t\t0,\n\t// \t\t\t-f1.y,\n\t// \t\t\tf1.x,\n\t// \t\t\t0,\n\t// \t\t\t-f2.y,\n\t// \t\t\tf2.x,\n\t// \t\t\t0,\n\t// \t\t]\n\t// \t\tif (!satForAxes(axes)) {\n\t// \t\t\treturn false\n\t// \t\t}\n\n\t// \t\t// test 3 face normals from the aabb\n\t// \t\taxes = [1, 0, 0, 0, 1, 0, 0, 0, 1]\n\t// \t\tif (!satForAxes(axes)) {\n\t// \t\t\treturn false\n\t// \t\t}\n\n\t// \t\t// finally testing the face normal of the triangle\n\t// \t\t// use already existing triangle edge vectors here\n\t// \t\ttriangleNormal.crossVectors(f0, f1)\n\t// \t\taxes = [triangleNormal.x, triangleNormal.y, triangleNormal.z]\n\t// \t\treturn satForAxes(axes)\n\t// \t}\n\t// })(),\n\n\t// clampPoint: function(point, target) {\n\t// \tif (target === undefined) {\n\t// \t\tconsole.warn('THREE.Box3: .clampPoint() target is now required')\n\t// \t\ttarget = new Vector3()\n\t// \t}\n\n\t// \treturn target.copy(point).clamp(this.min, this.max)\n\t// },\n\n\t// distanceToPoint: (function() {\n\t// \tvar v1 = new Vector3()\n\n\t// \treturn function distanceToPoint(point) {\n\t// \t\tvar clampedPoint = v1.copy(point).clamp(this.min, this.max)\n\t// \t\treturn clampedPoint.sub(point).length()\n\t// \t}\n\t// })(),\n\n\t// getBoundingSphere: (function() {\n\t// \tvar v1 = new Vector3()\n\n\t// \treturn function getBoundingSphere(target) {\n\t// \t\tif (target === undefined) {\n\t// \t\t\tconsole.error('THREE.Box3: .getBoundingSphere() target is now required')\n\t// \t\t\t//target = new Sphere(); // removed to avoid cyclic dependency\n\t// \t\t}\n\n\t// \t\tthis.getCenter(target.center)\n\n\t// \t\ttarget.radius = this.getSize(v1).length() * 0.5\n\n\t// \t\treturn target\n\t// \t}\n\t// })(),\n\n\t// intersect: function(box) {\n\t// \tthis.min.max(box.min)\n\t// \tthis.max.min(box.max)\n\n\t// \t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t// \tif (this.isEmpty()) this.makeEmpty()\n\n\t// \treturn this\n\t// },\n\n\t// union: function(box) {\n\t// \tthis.min.min(box.min)\n\t// \tthis.max.max(box.max)\n\n\t// \treturn this\n\t// },\n\n\tapplyMatrix4(matrix: Matrix4): this {\n\t\t// transform of empty box is an empty box.\n\t\tif (this.isEmpty()) return this\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\tpoints[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix) // 000\n\t\tpoints[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix) // 001\n\t\tpoints[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix) // 010\n\t\tpoints[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix) // 011\n\t\tpoints[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix) // 100\n\t\tpoints[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix) // 101\n\t\tpoints[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix) // 110\n\t\tpoints[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix) // 111\n\n\t\tthis.setFromPoints(points)\n\n\t\treturn this\n\t}\n\n\ttranslate(offset: Vector3): this {\n\t\tthis.min.add(offset)\n\t\tthis.max.add(offset)\n\n\t\treturn this\n\t}\n\n\tequals(box: Box3): boolean {\n\t\treturn box.min.equals(this.min) && box.max.equals(this.max)\n\t}\n}\n\nexport function compareBox(a: Box3, b: Box3, threshold: f32 = 0.0001): bool {\n\treturn a.min.distanceTo(b.min) < threshold && a.max.distanceTo(b.max) < threshold\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_ILLEGALGENTYPE, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureSize(array: usize, minSize: usize, alignLog2: u32): void {\n  // depends on the fact that Arrays mimic ArrayBufferView\n  var oldCapacity = changetype<ArrayBufferView>(array).byteLength;\n  if (minSize > <usize>oldCapacity >>> alignLog2) {\n    if (minSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    let newCapacity = minSize << alignLog2;\n    let newData = __renew(oldData, newCapacity);\n    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    if (newData !== oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  private dataStart: usize;\n  private byteLength: i32;\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? builtin_isArray(value) && value !== null : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    var array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var bufferSize = <usize>length << alignof<T>();\n    var buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureSize(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    var len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    start = start < 0 ? max(length + start, 0) : min(start, length);\n    end   = end   < 0 ? max(length + end,   0) : min(end,   length);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        store<usize>(dataStart + (<usize>start << alignof<T>()), changetype<usize>(value));\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          dataStart + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(dataStart + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length_;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      let dataStart = this.dataStart;\n      while (fromIndex < length) {\n        let elem = load<T>(dataStart + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var dataStart = this.dataStart;\n    while (fromIndex < length) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var dataStart = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var length = this.length_;\n    var newLength = length + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>length << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>length << alignof<T>()), value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, other.length_, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var len = this.length_;\n\n    end = min<i32>(end, len);\n\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      dataStart + (<usize>to << alignof<T>()),\n      dataStart + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var element = load<T>(this.dataStart + (<usize>(--length) << alignof<T>()));\n    this.length_ = length;\n    return element;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var out = changetype<Array<U>>(__newArray(length, alignof<U>(), idof<Array<U>>()));\n    var outStart = out.dataStart;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      let result = fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n      store<U>(outStart + (<usize>index << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n      if (fn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = length - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var newLength = this.length_ + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    var dataStart = this.dataStart;\n    memory.copy(\n      dataStart + sizeof<T>(),\n      dataStart,\n      <usize>(newLength - 1) << alignof<T>()\n    );\n    store<T>(dataStart, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var result = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>())); \n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    var length = this.length_;\n    if (length) {\n      let front = this.dataStart;\n      let back = this.dataStart + (<usize>(length - 1) << alignof<T>());\n      while (front < back) {\n        let temp = load<T>(front);\n        store<T>(front, load<T>(back));\n        store<T>(back, temp);\n        front += sizeof<T>();\n        back -= sizeof<T>();\n      }\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    var length = this.length_;\n    if (length <= 1) return this;\n    var base = this.dataStart;\n    if (length == 2) {\n      let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n      let b: T = load<T>(base); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        store<T>(base, b, sizeof<T>()); // arr[1] = b;\n        store<T>(base, a); // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(base, length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(dataStart, length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(dataStart, length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(dataStart, length, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(dataStart, length, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(dataStart, length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      throw new TypeError(E_ILLEGALGENTYPE);\n    }\n    // Get the length and data start values\n    var length = this.length_;\n    var selfDataStart = this.dataStart;\n\n    // calculate the end size with an initial pass\n    var size = 0;\n    for (let i = 0; i < length; i++) {\n      let child = load<usize>(selfDataStart + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    var byteLength = <usize>size << usize(alignof<valueof<T>>());\n    var outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    var outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    var resultOffset: usize = 0;\n    for (let i = 0; i < length; i++) { // for each child\n      let child = load<usize>(selfDataStart + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (child == 0) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = load<i32>(child, offsetof<T>(\"byteLength\"));\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        <usize>childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; i++) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","/**\n * @author bhouston / http://clara.io\n * @author mrdoob / http://mrdoob.com/\n * @author Joe Pea / https://github.com/trusktr\n */\nimport {Vector3} from './Vector3'\nimport {Box3} from './Box3'\nimport {Plane} from './Plane'\nimport {Matrix4} from './Matrix4'\n\nconst box = new Box3()\n\nexport class Sphere {\n\tcenter: Vector3\n\tradius: f32\n\n\tconstructor(center: Vector3 = new Vector3(), radius: f32 = 0) {\n\t\tthis.center = center\n\t\tthis.radius = radius\n\t}\n\n\t// XXX When will constructor properties be supported, so we don't have to write the above constructor version?\n\t// constructor(public center = new Vector3(), public radius = 0) {}\n\n\tset(center: Vector3, radius: f32): Sphere {\n\t\tthis.center.copy(center)\n\t\tthis.radius = radius\n\n\t\treturn this\n\t}\n\n\tsetFromPoints(points: Vector3[], optionalCenter: Vector3 | null = null): Sphere {\n\t\tconst center = this.center\n\n\t\tif (optionalCenter !== null) {\n\t\t\tcenter.copy(optionalCenter)\n\t\t} else {\n\t\t\tbox.setFromPoints(points).getCenter(center)\n\t\t}\n\n\t\tlet maxRadiusSq: f32 = 0.0\n\n\t\tfor (let i: i32 = 0, il: i32 = points.length; i < il; i++) {\n\t\t\tmaxRadiusSq = Mathf.max(maxRadiusSq, center.distanceToSquared(points[i]))\n\t\t}\n\n\t\tthis.radius = Mathf.sqrt(maxRadiusSq)\n\n\t\treturn this\n\t}\n\n\tclone(): Sphere {\n\t\tconst s = new Sphere()\n\t\ts.copy(this)\n\t\treturn s\n\t}\n\n\tcopy(sphere: Sphere): this {\n\t\tthis.center.copy(sphere.center)\n\t\tthis.radius = sphere.radius\n\n\t\treturn this\n\t}\n\n\t// empty(): boolean {\n\t// \treturn this.radius <= 0\n\t// }\n\n\t// containsPoint(point: Vector3): boolean {\n\t// \treturn point.distanceToSquared(this.center) <= this.radius * this.radius\n\t// }\n\n\t// distanceToPoint(point: Vector3): f32 {\n\t// \treturn point.distanceTo(this.center) - this.radius\n\t// }\n\n\t// intersectsSphere(sphere: Sphere): boolean {\n\t// \tvar radiusSum = this.radius + sphere.radius\n\n\t// \treturn sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum\n\t// }\n\n\t// intersectsBox(box: Box3): boolean {\n\t// \treturn box.intersectsSphere(this)\n\t// }\n\n\t// intersectsPlane(plane: Plane): boolean {\n\t// \treturn Mathf.abs(plane.distanceToPoint(this.center)) <= this.radius\n\t// }\n\n\t// clampPoint(point: Vector3, target: Vector3): Vector3 {\n\t// \tvar deltaLengthSq = this.center.distanceToSquared(point)\n\n\t// \tif (target === undefined) {\n\t// \t\tconsole.warn('THREE.Sphere: .clampPoint() target is now required')\n\t// \t\ttarget = new Vector3()\n\t// \t}\n\n\t// \ttarget.copy(point)\n\n\t// \tif (deltaLengthSq > this.radius * this.radius) {\n\t// \t\ttarget.sub(this.center).normalize()\n\t// \t\ttarget.multiplyScalar(this.radius).add(this.center)\n\t// \t}\n\n\t// \treturn target\n\t// }\n\n\tgetBoundingBox(target: Box3): Box3 {\n\t\ttarget.set(this.center, this.center)\n\t\ttarget.expandByScalar(this.radius)\n\n\t\treturn target\n\t}\n\n\tapplyMatrix4(matrix: Matrix4): Sphere {\n\t\tthis.center.applyMatrix4(matrix)\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis()\n\n\t\treturn this\n\t}\n\n\t// translate(offset: Vector3): Sphere {\n\t// \tthis.center.add(offset)\n\n\t// \treturn this\n\t// }\n\n\tequals(sphere: Sphere): boolean {\n\t\treturn sphere.center.equals(this.center) && sphere.radius === this.radius\n\t}\n}\n","/**\n * @author mrdoob / http://mrdoob.com/\n * @author mikael emtinger / http://gomo.se/\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author elephantatwork / www.elephantatwork.ch\n * @author Joe Pea / http://github.com/trusktr\n */\n\nimport {Quaternion} from '../math/Quaternion'\nimport {Vector3} from '../math/Vector3'\nimport {Matrix4} from '../math/Matrix4'\nimport {EventDispatcher} from './EventDispatcher'\nimport {Euler} from '../math/Euler'\nimport {Layers} from './Layers'\n// import {Matrix3} from '../math/Matrix3'\n// import * as _Math from '../math/Math'\n// import {WebGLRenderer} from './../renderers/WebGLRenderer'\n// import {Scene} from './../scenes/Scene'\n// import {Camera} from './../cameras/Camera'\n// import {Geometry} from './Geometry'\n// import {Material} from './../materials/Material'\n// import {Group} from './../objects/Group'\n// import {Raycaster, Intersection} from './Raycaster'\n// import {BufferGeometry} from './BufferGeometry'\n\n// DISABLED, because the toJSON() method is disabled\n// import {TrianglesDrawMode} from '../constants'\n\ntype RenderCallback = () => // TODO\n// renderer: WebGLRenderer,\n// scene: Scene,\n// camera: Camera,\n\n// material: Material,\n// group: Group\nvoid\n\ntype TraverseCallback = (object: Object3D) => void\n\nlet object3DId = 0\n\nconst quaternion = new Quaternion()\nconst vector = new Vector3()\nconst matrix = new Matrix4()\nconst target = new Vector3()\nconst position = new Vector3()\nconst scale = new Vector3()\n\nconst vX = new Vector3(1, 0, 0)\nconst vY = new Vector3(0, 1, 0)\nconst vZ = new Vector3(0, 0, 1)\n\nlet self: Object3D | null = null\n\n/**\n * Base class for scene graph objects\n */\nexport class Object3D extends EventDispatcher {\n\t// static DefaultUp = new Vector3(0, 1, 0)\n\tstatic DefaultMatrixAutoUpdate: boolean = true\n\n\t/**\n\t * Unique number of this object instance.\n\t */\n\tid: i32 = object3DId++\n\n\t/**\n\t *\n\t */\n\t// uuid = _Math.generateUUID()\n\n\t/**\n\t * Optional name of the object (doesn't need to be unique).\n\t */\n\tname: string = ''\n\n\t/**\n\t * Type of the object, as a string\n\t */\n\ttype: string = 'Object3D'\n\n\t/**\n\t * Object's parent in the scene graph.\n\t */\n\tparent: Object3D | null = null\n\n\t/**\n\t * Array with object's children.\n\t */\n\tchildren: Object3D[] = []\n\n\t/**\n\t * Up direction.\n\t */\n\t// up = Object3D.DefaultUp.clone()\n\n\t/**\n\t * Object's local position.\n\t */\n\treadonly position: Vector3 = new Vector3()\n\n\t/**\n\t * Object's local rotation (Euler angles), in radians.\n\t */\n\treadonly rotation: Euler = new Euler()\n\n\t/**\n\t * Global rotation.\n\t */\n\treadonly quaternion: Quaternion = new Quaternion()\n\n\t/**\n\t * Object's local scale.\n\t */\n\treadonly scale: Vector3 = new Vector3(1, 1, 1)\n\n\treadonly modelViewMatrix: Matrix4 = new Matrix4()\n\t// readonly normalMatrix: Matrix3 = new Matrix3()\n\n\t/**\n\t * Local transform.\n\t */\n\tmatrix: Matrix4 = new Matrix4()\n\n\t/**\n\t * The global transform of the object. If the Object3d has no parent, then it's identical to the local transform.\n\t */\n\tmatrixWorld: Matrix4 = new Matrix4()\n\n\t/**\n\t * When this is set, it calculates the matrix of position, (rotation or quaternion) and scale every frame and also recalculates the matrixWorld property.\n\t */\n\tmatrixAutoUpdate: boolean = Object3D.DefaultMatrixAutoUpdate\n\n\t/**\n\t * When this is set, it calculates the matrixWorld in that frame and resets this property to false.\n\t */\n\tmatrixWorldNeedsUpdate: boolean = false\n\n\tlayers: Layers = new Layers()\n\n\t/**\n\t * Object gets rendered if true.\n\t */\n\tvisible: boolean = true\n\n\t// TODO The following castShadow and receiveShadow properties are for the\n\t// Mesh class and similar classes. Other types of Object3D like CSS3DObject\n\t// don't cast or receive shadows, and plain Object3D instances also don't.\n\n\t/**\n\t * Gets rendered into shadow map.\n\t */\n\tcastShadow: boolean = false\n\n\t/**\n\t * Material gets baked in shadow receiving.\n\t */\n\treceiveShadow: boolean = false\n\n\t// XXX (@trusktr), this was moved to Mesh because if the property is defined\n\t// here, then we were getting compiler/aspect errors. Discussion at\n\t// https://discord.com/channels/710694854761381938/714242904712806402/714703859926302751\n\t//the BufferGeometry type might need to be added later...\n\t// geometry: Geometry //| BufferGeometry\n\n\t/**\n\t * When this is set, it checks every frame if the object is in the frustum of the camera. Otherwise the object gets drawn every frame even if it isn't visible.\n\t */\n\tfrustumCulled: boolean = true\n\n\t/**\n\t * Overrides the default rendering order of scene graph objects, from lowest to highest renderOrder. Opaque and transparent objects remain sorted independently though. When this property is set for an instance of Group, all descendants objects will be sorted and rendered together.\n\t */\n\trenderOrder: f32 = 0\n\n\t/**\n\t * An object that can be used to store custom data about the Object3d. It should not hold references to functions as these will not be cloned.\n\t * DISABLED: objects with type any are not supported in AS. Users can use a Map in their own scope, and architect their app to pass around their Map instead of relying on passing data on scene objects.\n\t */\n\t// userData: {[key: string]: any} = {}\n\n\t/**\n\t * Used to check whether this or derived classes are Object3Ds. Default is true.\n\t * You should not change this, as it is used internally for optimisation.\n\t */\n\treadonly isObject3D: boolean = true\n\n\t/**\n\t * True when a subclass is or extends from Camera\n\t */\n\tisCamera: boolean = false\n\n\t/**\n\t * True when a subclass is or extends from Light\n\t */\n\tprotected isLight: boolean = false\n\n\tconstructor() {\n\t\tsuper()\n\t\tself = this\n\n\t\tthis.rotation.onChange(() => {\n\t\t\tself!.onRotationChange()\n\t\t})\n\t\t// this.quaternion.onChange(this.onQuaternionChange)\n\t}\n\n\tprivate onRotationChange(): void {\n\t\tthis.quaternion.setFromEuler(this.rotation, false)\n\t}\n\n\t// private onQuaternionChange: () => void = () => {\n\t// \tthis.rotation.setFromQuaternion(this.quaternion, undefined, false)\n\t// }\n\n\t/**\n\t * Custom depth material to be used when rendering to the depth map. Can only be used in context of meshes.\n\t * When shadow-casting with a DirectionalLight or SpotLight, if you are (a) modifying vertex positions in\n\t * the vertex shader, (b) using a displacement map, (c) using an alpha map with alphaTest, or (d) using a\n\t * transparent texture with alphaTest, you must specify a customDepthMaterial for proper shadows.\n\t *\n\t */\n\t// customDepthMaterial: Material\n\t// TODO This isn't in the JS file, only in the declaration\n\n\t/**\n\t * Same as customDepthMaterial, but used with PointLight.\n\t */\n\t// customDistanceMaterial: Material\n\t// TODO This isn't in the JS file, only in the declaration\n\n\t/**\n\t * Calls before the object is rendered\n\t */\n\tonBeforeRender: RenderCallback = () => {}\n\n\t/**\n\t * Calls after the object is rendered\n\t */\n\tonAfterRender: RenderCallback = () => {}\n\n\t// /**\n\t//  * This updates the position, rotation and scale from a matrix.\n\t//  */\n\t// applyMatrix(matrix: Matrix4): void {\n\t// \tif (this.matrixAutoUpdate) this.updateMatrix()\n\n\t// \tthis.matrix.premultiply(matrix)\n\n\t// \tthis.matrix.decompose(this.position, this.quaternion, this.scale)\n\t// }\n\n\t// applyQuaternion(quaternion: Quaternion): this {\n\t// \tthis.quaternion.premultiply(quaternion)\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Rotate the object around an axis\n\t//  * @param axis A normalized vector to rotate the object around\n\t//  * @param angle The amount to rotate in radians\n\t//  */\n\t// setRotationFromAxisAngle(axis: Vector3, angle: f32): void {\n\t// \t// assumes axis is normalized\n\n\t// \tthis.quaternion.setFromAxisAngle(axis, angle)\n\t// }\n\n\t// setRotationFromEuler(euler: Euler): void {\n\t// \tthis.quaternion.setFromEuler(euler, true)\n\t// }\n\n\t// /**\n\t//  *\n\t//  * @param matrix The matrix from which to exetract rotation. Assumes the upper\n\t//  * 3x3 of the matrix is a pure rotation matrix (i.e, unscaled)\n\t//  */\n\t// setRotationFromMatrix(matrix: Matrix4): void {\n\t// \tthis.quaternion.setFromRotationMatrix(matrix)\n\t// }\n\n\t// /**\n\t//  * @param q The normalized quaternion to copy rotation from.\n\t//  */\n\t// setRotationFromQuaternion(q: Quaternion): void {\n\t// \tthis.quaternion.copy(q)\n\t// }\n\n\t// /**\n\t//  * Rotate an object along an axis in object space. The axis is assumed to be normalized.\n\t//  * @param axis  A normalized vector in object space.\n\t//  * @param angle  The angle in radians.\n\t//  */\n\t// rotateOnAxis(axis: Vector3, angle: f32): this {\n\t// \tquaternion.setFromAxisAngle(axis, angle)\n\n\t// \tthis.quaternion.multiply(quaternion)\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Rotate an object along an axis in world space. The axis is assumed to be normalized. Method Assumes no rotated parent.\n\t//  * @param axis  A normalized vector in object space.\n\t//  * @param angle  The angle in radians.\n\t//  */\n\t// rotateOnWorldAxis(axis: Vector3, angle: f32): this {\n\t// \tquaternion.setFromAxisAngle(axis, angle)\n\n\t// \tthis.quaternion.premultiply(quaternion)\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  *\n\t//  * @param angle\n\t//  */\n\t// rotateX(angle: f32): this {\n\t// \treturn this.rotateOnAxis(vX, angle)\n\t// }\n\n\t// /**\n\t//  *\n\t//  * @param angle\n\t//  */\n\t// rotateY(angle: f32): this {\n\t// \treturn this.rotateOnAxis(vY, angle)\n\t// }\n\n\t// /**\n\t//  *\n\t//  * @param angle\n\t//  */\n\t// rotateZ(angle: f32): this {\n\t// \treturn this.rotateOnAxis(vZ, angle)\n\t// }\n\n\t// /**\n\t//  * Translate object by distance along axis in object space. `axis` is assumed to be normalized\n\t//  * @param axis  A normalized vector in object space.\n\t//  * @param distance  The distance to translate.\n\t//  */\n\t// translateOnAxis(axis: Vector3, distance: f32): this {\n\t// \tvector.copy(axis).applyQuaternion(this.quaternion)\n\n\t// \tthis.position.add(vector.multiplyScalar(distance))\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Translates object along x axis by distance.\n\t//  * @param distance Distance.\n\t//  */\n\t// translateX(distance: f32): this {\n\t// \treturn this.translateOnAxis(vX, distance)\n\t// }\n\n\t// /**\n\t//  * Translates object along y axis by distance.\n\t//  * @param distance Distance.\n\t//  */\n\t// translateY(distance: f32): this {\n\t// \treturn this.translateOnAxis(vY, distance)\n\t// }\n\n\t// /**\n\t//  * Translates object along z axis by distance.\n\t//  * @param distance Distance.\n\t//  */\n\t// translateZ(distance: f32): this {\n\t// \treturn this.translateOnAxis(vZ, distance)\n\t// }\n\n\t// /**\n\t//  * Updates the vector from local space to world space.\n\t//  * @param vector A local vector.\n\t//  */\n\t// localToWorld(vector: Vector3): Vector3 {\n\t// \treturn vector.applyMatrix4(this.matrixWorld)\n\t// }\n\n\t// /**\n\t//  * Updates the vector from world space to local space.\n\t//  * @param vector A world vector.\n\t//  */\n\t// worldToLocal(vector: Vector3): Vector3 {\n\t// \treturn vector.applyMatrix4(matrix.getInverse(this.matrixWorld))\n\t// }\n\n\t// /**\n\t//  * Rotates object to face point in space.\n\t//  * This method does not support objects having non-uniformly-scaled parent(s)\n\t//  * @param vector A world vector to look at.\n\t//  */\n\t// lookAt<T>(x: T, y: f32 = 0, z: f32 = 0): void {\n\t// \tif (x instanceof Vector3) {\n\t// \t\ttarget.copy(x)\n\t// \t} else if (isFloat<T>()) {\n\t// \t\ttarget.set(x, y, z)\n\t// \t}\n\n\t// \tconst parent = this.parent\n\n\t// \tthis.updateWorldMatrix(true, false)\n\n\t// \tposition.setFromMatrixPosition(this.matrixWorld)\n\n\t// \tif (this.isCamera || this.isLight) {\n\t// \t\tmatrix.lookAt(position, target, this.up)\n\t// \t} else {\n\t// \t\tmatrix.lookAt(target, position, this.up)\n\t// \t}\n\n\t// \tthis.quaternion.setFromRotationMatrix(matrix)\n\n\t// \tif (parent) {\n\t// \t\tmatrix.extractRotation(parent.matrixWorld)\n\t// \t\tquaternion.setFromRotationMatrix(matrix)\n\t// \t\tthis.quaternion.premultiply(quaternion.inverse())\n\t// \t}\n\t// }\n\n\t/**\n\t * Adds object as child of this object.\n\t * @param object A single Object3D instance to add, or an array of Object3D instances to add\n\t */\n\t// add<T>(object: T): this {\n\tadd(object: Object3D): this {\n\t\t// let o: Object3D | null = null\n\n\t\t// if (Array.isArray<Object3D>(object)) {\n\t\t// if (isArray<Object3D>(object)) {\n\t\t// \tfor (let i = 0, l = object.length; i < l; i++) {\n\t\t// \t\to = object[i] as Object3D\n\n\t\t// \t\tthis.__add(o)\n\t\t// \t}\n\t\t// } else\n\t\t// if (object instanceof Object3D) {\n\t\tthis.__add(object)\n\t\t// } else {\n\t\t// \tthrow new Error('Object3D.add: The argument should be an Object3D or Array<Object3D>')\n\t\t// }\n\n\t\treturn this\n\t}\n\n\tprivate __add(object: Object3D): void {\n\t\tif (object === this) {\n\t\t\tthrow new Error(\"Object3D.add: object can't be added as a child of itself.\")\n\t\t}\n\n\t\tlet parent = object.parent\n\n\t\t// if (object && object.isObject3D) {\n\t\tif (parent) {\n\t\t\tparent.remove(object)\n\t\t}\n\n\t\tobject.parent = this\n\n\t\t// TODO\n\t\t// object.dispatchEvent({type: 'added'})\n\n\t\tthis.children.push(object)\n\t\t// } else {\n\t\t// \tthrow new Error('Object3D.add: object not an instance of THREE.Object3D.')\n\t\t// }\n\t}\n\n\t/**\n\t * Removes object as child of this object.\n\t * @param object A single Object3D instance to remove, or an array of Object3D instances to remove\n\t */\n\t// remove<T>(object: T): this {\n\tremove(object: Object3D): this {\n\t\t// let o: Object3D | null = null\n\n\t\t// if (Array.isArray<Object3D>(object)) {\n\t\t// \tfor (let i = 0, l = object.length; i < l; i++) {\n\t\t// \t\to = object[i] as Object3D\n\n\t\t// \t\tthis.__remove(o)\n\t\t// \t}\n\t\t// } else\n\t\t// if (object instanceof Object3D) {\n\t\tthis.__remove(object)\n\t\t// } else {\n\t\t// \tthrow new Error('Object3D.remove: The argument should be an Object3D or Array<Object3D>')\n\t\t// }\n\n\t\treturn this\n\t}\n\n\tprivate __remove(object: Object3D): void {\n\t\tconst index = this.children.indexOf(object)\n\n\t\tif (index !== -1) {\n\t\t\tobject.parent = null\n\n\t\t\t// TODO\n\t\t\t// object.dispatchEvent({type: 'removed'})\n\n\t\t\tthis.children.splice(index, 1)\n\t\t}\n\t}\n\n\t// /**\n\t//  * Adds object as a child of this, while maintaining the object's world transform.\n\t//  * @param object A single Object3D instance TODO support an array of Object3D instances\n\t//  */\n\t// attach(object: Object3D): this {\n\t// \tthis.updateWorldMatrix(true, false)\n\n\t// \tmatrix.getInverse(this.matrixWorld)\n\n\t// \tif (object.parent !== null) {\n\t// \t\tobject.parent.updateWorldMatrix(true, false)\n\n\t// \t\tmatrix.multiply(object.parent.matrixWorld)\n\t// \t}\n\n\t// \tobject.applyMatrix(matrix)\n\n\t// \tobject.updateWorldMatrix(false, false)\n\n\t// \tthis.add(object)\n\n\t// \treturn this\n\t// }\n\n\t// /**\n\t//  * Searches through the object's children and returns the first with a matching id.\n\t//  * @param id  Unique number of the object instance\n\t//  */\n\t// getObjectById(id: f32): Object3D | null {\n\t// \tfor (let i = 0, l = this.children.length; i < l; i++) {\n\t// \t\tconst child = this.children[i]\n\n\t// \t\tif (child.id === id) {\n\t// \t\t\treturn child\n\t// \t\t}\n\t// \t}\n\n\t// \treturn null\n\t// }\n\n\t// /**\n\t//  * Set the target vector to the world position of the current object.\n\t//  * @param target The vector to set.\n\t//  */\n\t// getWorldPosition(target: Vector3): Vector3 {\n\t// \tthis.updateMatrixWorld(true)\n\n\t// \treturn target.setFromMatrixPosition(this.matrixWorld)\n\t// }\n\n\t// /**\n\t//  * Set the target quaternion to the world quaternion of the current object.\n\t//  * @param target The quaternion to set.\n\t//  */\n\t// getWorldQuaternion(target: Quaternion): Quaternion {\n\t// \tthis.updateMatrixWorld(true)\n\n\t// \tthis.matrixWorld.decompose(position, target, scale)\n\n\t// \treturn target\n\t// }\n\n\t// /**\n\t//  * Set the target vector to the world scale of the current object.\n\t//  * @param target The vector to set.\n\t//  */\n\t// getWorldScale(target: Vector3): Vector3 {\n\t// \tthis.updateMatrixWorld(true)\n\n\t// \tthis.matrixWorld.decompose(position, quaternion, target)\n\n\t// \treturn target\n\t// }\n\n\t// /**\n\t//  * Set the target vector to the world direction of the current object.\n\t//  * @param target The vector to set.\n\t//  */\n\t// getWorldDirection(target: Vector3): Vector3 {\n\t// \tthis.updateMatrixWorld(true)\n\n\t// \tconst e = this.matrixWorld.elements\n\n\t// \treturn target.set(e[8], e[9], e[10]).normalize()\n\t// }\n\n\t// /**\n\t//  * Get intersections between a casted ray and this object.\n\t//  * The resulting points of intersection should be placed in the `intersects` array.\n\t//  * Subclasses such as Mesh, Line, and Points should implement this method in order to use raycasting.\n\t//  * @abstract\n\t//  * @param raycaster A raycaster to use in calculating intersections.\n\t//  * @param intersects An array in which all intersection points should be placed.\n\t//  */\n\t// raycast(raycaster: Raycaster, intersects: Intersection[]): void {}\n\n\t/**\n\t * Traverses the scene graph tree in pre-order starting at the current object.\n\t * @param callback A function which is called for each object in the traversed\n\t * tree. It is passed as argument the current object being traversed.\n\t */\n\ttraverse(callback: TraverseCallback): void {\n\t\tcallback(this)\n\n\t\tconst children = this.children\n\n\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].traverse(callback)\n\t\t}\n\t}\n\n\t// /**\n\t//  * Like the traverse() method, but skips traversing into any object that is not visible.\n\t//  * @param callback A function which is called for each object in the traversed\n\t//  * tree, being passed that object as an argument.\n\t//  */\n\t// traverseVisible(callback: TraverseCallback): void {\n\t// \tif (this.visible === false) return\n\n\t// \tcallback(this)\n\n\t// \tconst children = this.children\n\n\t// \tfor (let i = 0, l = children.length; i < l; i++) {\n\t// \t\tchildren[i].traverseVisible(callback)\n\t// \t}\n\t// }\n\n\t// /**\n\t//  * Traverse up the tree until reaching the root most object.\n\t//  * @param callback A function which is called for each object in the upward\n\t//  * traversal, being passed that object as an argument.\n\t//  */\n\t// traverseAncestors(callback: TraverseCallback): void {\n\t// \tconst parent = this.parent\n\n\t// \tif (parent !== null) {\n\t// \t\tcallback(parent)\n\n\t// \t\tparent.traverseAncestors(callback)\n\t// \t}\n\t// }\n\n\t/**\n\t * Composes the local position, rotation, and scale into the local matrix.\n\t */\n\tupdateMatrix(): void {\n\t\tthis.matrix.compose(this.position, this.quaternion, this.scale)\n\n\t\tthis.matrixWorldNeedsUpdate = true\n\t}\n\n\t/**\n\t * Updates global transform of the object and its children.\n\t */\n\tupdateMatrixWorld(force: boolean = false): void {\n\t\tif (this.matrixAutoUpdate) this.updateMatrix()\n\n\t\tif (this.matrixWorldNeedsUpdate || force) {\n\t\t\t// save to a variable as AS can not (yet) do nullable type narrowing on properties.\n\t\t\tconst parent = this.parent\n\n\t\t\tif (parent === null) {\n\t\t\t\tthis.matrixWorld.copy(this.matrix)\n\t\t\t} else {\n\t\t\t\tthis.matrixWorld.multiplyMatrices(parent.matrixWorld, this.matrix)\n\t\t\t}\n\n\t\t\tthis.matrixWorldNeedsUpdate = false\n\n\t\t\tforce = true\n\t\t}\n\n\t\t// update children\n\n\t\tconst children = this.children\n\n\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\tchildren[i].updateMatrixWorld(force)\n\t\t}\n\t}\n\n\t// updateWorldMatrix(updateParents: boolean = false, updateChildren: boolean = false): void {\n\t// \tvar parent = this.parent\n\n\t// \tif (updateParents === true && parent !== null) {\n\t// \t\tparent.updateWorldMatrix(true, false)\n\t// \t}\n\n\t// \tif (this.matrixAutoUpdate) this.updateMatrix()\n\n\t// \tif (this.parent === null) {\n\t// \t\tthis.matrixWorld.copy(this.matrix)\n\t// \t} else {\n\t// \t\tthis.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)\n\t// \t}\n\n\t// \t// update children\n\n\t// \tif (updateChildren === true) {\n\t// \t\tvar children = this.children\n\n\t// \t\tfor (var i = 0, l = children.length; i < l; i++) {\n\t// \t\t\tchildren[i].updateWorldMatrix(false, true)\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t/**\n\t * TODO, toJSON needs special handling. It would be used by JS to get JSON\n\t * representation of the AS object. There's an AS project for json:\n\t * https://github.com/nearprotocol/assemblyscript-json\n\t */\n\t// toJSON(meta?: {geometries: any; materials: any; textures: any; images: any}): any {\n\t// \t// meta is a string when called from JSON.stringify\n\t// \tvar isRootObject = meta === undefined || typeof meta === 'string'\n\n\t// \tvar output = {}\n\n\t// \t// meta is a hash used to collect geometries, materials.\n\t// \t// not providing it implies that this is the root object\n\t// \t// being serialized.\n\t// \tif (isRootObject) {\n\t// \t\t// initialize meta obj\n\t// \t\tmeta = {\n\t// \t\t\tgeometries: {},\n\t// \t\t\tmaterials: {},\n\t// \t\t\ttextures: {},\n\t// \t\t\timages: {},\n\t// \t\t\tshapes: {},\n\t// \t\t}\n\n\t// \t\toutput.metadata = {\n\t// \t\t\tversion: 4.5,\n\t// \t\t\ttype: 'Object',\n\t// \t\t\tgenerator: 'Object3D.toJSON',\n\t// \t\t}\n\t// \t}\n\n\t// \t// standard Object3D serialization\n\n\t// \tvar object = {}\n\n\t// \tobject.uuid = this.uuid\n\t// \tobject.type = this.type\n\n\t// \tif (this.name !== '') object.name = this.name\n\t// \tif (this.castShadow === true) object.castShadow = true\n\t// \tif (this.receiveShadow === true) object.receiveShadow = true\n\t// \tif (this.visible === false) object.visible = false\n\t// \tif (this.frustumCulled === false) object.frustumCulled = false\n\t// \tif (this.renderOrder !== 0) object.renderOrder = this.renderOrder\n\t// \tif (JSON.stringify(this.userData) !== '{}') object.userData = this.userData\n\n\t// \tobject.layers = this.layers.mask\n\t// \tobject.matrix = this.matrix.toArray()\n\n\t// \tif (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false\n\n\t// \t// object specific properties\n\n\t// \tif (this.isMesh && this.drawMode !== TrianglesDrawMode) object.drawMode = this.drawMode\n\n\t// \t//\n\n\t// \tfunction serialize(library, element) {\n\t// \t\tif (library[element.uuid] === undefined) {\n\t// \t\t\tlibrary[element.uuid] = element.toJSON(meta)\n\t// \t\t}\n\n\t// \t\treturn element.uuid\n\t// \t}\n\n\t// \tif (this.isMesh || this.isLine || this.isPoints) {\n\t// \t\tobject.geometry = serialize(meta.geometries, this.geometry)\n\n\t// \t\tvar parameters = this.geometry.parameters\n\n\t// \t\tif (parameters !== undefined && parameters.shapes !== undefined) {\n\t// \t\t\tvar shapes = parameters.shapes\n\n\t// \t\t\tif (Array.isArray(shapes)) {\n\t// \t\t\t\tfor (var i = 0, l = shapes.length; i < l; i++) {\n\t// \t\t\t\t\tvar shape = shapes[i]\n\n\t// \t\t\t\t\tserialize(meta.shapes, shape)\n\t// \t\t\t\t}\n\t// \t\t\t} else {\n\t// \t\t\t\tserialize(meta.shapes, shapes)\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \tif (this.material !== undefined) {\n\t// \t\tif (Array.isArray(this.material)) {\n\t// \t\t\tvar uuids = []\n\n\t// \t\t\tfor (var i = 0, l = this.material.length; i < l; i++) {\n\t// \t\t\t\tuuids.push(serialize(meta.materials, this.material[i]))\n\t// \t\t\t}\n\n\t// \t\t\tobject.material = uuids\n\t// \t\t} else {\n\t// \t\t\tobject.material = serialize(meta.materials, this.material)\n\t// \t\t}\n\t// \t}\n\n\t// \t//\n\n\t// \tif (this.children.length > 0) {\n\t// \t\tobject.children = []\n\n\t// \t\tfor (var i = 0; i < this.children.length; i++) {\n\t// \t\t\tobject.children.push(this.children[i].toJSON(meta).object)\n\t// \t\t}\n\t// \t}\n\n\t// \tif (isRootObject) {\n\t// \t\tvar geometries = extractFromCache(meta.geometries)\n\t// \t\tvar materials = extractFromCache(meta.materials)\n\t// \t\tvar textures = extractFromCache(meta.textures)\n\t// \t\tvar images = extractFromCache(meta.images)\n\t// \t\tvar shapes = extractFromCache(meta.shapes)\n\n\t// \t\tif (geometries.length > 0) output.geometries = geometries\n\t// \t\tif (materials.length > 0) output.materials = materials\n\t// \t\tif (textures.length > 0) output.textures = textures\n\t// \t\tif (images.length > 0) output.images = images\n\t// \t\tif (shapes.length > 0) output.shapes = shapes\n\t// \t}\n\n\t// \toutput.object = object\n\n\t// \treturn output\n\n\t// \t// extract data from the cache hash\n\t// \t// remove metadata on each item\n\t// \t// and return as array\n\t// \tfunction extractFromCache(cache) {\n\t// \t\tvar values = []\n\t// \t\tfor (var key in cache) {\n\t// \t\t\tvar data = cache[key]\n\t// \t\t\tdelete data.metadata\n\t// \t\t\tvalues.push(data)\n\t// \t\t}\n\t// \t\treturn values\n\t// \t}\n\t// }\n\n\t// /**\n\t//  * Clones the current object, returning a new one with all the same property values.\n\t//  * @param recursive Whether or not to also clone children recursively. If\n\t//  * true, creates a copy of the current object's whole tree.\n\t//  */\n\t// clone(recursive: boolean = false): Object3D {\n\t// \treturn new Object3D().copy(this, recursive)\n\t// }\n\n\t// /**\n\t//  * Copies all data (and children) of the source object to this object.\n\t//  * @param source The object to copy from.\n\t//  * @param recursive Whether or not to also copy children recursively. If true,\n\t//  * results in copying the whole tree starting at the source as the root.\n\t//  */\n\t// copy(source: Object3D, recursive: boolean = false): this {\n\t// \tif (recursive === undefined) recursive = true\n\n\t// \tthis.name = source.name\n\n\t// \tthis.up.copy(source.up)\n\n\t// \tthis.position.copy(source.position)\n\t// \tthis.quaternion.copy(source.quaternion)\n\t// \tthis.scale.copy(source.scale)\n\n\t// \tthis.matrix.copy(source.matrix)\n\t// \tthis.matrixWorld.copy(source.matrixWorld)\n\n\t// \tthis.matrixAutoUpdate = source.matrixAutoUpdate\n\t// \tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate\n\n\t// \tthis.layers.mask = source.layers.mask\n\t// \tthis.visible = source.visible\n\n\t// \tthis.castShadow = source.castShadow\n\t// \tthis.receiveShadow = source.receiveShadow\n\n\t// \tthis.frustumCulled = source.frustumCulled\n\t// \tthis.renderOrder = source.renderOrder\n\n\t// \t// no `any`-typed userData in AS\n\t// \t// this.userData = JSON.parse(JSON.stringify(source.userData))\n\n\t// \tif (recursive === true) {\n\t// \t\tfor (var i = 0; i < source.children.length; i++) {\n\t// \t\t\tvar child = source.children[i]\n\t// \t\t\tthis.add(child.clone())\n\t// \t\t}\n\t// \t}\n\n\t// \treturn this\n\t// }\n}\n","import {Vector3} from './Vector3'\nimport {Sphere} from './Sphere'\nimport {Plane} from './Plane'\nimport {Matrix4} from './Matrix4'\nimport {Object3D} from '../core/Object3D'\n//  import {Sprite} from '../objects/Sprite'\nimport {Box3} from './Box3'\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author bhouston / http://clara.io\n * @author jtenner / https://github.com/jtenner\n */\n\nconst _sphere = new Sphere()\nconst _vector = new Vector3()\n\nexport class Frustum {\n\t// TODO: this should be a static array since it never changes size\n\tplanes: Plane[]\n\n\tconstructor(\n\t\tp0: Plane | null = null,\n\t\tp1: Plane | null = null,\n\t\tp2: Plane | null = null,\n\t\tp3: Plane | null = null,\n\t\tp4: Plane | null = null,\n\t\tp5: Plane | null = null\n\t) {\n\t\tthis.planes = [\n\t\t\tp0 == null ? new Plane() : p0,\n\t\t\tp1 == null ? new Plane() : p1,\n\t\t\tp2 == null ? new Plane() : p2,\n\t\t\tp3 == null ? new Plane() : p3,\n\t\t\tp4 == null ? new Plane() : p4,\n\t\t\tp5 == null ? new Plane() : p5,\n\t\t]\n\t}\n\n\tpublic set(p0: Plane, p1: Plane, p2: Plane, p3: Plane, p4: Plane, p5: Plane): this {\n\t\tconst planes = this.planes\n\n\t\tplanes[0].copy(p0)\n\t\tplanes[1].copy(p1)\n\t\tplanes[2].copy(p2)\n\t\tplanes[3].copy(p3)\n\t\tplanes[4].copy(p4)\n\t\tplanes[5].copy(p5)\n\n\t\treturn this\n\t}\n\n\tclone(): this {\n\t\tlet a = new Frustum()\n\t\t// @ts-ignore\n\t\treturn a.copy(this)\n\t}\n\n\t// todo: maybe avoid using a for loop since it's cpu intensive here\n\tcopy(frustum: Frustum): this {\n\t\tconst planes = this.planes\n\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tplanes[i].copy(frustum.planes[i])\n\t\t}\n\n\t\treturn this\n\t}\n\n\tpublic setFromProjectionMatrix(m: Matrix4): this {\n\t\tconst planes = this.planes\n\t\tconst me = m.elements\n\t\tconst me0 = me[0],\n\t\t\tme1 = me[1],\n\t\t\tme2 = me[2],\n\t\t\tme3 = me[3]\n\t\tconst me4 = me[4],\n\t\t\tme5 = me[5],\n\t\t\tme6 = me[6],\n\t\t\tme7 = me[7]\n\t\tconst me8 = me[8],\n\t\t\tme9 = me[9],\n\t\t\tme10 = me[10],\n\t\t\tme11 = me[11]\n\t\tconst me12 = me[12],\n\t\t\tme13 = me[13],\n\t\t\tme14 = me[14],\n\t\t\tme15 = me[15]\n\n\t\tplanes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize()\n\t\tplanes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize()\n\t\tplanes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize()\n\t\tplanes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize()\n\t\tplanes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize()\n\t\tplanes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize()\n\n\t\treturn this\n\t}\n\t/*\n  intersectsObject( object: Object3D ) {\n    \n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\n\n\t\t_sphere.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );\n\n\t\treturn this.intersectsSphere( _sphere );\n\n  }\n  */\n\n\t// public intersectsSprite(sprite: Sprite): boolean {\n\t// \t_sphere.center.set(0, 0, 0)\n\t// \t_sphere.radius = 0.7071067811865476\n\t// \t_sphere.applyMatrix4(sprite.matrixWorld)\n\t//\n\t// \treturn this.intersectsSphere(_sphere)\n\t// }\n\n\tpublic intersectsSphere(sphere: Sphere): boolean {\n\t\tconst planes = this.planes\n\t\tconst center = sphere.center\n\t\tconst negRadius = -sphere.radius\n\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tconst distance = planes[i].distanceToPoint(center)\n\n\t\t\tif (distance < negRadius) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\tpublic intersectsBox(box: Box3): bool {\n\t\tconst planes = this.planes\n\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tconst plane = planes[i]\n\n\t\t\t// corner at max distance\n\n\t\t\t_vector.x = plane.normal.x > 0 ? box.max.x : box.min.x\n\t\t\t_vector.y = plane.normal.y > 0 ? box.max.y : box.min.y\n\t\t\t_vector.z = plane.normal.z > 0 ? box.max.z : box.min.z\n\n\t\t\tif (plane.distanceToPoint(_vector) < 0) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\tpublic containsPoint(point: Vector3): bool {\n\t\tconst planes = this.planes\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tif (planes[i].distanceToPoint(point) < 0) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n}\n","import {Vector3} from './Vector3'\nimport {Sphere} from './Sphere'\nimport {Plane} from './Plane'\nimport {Box3} from './Box3'\nimport {Matrix4} from './Matrix4'\n\nconst _vector = new Vector3()\nconst _segCenter = new Vector3()\nconst _segDir = new Vector3()\nconst _diff = new Vector3()\n\nconst _edge1 = new Vector3()\nconst _edge2 = new Vector3()\nconst _normal = new Vector3()\n\n/**\n * @author bhouston / http://clara.io\n */\nexport class Ray {\n\tconstructor(public origin: Vector3 = new Vector3(), public direction: Vector3 = new Vector3(0, 0, -1)) {}\n\n\tpublic set(origin: Vector3, direction: Vector3): Ray {\n\t\tthis.origin.copy(origin)\n\t\tthis.direction.copy(direction)\n\t\treturn this\n\t}\n\n\tpublic clone(): Ray {\n\t\treturn new Ray().copy(this)\n\t}\n\n\tpublic copy(ray: Ray): Ray {\n\t\tthis.origin.copy(ray.origin)\n\t\tthis.direction.copy(ray.direction)\n\t\treturn this\n\t}\n\n\tpublic at(t: f32, target: Vector3): Vector3 {\n\t\t// previously it checked to make sure that `target: Vector3` is set.\n\t\t// We can assert that Vector3 is a reference with the signature at\n\t\t// compile time.\n\n\t\treturn target.copy(this.direction).multiplyScalar(t).add(this.origin)\n\t}\n\n\tpublic lookAt(v: Vector3): Ray {\n\t\tthis.direction.copy(v).sub(this.origin).normalize()\n\t\treturn this\n\t}\n\n\tpublic recast(t: f32): Ray {\n\t\tthis.origin.copy(this.at(t, _vector))\n\t\treturn this\n\t}\n\n\tpublic closestPointToPoint(point: Vector3, target: Vector3): Vector3 {\n\t\ttarget.subVectors(point, this.origin)\n\t\tconst directionDistance = target.dot(this.direction)\n\t\tif (directionDistance < 0) {\n\t\t\treturn target.copy(this.origin)\n\t\t}\n\t\treturn target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin)\n\t}\n\n\tpublic distanceToPoint(point: Vector3): f32 {\n\t\treturn Mathf.sqrt(this.distanceSqToPoint(point))\n\t}\n\n\tpublic distanceSqToPoint(point: Vector3): f32 {\n\t\tconst directionDistance = _vector.subVectors(point, this.origin).dot(this.direction)\n\n\t\t// point behind the ray\n\n\t\tif (directionDistance < 0) {\n\t\t\treturn this.origin.distanceToSquared(point)\n\t\t}\n\n\t\t_vector.copy(this.direction).multiplyScalar(directionDistance).add(this.origin)\n\n\t\treturn _vector.distanceToSquared(point)\n\t}\n\n\tpublic distanceSqToSegment(\n\t\tv0: Vector3,\n\t\tv1: Vector3,\n\t\toptionalPointOnRay: Vector3 | null,\n\t\toptionalPointOnSegment: Vector3 | null\n\t): f32 {\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy(v0).add(v1).multiplyScalar(0.5)\n\t\t_segDir.copy(v1).sub(v0).normalize()\n\t\t_diff.copy(this.origin).sub(_segCenter)\n\n\t\tconst segExtent = v0.distanceTo(v1) * 0.5\n\t\tconst a01 = -this.direction.dot(_segDir)\n\t\tconst b0 = _diff.dot(this.direction)\n\t\tconst b1 = -_diff.dot(_segDir)\n\t\tconst c = _diff.lengthSq()\n\t\tconst det = abs<f32>(1 - a01 * a01)\n\t\tlet s0: f32, s1: f32, sqrDist: f32, extDet: f32\n\n\t\tif (det > 0) {\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0\n\t\t\ts1 = a01 * b0 - b1\n\t\t\textDet = segExtent * det\n\n\t\t\tif (s0 >= 0) {\n\t\t\t\tif (s1 >= -extDet) {\n\t\t\t\t\tif (s1 <= extDet) {\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = <f32>1 / det\n\t\t\t\t\t\ts0 *= invDet\n\t\t\t\t\t\ts1 *= invDet\n\t\t\t\t\t\tsqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent\n\t\t\t\t\t\ts0 = max<f32>(0, -(a01 * s1 + b0))\n\t\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = -segExtent\n\t\t\t\t\ts0 = max<f32>(0, -(a01 * s1 + b0))\n\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (s1 <= -extDet) {\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = max<f32>(0, -(-a01 * segExtent + b0))\n\t\t\t\t\ts1 = s0 > 0 ? -segExtent : min<f32>(max<f32>(-segExtent, -b1), segExtent)\n\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c\n\t\t\t\t} else if (s1 <= extDet) {\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0\n\t\t\t\t\ts1 = min<f32>(max<f32>(-segExtent, -b1), segExtent)\n\t\t\t\t\tsqrDist = s1 * (s1 + 2 * b1) + c\n\t\t\t\t} else {\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = max<f32>(0, -(a01 * segExtent + b0))\n\t\t\t\t\ts1 = s0 > 0 ? segExtent : min<f32>(max<f32>(-segExtent, -b1), segExtent)\n\t\t\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = a01 > 0 ? -segExtent : segExtent\n\t\t\ts0 = max<f32>(0, -(a01 * s1 + b0))\n\t\t\tsqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c\n\t\t}\n\n\t\tif (optionalPointOnRay) {\n\t\t\toptionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin)\n\t\t}\n\n\t\tif (optionalPointOnSegment) {\n\t\t\toptionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter)\n\t\t}\n\n\t\treturn sqrDist\n\t}\n\n\tpublic intersectSphere(sphere: Sphere, target: Vector3): Vector3 | null {\n\t\t_vector.subVectors(sphere.center, this.origin)\n\t\tconst tca = _vector.dot(this.direction)\n\t\tconst d2 = _vector.dot(_vector) - tca * tca\n\t\tconst radius2 = sphere.radius * sphere.radius\n\n\t\tif (d2 > radius2) return null\n\n\t\tconst thc = Mathf.sqrt(radius2 - d2)\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc\n\n\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\tif (t0 < 0 && t1 < 0) return null\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at(select<f32>(t1, t0, t0 < 0), target)\n\t}\n\n\tpublic intersectsSphere(sphere: Sphere): bool {\n\t\treturn this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius\n\t}\n\n\t/**\n\t * This method used to return null, but it never returns a negative number, so a\n\t * result of -1 is equivalent to a null result.\n\t */\n\tpublic distanceToPlane(plane: Plane): f32 {\n\t\tconst denominator = plane.normal.dot(this.direction)\n\n\t\tif (denominator === 0) {\n\t\t\t// line is coplanar, return origin\n\t\t\tif (plane.distanceToPoint(this.origin) === 0) {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\t\t\treturn -1\n\t\t}\n\n\t\tconst t = -(this.origin.dot(plane.normal) + plane.constant) / denominator\n\n\t\t// Return if the ray never intersects the plane\n\t\treturn t >= 0 ? t : -1\n\t}\n\n\tpublic intersectPlane(plane: Plane, target: Vector3): Vector3 | null {\n\t\tconst t = this.distanceToPlane(plane)\n\n\t\t// this used to be a null check\n\t\tif (t === -1) {\n\t\t\treturn null\n\t\t}\n\n\t\treturn this.at(t, target)\n\t}\n\n\tpublic intersectsPlane(plane: Plane): bool {\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint(this.origin)\n\n\t\tif (distToPoint === 0) {\n\t\t\treturn true\n\t\t}\n\n\t\tconst denominator = plane.normal.dot(this.direction)\n\n\t\tif (denominator * distToPoint < 0) {\n\t\t\treturn true\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false\n\t}\n\n\tpublic intersectsBox(box: Box3): bool {\n\t\treturn this.intersectBox(box, _vector) != null\n\t}\n\n\tpublic intersectBox(box: Box3, target: Vector3): Vector3 | null {\n\t\tlet tmin: f32, tmax: f32, tymin: f32, tymax: f32, tzmin: f32, tzmax: f32\n\n\t\tconst invdirx = <f32>1 / this.direction.x,\n\t\t\tinvdiry = <f32>1 / this.direction.y,\n\t\t\tinvdirz = <f32>1 / this.direction.z\n\n\t\tconst origin = this.origin\n\n\t\tif (invdirx >= 0) {\n\t\t\ttmin = (box.min.x - origin.x) * invdirx\n\t\t\ttmax = (box.max.x - origin.x) * invdirx\n\t\t} else {\n\t\t\ttmin = (box.max.x - origin.x) * invdirx\n\t\t\ttmax = (box.min.x - origin.x) * invdirx\n\t\t}\n\n\t\tif (invdiry >= 0) {\n\t\t\ttymin = (box.min.y - origin.y) * invdiry\n\t\t\ttymax = (box.max.y - origin.y) * invdiry\n\t\t} else {\n\t\t\ttymin = (box.max.y - origin.y) * invdiry\n\t\t\ttymax = (box.min.y - origin.y) * invdiry\n\t\t}\n\n\t\tif (tmin > tymax || tymin > tmax) return null\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif (tymin > tmin || tmin !== tmin) tmin = tymin\n\n\t\tif (tymax < tmax || tmax !== tmax) tmax = tymax\n\n\t\tif (invdirz >= 0) {\n\t\t\ttzmin = (box.min.z - origin.z) * invdirz\n\t\t\ttzmax = (box.max.z - origin.z) * invdirz\n\t\t} else {\n\t\t\ttzmin = (box.max.z - origin.z) * invdirz\n\t\t\ttzmax = (box.min.z - origin.z) * invdirz\n\t\t}\n\n\t\tif (tmin > tzmax || tzmin > tmax) return null\n\n\t\tif (tzmin > tmin || tmin !== tmin) tmin = tzmin\n\n\t\tif (tzmax < tmax || tmax !== tmax) tmax = tzmax\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif (tmax < 0) return null\n\n\t\treturn this.at(tmin >= 0 ? tmin : tmax, target)\n\t}\n\n\tpublic intersectTriangle(\n\t\ta: Vector3,\n\t\tb: Vector3,\n\t\tc: Vector3,\n\t\tbackfaceCulling: bool,\n\t\ttarget: Vector3\n\t): Vector3 | null {\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors(b, a)\n\t\t_edge2.subVectors(c, a)\n\t\t_normal.crossVectors(_edge1, _edge2)\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot(_normal)\n\t\tlet sign: f32\n\n\t\tif (DdN > 0) {\n\t\t\tif (backfaceCulling) return null\n\t\t\tsign = 1\n\t\t} else if (DdN < 0) {\n\t\t\tsign = -1\n\t\t\tDdN = -DdN\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\n\t\t_diff.subVectors(this.origin, a)\n\t\tconst DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2))\n\n\t\t// b1 < 0, no intersection\n\t\tif (DdQxE2 < 0) {\n\t\t\treturn null\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff))\n\n\t\t// b2 < 0, no intersection\n\t\tif (DdE1xQ < 0) {\n\t\t\treturn null\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif (DdQxE2 + DdE1xQ > DdN) {\n\t\t\treturn null\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = -sign * _diff.dot(_normal)\n\n\t\t// t < 0, no intersection\n\t\tif (QdN < 0) {\n\t\t\treturn null\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at(QdN / DdN, target)\n\t}\n\n\tpublic applyMatrix4(matrix4: Matrix4): Ray {\n\t\tthis.origin.applyMatrix4(matrix4)\n\t\tthis.direction.transformDirection(matrix4)\n\n\t\treturn this\n\t}\n\n\t// @operator(\"==\")\n\tpublic equals(ray: Ray): bool {\n\t\treturn ray.origin.equals(this.origin) && ray.direction.equals(this.direction)\n\t}\n}\n","import { RenderContext } from \"./RenderContext\";\r\nimport { WebGLProgram, WebGLUniformLocation, WebGLBuffer, GLint } from \"./WebGL\";\r\nimport { consoleLog } from \"../../netcode/netcode\";\r\nimport { RenderColor } from \"./RenderCommon\";\r\n\r\nconst kInnerVS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    attribute vec2 a_position;\r\n    uniform vec2 u_xy;\r\n    uniform float u_scale;\r\n\r\n    // Output to fragment shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        vec2 p = a_position;\r\n        v_pos = p;\r\n        p = p * u_scale + u_xy;\r\n        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);\r\n    }\r\n`;\r\n\r\nconst kInnerFS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    uniform vec3 u_color;\r\n    uniform float u_shine_angle;\r\n    uniform float u_shine_dist;\r\n\r\n    // Input from vertex shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        // Radius of circle is always 1, so dist2 = 1 on the border\r\n        float alpha = (sin(atan(v_pos.y, v_pos.x) - u_shine_angle - 3.14159 * 0.5) + 1.0) * 0.5;\r\n\r\n        gl_FragColor = vec4(mix(u_color, vec3(1.0, 1.0, 1.0), alpha*alpha * u_shine_dist), 1.0);\r\n    }\r\n`;\r\n\r\nconst kOuterVS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    attribute vec2 a_position;\r\n    uniform vec2 u_xy;\r\n    uniform float u_scale;\r\n\r\n    // Output to fragment shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        vec2 p = a_position;\r\n        v_pos = p;\r\n        p = p * u_scale + u_xy;\r\n        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);\r\n    }\r\n`;\r\n\r\nconst kOuterFS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    uniform vec3 u_color;\r\n    uniform float u_t;\r\n\r\n    // Input from vertex shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        // Radius of circle is always 1, so dist2 = 1 on the border\r\n        float x = v_pos.x * v_pos.x + v_pos.y * v_pos.y;\r\n\r\n        float y = (sin(u_t) + 1.0) * 0.05;\r\n\r\n        float alpha = clamp(x * 0.8 - y, 0.0, 1.0);\r\n\r\n        gl_FragColor = vec4(u_color, 1.0 - alpha);\r\n    }\r\n`;\r\n\r\n// Data generated by RenderPlayerData and cached for each use\r\nexport class RenderPlayerData {\r\n    vertices: StaticArray<f32>;\r\n\r\n    inner_indices: StaticArray<u8>;\r\n    outer_indices: StaticArray<u8>;\r\n\r\n    // Inner radius is the corner vertices on the inside\r\n    // Outer radius is the middle of the outer quads\r\n    // 1.0 is always the radius of the circle of the player\r\n    constructor(cells: i32, inner_radius_max: f32, outer_radius_min: f32) {\r\n        if (cells < 5) {\r\n            cells = 5;\r\n        } else if (cells > 127) {\r\n            // Limit to 8-bit indices\r\n            cells = 127;\r\n        }\r\n\r\n        const base_angle: f32 = 2.0 * Mathf.PI / f32(cells);\r\n        const outer_radius_max: f32 = outer_radius_min / Mathf.cos(base_angle);\r\n\r\n        this.vertices = new StaticArray<f32>(2 + 4 * cells);\r\n        this.inner_indices = new StaticArray<u8>(3 * cells);\r\n        this.outer_indices = new StaticArray<u8>(6 * cells);\r\n\r\n        // index 0\r\n        this.vertices[0] = 0.0;\r\n        this.vertices[1] = 0.0;\r\n\r\n        let iv: i32 = 2, ii: i32 = 0;\r\n        let ov: i32 = 2 + 2 * cells, oi: i32 = 0;\r\n\r\n        for (let i: i32 = 0; i < cells; ++i) {\r\n            const angle: f32 = base_angle * f32(i);\r\n            const cos_angle: f32 = Mathf.cos(angle);\r\n            const sin_angle: f32 = Mathf.sin(angle);\r\n\r\n            this.vertices[iv + 0] = inner_radius_max * cos_angle;\r\n            this.vertices[iv + 1] = inner_radius_max * sin_angle;\r\n\r\n            this.vertices[ov + 0] = outer_radius_max * cos_angle;\r\n            this.vertices[ov + 1] = outer_radius_max * sin_angle;\r\n\r\n            this.inner_indices[ii + 0] = 0;\r\n            this.inner_indices[ii + 1] = u8(i + 1);\r\n            if (i == cells - 1) {\r\n                this.inner_indices[ii + 2] = 1;\r\n                this.outer_indices[oi + 2] = 1;\r\n                this.outer_indices[oi + 4] = u8(1 + cells);\r\n                this.outer_indices[oi + 5] = 1;\r\n            } else {\r\n                this.inner_indices[ii + 2] = u8(i + 2);\r\n                this.outer_indices[oi + 2] = u8(i + 2);\r\n                this.outer_indices[oi + 4] = u8(2 + cells + i);\r\n                this.outer_indices[oi + 5] = u8(i + 2);\r\n            }\r\n\r\n            this.outer_indices[oi + 0] = u8(i + 1);\r\n            this.outer_indices[oi + 1] = u8(1 + cells + i);\r\n\r\n            this.outer_indices[oi + 3] = u8(1 + cells + i);\r\n\r\n            iv += 2;\r\n            ii += 3;\r\n\r\n            ov += 2;\r\n            oi += 6;\r\n        }\r\n    }\r\n}\r\n\r\n// Render program shared between all players\r\nexport class RenderPlayerProgram {\r\n    // Inner program\r\n    inner_program: WebGLProgram;\r\n    inner_a_position: GLint;\r\n    inner_u_xy: WebGLUniformLocation;\r\n    inner_u_scale: WebGLUniformLocation;\r\n    inner_u_color: WebGLUniformLocation;\r\n    inner_u_shine_angle: WebGLUniformLocation;\r\n    inner_u_shine_dist: WebGLUniformLocation;\r\n\r\n    // Outer program\r\n    outer_program: WebGLProgram;\r\n    outer_a_position: GLint;\r\n    outer_u_xy: WebGLUniformLocation;\r\n    outer_u_scale: WebGLUniformLocation;\r\n    outer_u_color: WebGLUniformLocation;\r\n    outer_u_t: WebGLUniformLocation;\r\n\r\n    vertices_buffer: WebGLBuffer;\r\n    inner_indices_buffer: WebGLBuffer;\r\n    outer_indices_buffer: WebGLBuffer;\r\n\r\n    data: RenderPlayerData;\r\n\r\n    constructor() {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        gl.getExtension('OES_standard_derivatives');\r\n        gl.getExtension('OES_texture_float_linear');\r\n        //gl.getExtension('OES_texture_border_clamp');\r\n\r\n        const inner_vs = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(inner_vs, kInnerVS);\r\n        gl.compileShader(inner_vs);\r\n\r\n        const inner_fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(inner_fs, kInnerFS);\r\n        gl.compileShader(inner_fs);\r\n\r\n        this.inner_program = gl.createProgram();\r\n        gl.attachShader(this.inner_program, inner_vs);\r\n        gl.attachShader(this.inner_program, inner_fs);\r\n        gl.linkProgram(this.inner_program);\r\n        gl.useProgram(this.inner_program);\r\n\r\n        this.inner_a_position = gl.getAttribLocation(this.inner_program, \"a_position\");\r\n        this.inner_u_xy = gl.getUniformLocation(this.inner_program, \"u_xy\");\r\n        this.inner_u_scale = gl.getUniformLocation(this.inner_program, \"u_scale\");\r\n        this.inner_u_color = gl.getUniformLocation(this.inner_program, \"u_color\");\r\n        this.inner_u_shine_angle = gl.getUniformLocation(this.inner_program, \"u_shine_angle\");\r\n        this.inner_u_shine_dist = gl.getUniformLocation(this.inner_program, \"u_shine_dist\");\r\n\r\n        const outer_vs = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(outer_vs, kOuterVS);\r\n        gl.compileShader(outer_vs);\r\n\r\n        const outer_fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(outer_fs, kOuterFS);\r\n        gl.compileShader(outer_fs);\r\n\r\n        this.outer_program = gl.createProgram();\r\n        gl.attachShader(this.outer_program, outer_vs);\r\n        gl.attachShader(this.outer_program, outer_fs);\r\n        gl.linkProgram(this.outer_program);\r\n        gl.useProgram(this.outer_program);\r\n\r\n        this.outer_a_position = gl.getAttribLocation(this.outer_program, \"a_position\");\r\n        this.outer_u_xy = gl.getUniformLocation(this.outer_program, \"u_xy\");\r\n        this.outer_u_scale = gl.getUniformLocation(this.outer_program, \"u_scale\");\r\n        this.outer_u_color = gl.getUniformLocation(this.outer_program, \"u_color\");\r\n        this.outer_u_t = gl.getUniformLocation(this.outer_program, \"u_t\");\r\n\r\n        this.vertices_buffer = gl.createBuffer();\r\n        this.inner_indices_buffer = gl.createBuffer();\r\n        this.outer_indices_buffer = gl.createBuffer();\r\n\r\n        this.data = new RenderPlayerData(11, 0.9, 1.1);\r\n    }\r\n\r\n    public DrawPlayer(\r\n        color: RenderColor,\r\n        x: f32, y: f32,\r\n        scale: f32,\r\n        shine_angle: f32, shine_dist: f32,\r\n        t: u64): void {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        const data = this.data;\r\n\r\n\r\n        gl.useProgram(this.inner_program);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n\r\n        gl.enableVertexAttribArray(this.inner_a_position);\r\n\r\n        // attribute | dimensions | data type | normalize | stride bytes | offset bytes\r\n        gl.vertexAttribPointer(this.inner_a_position, 2, gl.FLOAT, +false, 8, 0);\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.inner_indices_buffer);\r\n\r\n        gl.uniform3f(this.inner_u_color, color.r, color.g, color.b);\r\n\r\n        gl.uniform2f(this.inner_u_xy, x, y);\r\n        gl.uniform1f(this.inner_u_scale, scale);\r\n        gl.uniform1f(this.inner_u_shine_angle, shine_angle);\r\n        gl.uniform1f(this.inner_u_shine_dist, shine_dist);\r\n\r\n        // Use DYNAMIC_DRAW because we want to change this for each line we render\r\n        gl.bufferData<f32>(gl.ARRAY_BUFFER, data.vertices, gl.DYNAMIC_DRAW);\r\n        gl.bufferData<u8>(gl.ELEMENT_ARRAY_BUFFER, data.inner_indices, gl.DYNAMIC_DRAW);\r\n\r\n        gl.drawElements(gl.TRIANGLES, data.inner_indices.length, gl.UNSIGNED_BYTE, 0);\r\n\r\n\r\n        gl.useProgram(this.outer_program);\r\n\r\n        gl.enableVertexAttribArray(this.outer_a_position);\r\n\r\n        // attribute | dimensions | data type | normalize | stride bytes | offset bytes\r\n        gl.vertexAttribPointer(this.outer_a_position, 2, gl.FLOAT, +false, 8, 0);\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.outer_indices_buffer);\r\n\r\n        //gl.uniform3f(this.outer_u_color, foreground_r, foreground_g, foreground_b);\r\n        gl.uniform3f(this.outer_u_color, 0.0, 0.0, 0.0);\r\n\r\n        gl.uniform2f(this.outer_u_xy, x, y);\r\n        gl.uniform1f(this.outer_u_scale, scale);\r\n        gl.uniform1f(this.outer_u_t, f32(t/4 % 1024) * 2.0 * Mathf.PI / 1024.0);\r\n\r\n        // Use DYNAMIC_DRAW because we want to change this for each line we render\r\n        gl.bufferData<u8>(gl.ELEMENT_ARRAY_BUFFER, data.outer_indices, gl.DYNAMIC_DRAW);\r\n\r\n        gl.drawElements(gl.TRIANGLES, data.outer_indices.length, gl.UNSIGNED_BYTE, 0);\r\n    }\r\n}\r\n","import { RenderContext } from \"./RenderContext\";\r\nimport { WebGLProgram, WebGLUniformLocation, WebGLBuffer, GLint } from \"./WebGL\";\r\nimport { consoleLog } from \"../../netcode/netcode\";\r\nimport { RenderColor } from \"./RenderCommon\";\r\n\r\nconst kVS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    attribute vec2 a_position;\r\n\r\n    // Output to fragment shader:\r\n    varying float v_dist;\r\n\r\n    void main() {\r\n        vec2 p = a_position;\r\n        v_dist = clamp(1.0 - length(p), 0.0, 1.0);\r\n        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);\r\n    }\r\n`;\r\n\r\nconst kFS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    uniform vec3 u_color;\r\n    uniform float u_t;\r\n\r\n    // Input from vertex shader:\r\n    varying float v_dist;\r\n\r\n    void main() {\r\n        float alpha = (sin(u_t + v_dist * 16.0) + 1.0) * 0.5 * 0.8 + 0.2;\r\n\r\n        gl_FragColor = vec4(u_color * alpha, 1.0);\r\n    }\r\n`;\r\n\r\nexport class RenderStringProgram {\r\n    program: WebGLProgram;\r\n    a_position: GLint;\r\n    a_dist: GLint;\r\n    u_color: WebGLUniformLocation;\r\n    u_t: WebGLUniformLocation;\r\n\r\n    vertices_buffer: WebGLBuffer;\r\n    data: StaticArray<f32> = new StaticArray<f32>(4);\r\n\r\n    constructor() {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        gl.getExtension('OES_standard_derivatives');\r\n        gl.getExtension('OES_texture_float_linear');\r\n        //gl.getExtension('OES_texture_border_clamp');\r\n\r\n        const vs = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vs, kVS);\r\n        gl.compileShader(vs);\r\n\r\n        const fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fs, kFS);\r\n        gl.compileShader(fs);\r\n\r\n        this.program = gl.createProgram();\r\n        gl.attachShader(this.program, vs);\r\n        gl.attachShader(this.program, fs);\r\n        gl.linkProgram(this.program);\r\n        gl.useProgram(this.program);\r\n\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        this.u_t = gl.getUniformLocation(this.program, \"u_t\");\r\n\r\n        this.vertices_buffer = gl.createBuffer();\r\n    }\r\n\r\n    public DrawString(\r\n        color: RenderColor,\r\n        x0: f32, y0: f32,\r\n        x1: f32, y1: f32,\r\n        t: u64): void {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        const data = this.data;\r\n\r\n        data[0] = x0;\r\n        data[1] = y0;\r\n        data[2] = x1;\r\n        data[3] = y1;\r\n\r\n        gl.useProgram(this.program);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n\r\n        gl.enableVertexAttribArray(this.a_position);\r\n\r\n        // attribute | dimensions | data type | normalize | stride bytes | offset bytes\r\n        gl.vertexAttribPointer(this.a_position, 2, gl.FLOAT, +false, 8, 0);\r\n\r\n        gl.uniform3f(this.u_color, color.r, color.g, color.b);\r\n        gl.uniform1f(this.u_t, f32(t/4 % 1024) * 4.0 * Mathf.PI / 1024.0);\r\n\r\n        // Use DYNAMIC_DRAW because we want to change this for each line we render\r\n        gl.bufferData<f32>(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);\r\n\r\n        gl.drawArrays(gl.LINES, 0, 2);\r\n    }\r\n}\r\n","import { RenderContext } from \"./RenderContext\";\r\nimport { WebGLProgram, WebGLUniformLocation, WebGLBuffer, GLint } from \"./WebGL\";\r\nimport { consoleLog } from \"../../netcode/netcode\";\r\nimport { RenderColor } from \"./RenderCommon\";\r\n\r\nconst kVS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    attribute vec2 a_position;\r\n    uniform vec2 u_xy;\r\n    uniform float u_scale;\r\n    uniform float u_angle;\r\n\r\n    // Output to fragment shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        vec2 p = a_position;\r\n        v_pos = p * 8.0;\r\n        p = vec2(-p.x * sin(u_angle) + p.y * cos(u_angle), p.x * cos(u_angle) + p.y * sin(u_angle));\r\n        p = p * u_scale + u_xy;\r\n        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);\r\n    }\r\n`;\r\n\r\nconst kFS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    uniform vec3 u_color;\r\n    uniform float u_t;\r\n\r\n    // Input from vertex shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        float d = length(v_pos);\r\n        float f = 0.;\r\n        float phase = u_t;\r\n        float dir = 1.;\r\n        float a = 0.;\r\n        float len = -d*(cos(u_t)*.2+.2);\r\n        for(float i = 0.; i<10.0; i+=1.){\r\n            float p = phase +(sin(i+u_t)-1.)*.05+len;\r\n            a = dot(normalize(v_pos), normalize(vec2(cos((p)*dir), sin((p)*dir))));\r\n            a = max(0., a);\r\n            a = pow(a, 10.);\r\n            dir*=-1.;\r\n            phase+=mod(i,6.28);\r\n            f += a;\r\n            f = abs(mod(f+1., 2.)-1.);\r\n        }    \r\n        f+=1.7-d*(.7+sin(u_t+dot(normalize(v_pos), vec2(1., 0.))*12.)*.02);\r\n        f = max(f, 0.);\r\n        vec3 c = mix( vec3(0.5, 0., 0.), u_color, f);\r\n        c = clamp(c, 0., 1.);\r\n        c = 1.0-vec3(1.0, .8, .6)*3.*(1.0-c);\r\n        gl_FragColor = vec4(c,f);\r\n    }\r\n`;\r\n\r\n// Render program shared between all bombs\r\nexport class RenderBombProgram {\r\n    program: WebGLProgram;\r\n    a_position: GLint;\r\n    u_xy: WebGLUniformLocation;\r\n    u_color: WebGLUniformLocation;\r\n    u_scale: WebGLUniformLocation;\r\n    u_angle: WebGLUniformLocation;\r\n    u_t: WebGLUniformLocation;\r\n\r\n    vertices_buffer: WebGLBuffer;\r\n    indices_buffer: WebGLBuffer;\r\n\r\n    constructor() {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        const vs = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vs, kVS);\r\n        gl.compileShader(vs);\r\n\r\n        const fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fs, kFS);\r\n        gl.compileShader(fs);\r\n\r\n        this.program = gl.createProgram();\r\n        gl.attachShader(this.program, vs);\r\n        gl.attachShader(this.program, fs);\r\n        gl.linkProgram(this.program);\r\n        gl.useProgram(this.program);\r\n\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.u_xy = gl.getUniformLocation(this.program, \"u_xy\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        this.u_scale = gl.getUniformLocation(this.program, \"u_scale\");\r\n        this.u_angle = gl.getUniformLocation(this.program, \"u_angle\");\r\n        this.u_t = gl.getUniformLocation(this.program, \"u_t\");\r\n\r\n        this.vertices_buffer = gl.createBuffer();\r\n        this.indices_buffer = gl.createBuffer();\r\n\r\n        let vertex_data: StaticArray<f32> = new StaticArray<f32>(8);\r\n        vertex_data[0] = 0.0;\r\n        vertex_data[1] = -1.0;\r\n        vertex_data[2] = 1.0;\r\n        vertex_data[3] = 0.0;\r\n        vertex_data[4] = 0.0;\r\n        vertex_data[5] = 1.0;\r\n        vertex_data[6] = -1.0;\r\n        vertex_data[7] = 0.0;\r\n\r\n        let index_data: StaticArray<u8> = new StaticArray<u8>(6);\r\n        index_data[0] = 0;\r\n        index_data[1] = 3;\r\n        index_data[2] = 1;\r\n        index_data[3] = 1;\r\n        index_data[4] = 3;\r\n        index_data[5] = 2;\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n        gl.bufferData<f32>(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices_buffer);\r\n        gl.bufferData<u8>(gl.ELEMENT_ARRAY_BUFFER, index_data, gl.STATIC_DRAW);\r\n    }\r\n\r\n    public DrawBomb(\r\n        color: RenderColor,\r\n        x: f32, y: f32,\r\n        scale: f32, angle: f32,\r\n        t: u64): void {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        gl.useProgram(this.program);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices_buffer);\r\n\r\n        gl.enableVertexAttribArray(this.a_position);\r\n\r\n        // attribute | dimensions | data type | normalize | stride bytes | offset bytes\r\n        gl.vertexAttribPointer(this.a_position, 2, gl.FLOAT, +false, 8, 0);\r\n\r\n        gl.uniform3f(this.u_color, color.r, color.g, color.b);\r\n        gl.uniform2f(this.u_xy, x, y);\r\n        gl.uniform1f(this.u_scale, scale);\r\n        gl.uniform1f(this.u_angle, angle);\r\n        gl.uniform1f(this.u_t, f32(t/40 % 1000000) * 0.01);\r\n\r\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);\r\n    }\r\n}\r\n","import { RenderContext } from \"./RenderContext\";\r\nimport { WebGLProgram, WebGLUniformLocation, WebGLBuffer, GLint } from \"./WebGL\";\r\nimport { consoleLog } from \"../../netcode/netcode\";\r\nimport { RenderColor } from \"./RenderCommon\";\r\n\r\nconst kVS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    attribute vec2 a_position;\r\n    uniform vec2 u_xy;\r\n    uniform float u_scale;\r\n    uniform float u_angle;\r\n\r\n    // Output to fragment shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        vec2 p = a_position;\r\n        v_pos = p;\r\n        p = vec2(-p.x * sin(u_angle) + p.y * cos(u_angle), p.x * cos(u_angle) + p.y * sin(u_angle));\r\n        p = p * u_scale + u_xy;\r\n        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);\r\n    }\r\n`;\r\n\r\nconst kFS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    uniform vec3 u_color;\r\n    uniform float u_t;\r\n\r\n    // Input from vertex shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        // Radius of circle is always 1, so dist2 = 1 on the border\r\n        float x = 1.0 - abs(v_pos.x);\r\n        float y = 1.0 - abs(v_pos.y);\r\n        float alpha = clamp((x * x + y * y) * 0.5, 0.0, 1.0);\r\n        float gamma = 1.0 - (v_pos.x * v_pos.x + v_pos.y * v_pos.y);\r\n\r\n        float t = (sin(u_t) + 1.0) * 0.5;\r\n\r\n        float beta = pow(alpha, 3.0 + cos(u_t * 2.0) * 0.5);\r\n\r\n        vec3 flare_color = mix(u_color, vec3(0.0, 0.0, 0.0), beta);\r\n\r\n        vec3 color;\r\n        if (alpha > 0.90) {\r\n            color = u_color;\r\n        } else {\r\n            color = flare_color;\r\n        }\r\n\r\n        gl_FragColor = vec4(color, beta*gamma);\r\n    }\r\n`;\r\n\r\n// Render program shared between all bombs\r\nexport class RenderBulletProgram {\r\n    program: WebGLProgram;\r\n    a_position: GLint;\r\n    u_xy: WebGLUniformLocation;\r\n    u_color: WebGLUniformLocation;\r\n    u_scale: WebGLUniformLocation;\r\n    u_angle: WebGLUniformLocation;\r\n    u_t: WebGLUniformLocation;\r\n\r\n    vertices_buffer: WebGLBuffer;\r\n    indices_buffer: WebGLBuffer;\r\n\r\n    constructor() {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        const vs = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vs, kVS);\r\n        gl.compileShader(vs);\r\n\r\n        const fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fs, kFS);\r\n        gl.compileShader(fs);\r\n\r\n        this.program = gl.createProgram();\r\n        gl.attachShader(this.program, vs);\r\n        gl.attachShader(this.program, fs);\r\n        gl.linkProgram(this.program);\r\n        gl.useProgram(this.program);\r\n\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.u_xy = gl.getUniformLocation(this.program, \"u_xy\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        this.u_scale = gl.getUniformLocation(this.program, \"u_scale\");\r\n        this.u_angle = gl.getUniformLocation(this.program, \"u_angle\");\r\n        this.u_t = gl.getUniformLocation(this.program, \"u_t\");\r\n\r\n        this.vertices_buffer = gl.createBuffer();\r\n        this.indices_buffer = gl.createBuffer();\r\n\r\n        let vertex_data: StaticArray<f32> = new StaticArray<f32>(8);\r\n        vertex_data[0] = 0.0;\r\n        vertex_data[1] = -1.0;\r\n        vertex_data[2] = 1.0;\r\n        vertex_data[3] = 0.0;\r\n        vertex_data[4] = 0.0;\r\n        vertex_data[5] = 1.0;\r\n        vertex_data[6] = -1.0;\r\n        vertex_data[7] = 0.0;\r\n\r\n        let index_data: StaticArray<u8> = new StaticArray<u8>(6);\r\n        index_data[0] = 0;\r\n        index_data[1] = 3;\r\n        index_data[2] = 1;\r\n        index_data[3] = 1;\r\n        index_data[4] = 3;\r\n        index_data[5] = 2;\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n        gl.bufferData<f32>(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices_buffer);\r\n        gl.bufferData<u8>(gl.ELEMENT_ARRAY_BUFFER, index_data, gl.STATIC_DRAW);\r\n    }\r\n\r\n    public DrawBullet(\r\n        color: RenderColor,\r\n        x: f32, y: f32,\r\n        scale: f32, angle: f32,\r\n        t: u64): void {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        gl.useProgram(this.program);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices_buffer);\r\n\r\n        gl.enableVertexAttribArray(this.a_position);\r\n\r\n        // attribute | dimensions | data type | normalize | stride bytes | offset bytes\r\n        gl.vertexAttribPointer(this.a_position, 2, gl.FLOAT, +false, 8, 0);\r\n\r\n        gl.uniform3f(this.u_color, color.r, color.g, color.b);\r\n        gl.uniform2f(this.u_xy, x, y);\r\n        gl.uniform1f(this.u_scale, scale);\r\n        gl.uniform1f(this.u_angle, angle);\r\n        gl.uniform1f(this.u_t, f32((t + 333333)/4 % 1024) * 3.0 * Mathf.PI / 1024.0);\r\n\r\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);\r\n    }\r\n}\r\n","import { RenderContext } from \"./RenderContext\";\r\nimport { ImageData, WebGLProgram, WebGLUniformLocation, WebGLBuffer, GLint, WebGLTexture } from \"./WebGL\";\r\nimport { JSON } from \"assemblyscript-json\";\r\nimport { consoleLog } from \"../../netcode/netcode\";\r\n\r\nconst kVertexShaderCode: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    attribute vec2 a_position;\r\n    uniform vec2 u_xy;\r\n    uniform float u_scale;\r\n\r\n    // Output to fragment shader:\r\n    varying vec2 v_coord;\r\n\r\n    void main() {\r\n        vec2 p = a_position;\r\n        v_coord = p * u_scale + u_xy;\r\n        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);\r\n    }\r\n`;\r\n\r\nconst kFragmentShaderCode: string = `\r\n    precision highp float;\r\n\r\n    // Input from vertex shader:\r\n    varying vec2 v_coord;\r\n\r\n    uniform float u_t;\r\n\r\n    const float cloudscale = 0.8;\r\n    const float speed = 0.03;\r\n    const float clouddark = 0.5;\r\n    const float cloudlight = 0.3;\r\n    const float cloudcover = 0.2;\r\n    const float cloudalpha = 8.0;\r\n    const float skytint = 0.5;\r\n    const vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\r\n    const vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\r\n\r\n    const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\r\n\r\n    vec2 hash( vec2 p ) {\r\n        p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\r\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\r\n    }\r\n\r\n    float noise( in vec2 p ) {\r\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\r\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\r\n        vec2 i = floor(p + (p.x+p.y)*K1);\t\r\n        vec2 a = p - i + (i.x+i.y)*K2;\r\n        vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\r\n        vec2 b = a - o + K2;\r\n        vec2 c = a - 1.0 + 2.0*K2;\r\n        vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\r\n        vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\r\n        return dot(n, vec3(70.0));\t\r\n    }\r\n\r\n    float fbm(vec2 n) {\r\n        float total = 0.0, amplitude = 0.1;\r\n        for (int i = 0; i < 7; i++) {\r\n            total += noise(n) * amplitude;\r\n            n = m * n;\r\n            amplitude *= 0.4;\r\n        }\r\n        return total;\r\n    }\r\n\r\n    void main() {\r\n        vec2 p = v_coord.xy;\r\n        vec2 uv = p;\r\n        float time = u_t * speed * 100.0;\r\n        float q = fbm(uv * cloudscale * 0.5);\r\n        \r\n        //ridged noise shape\r\n        float r = 0.0;\r\n        uv *= cloudscale;\r\n        uv -= q - time;\r\n        float weight = 0.8;\r\n        for (int i=0; i<8; i++){\r\n            r += abs(weight*noise( uv ));\r\n            uv = m*uv + time;\r\n            weight *= 0.7;\r\n        }\r\n        \r\n        //noise shape\r\n        float f = 0.0;\r\n        uv = p;\r\n        uv *= cloudscale;\r\n        uv -= q - time;\r\n        weight = 0.7;\r\n        for (int i=0; i<8; i++){\r\n            f += weight*noise( uv );\r\n            uv = m*uv + time;\r\n            weight *= 0.6;\r\n        }\r\n        \r\n        f *= r + f;\r\n        \r\n        //noise colour\r\n        float c = 0.0;\r\n        time = u_t * speed * 2.0;\r\n        uv = p;\r\n        uv *= cloudscale*2.0;\r\n        uv -= q - time;\r\n        weight = 0.4;\r\n        for (int i=0; i<7; i++){\r\n            c += weight*noise( uv );\r\n            uv = m*uv + time;\r\n            weight *= 0.6;\r\n        }\r\n\r\n        //noise ridge colour\r\n        float c1 = 0.0;\r\n        time = u_t * speed * 3.0;\r\n        uv = p;\r\n        uv *= cloudscale*3.0;\r\n        uv -= q - time;\r\n        weight = 0.4;\r\n        for (int i=0; i<7; i++){\r\n            c1 += abs(weight*noise( uv ));\r\n            uv = m*uv + time;\r\n            weight *= 0.6;\r\n        }\r\n        \r\n        c += c1;\r\n        \r\n        vec3 skycolour = skycolour2;\r\n        vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\r\n       \r\n        f = cloudcover + cloudalpha*f*r;\r\n        \r\n        vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\r\n\r\n        gl_FragColor = vec4( result, 1.0 );\r\n    }\r\n`;\r\n\r\nexport class RenderMapProgram {\r\n    shader_program: WebGLProgram;\r\n\r\n    // Vertex shader attributes/uniforms:\r\n    a_position: GLint;\r\n    u_xy: WebGLUniformLocation;\r\n    u_scale: WebGLUniformLocation;\r\n    u_t: WebGLUniformLocation;\r\n\r\n    vertices_buffer: WebGLBuffer;\r\n    indices_buffer: WebGLBuffer;\r\n\r\n    constructor() {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        gl.getExtension('OES_standard_derivatives');\r\n        gl.getExtension('OES_texture_float_linear');\r\n        //gl.getExtension('OES_texture_border_clamp');\r\n\r\n        const vertex_shader = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vertex_shader, kVertexShaderCode);\r\n        gl.compileShader(vertex_shader);\r\n\r\n        const fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fragment_shader, kFragmentShaderCode);\r\n        gl.compileShader(fragment_shader);\r\n\r\n        this.shader_program = gl.createProgram();\r\n        gl.attachShader(this.shader_program, vertex_shader);\r\n        gl.attachShader(this.shader_program, fragment_shader);\r\n        gl.linkProgram(this.shader_program);\r\n        gl.useProgram(this.shader_program);\r\n\r\n        this.a_position = gl.getAttribLocation(this.shader_program, \"a_position\");\r\n\r\n        this.u_xy = gl.getUniformLocation(this.shader_program, \"u_xy\");\r\n        this.u_scale = gl.getUniformLocation(this.shader_program, \"u_scale\");\r\n        this.u_t = gl.getUniformLocation(this.shader_program, \"u_t\");\r\n\r\n        this.vertices_buffer = gl.createBuffer();\r\n        this.indices_buffer = gl.createBuffer();\r\n\r\n        let vertex_data: StaticArray<f32> = new StaticArray<f32>(8);\r\n        vertex_data[0] = -1.0;\r\n        vertex_data[1] = -1.0;\r\n        vertex_data[2] = 1.0;\r\n        vertex_data[3] = -1.0;\r\n        vertex_data[4] = 1.0;\r\n        vertex_data[5] = 1.0;\r\n        vertex_data[6] = -1.0;\r\n        vertex_data[7] = 1.0;\r\n\r\n        let index_data: StaticArray<u8> = new StaticArray<u8>(6);\r\n        index_data[0] = 0;\r\n        index_data[1] = 1;\r\n        index_data[2] = 3;\r\n        index_data[3] = 1;\r\n        index_data[4] = 2;\r\n        index_data[5] = 3;\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n        gl.bufferData<f32>(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices_buffer);\r\n        gl.bufferData<u8>(gl.ELEMENT_ARRAY_BUFFER, index_data, gl.STATIC_DRAW);\r\n    }\r\n\r\n    public DrawMap(\r\n        x: f32, y: f32,\r\n        scale: f32,\r\n        t: u64): void {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        gl.useProgram(this.shader_program);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices_buffer);\r\n\r\n        gl.enableVertexAttribArray(this.a_position);\r\n\r\n        // attribute | dimensions | data type | normalize | stride bytes | offset bytes\r\n        gl.vertexAttribPointer(this.a_position, 2, gl.FLOAT, +false, 8, 0);\r\n\r\n        gl.uniform2f(this.u_xy, x, y);\r\n        gl.uniform1f(this.u_scale, scale);\r\n        gl.uniform1f(this.u_t, f32(t % 1000000) / 1000000.0);\r\n\r\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);\r\n     }\r\n}\r\n","import { RenderContext } from \"./RenderContext\";\r\nimport { WebGLProgram, WebGLUniformLocation, WebGLBuffer, GLint } from \"./WebGL\";\r\nimport { consoleLog } from \"../../netcode/netcode\";\r\nimport { RenderColor } from \"./RenderCommon\";\r\n\r\nconst kVS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    attribute vec2 a_position;\r\n    uniform vec2 u_xy;\r\n    uniform float u_scale;\r\n    uniform float u_angle;\r\n\r\n    // Output to fragment shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        vec2 p = a_position;\r\n        v_pos = p;\r\n        p = vec2(-p.x * sin(u_angle) + p.y * cos(u_angle), p.x * cos(u_angle) + p.y * sin(u_angle));\r\n        p = p * u_scale + u_xy;\r\n        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);\r\n    }\r\n`;\r\n\r\nconst kFS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    uniform vec3 u_color;\r\n    uniform float u_t;\r\n\r\n    // Input from vertex shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        float alpha = (sin(u_t - v_pos.y) + 1.0) * 0.5;\r\n        vec3 color = mix(u_color, vec3(1.0,1.0,1.0), alpha);\r\n\r\n        gl_FragColor = vec4(color, 1.0);\r\n    }\r\n`;\r\n\r\nexport class RenderArrowProgram {\r\n    program: WebGLProgram;\r\n    a_position: GLint;\r\n    u_xy: WebGLUniformLocation;\r\n    u_color: WebGLUniformLocation;\r\n    u_scale: WebGLUniformLocation;\r\n    u_angle: WebGLUniformLocation;\r\n    u_t: WebGLUniformLocation;\r\n\r\n    vertices_buffer: WebGLBuffer;\r\n\r\n    constructor() {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        const vs = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vs, kVS);\r\n        gl.compileShader(vs);\r\n\r\n        const fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fs, kFS);\r\n        gl.compileShader(fs);\r\n\r\n        this.program = gl.createProgram();\r\n        gl.attachShader(this.program, vs);\r\n        gl.attachShader(this.program, fs);\r\n        gl.linkProgram(this.program);\r\n        gl.useProgram(this.program);\r\n\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.u_xy = gl.getUniformLocation(this.program, \"u_xy\");\r\n        this.u_color = gl.getUniformLocation(this.program, \"u_color\");\r\n        this.u_scale = gl.getUniformLocation(this.program, \"u_scale\");\r\n        this.u_angle = gl.getUniformLocation(this.program, \"u_angle\");\r\n        this.u_t = gl.getUniformLocation(this.program, \"u_t\");\r\n\r\n        this.vertices_buffer = gl.createBuffer();\r\n\r\n        let vertex_data: StaticArray<f32> = new StaticArray<f32>(6);\r\n        vertex_data[0] = -1.0;\r\n        vertex_data[1] = -1.0;\r\n        vertex_data[2] = 1.0;\r\n        vertex_data[3] = -1.0;\r\n        vertex_data[4] = 0.0;\r\n        vertex_data[5] = 1.0;\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n        gl.bufferData<f32>(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);\r\n    }\r\n\r\n    public DrawArrow(\r\n        color: RenderColor,\r\n        x: f32, y: f32,\r\n        scale: f32, angle: f32,\r\n        t: u64): void {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        gl.useProgram(this.program);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n\r\n        gl.enableVertexAttribArray(this.a_position);\r\n\r\n        // attribute | dimensions | data type | normalize | stride bytes | offset bytes\r\n        gl.vertexAttribPointer(this.a_position, 2, gl.FLOAT, +false, 8, 0);\r\n\r\n        gl.uniform3f(this.u_color, color.r, color.g, color.b);\r\n        gl.uniform2f(this.u_xy, x, y);\r\n        gl.uniform1f(this.u_scale, scale);\r\n        gl.uniform1f(this.u_angle, angle);\r\n        gl.uniform1f(this.u_t, f32((t + 235235)/4 % 1024) * 2.1 * Mathf.PI / 1024.0);\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, 3);\r\n    }\r\n}\r\n","import { RenderContext } from \"./RenderContext\";\r\nimport { WebGLProgram, WebGLUniformLocation, WebGLBuffer, GLint } from \"./WebGL\";\r\nimport { consoleLog } from \"../../netcode/netcode\";\r\n\r\nconst kVS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    attribute vec2 a_position;\r\n    uniform vec2 u_xy;\r\n    uniform float u_scale;\r\n\r\n    // Output to fragment shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        vec2 p = a_position;\r\n        v_pos = p * 4.0;\r\n        p = p * u_scale + u_xy;\r\n        gl_Position = vec4(p.x, -p.y, 0.0, 1.0);\r\n    }\r\n`;\r\n\r\nconst kFS: string = `\r\n    precision highp float;\r\n\r\n    // Input from application:\r\n    uniform float u_t;\r\n\r\n    // Input from vertex shader:\r\n    varying vec2 v_pos;\r\n\r\n    void main() {\r\n        float d = length(v_pos);\r\n        float f = 0.;\r\n        float phase = u_t;\r\n        float dir = 1.;\r\n        float a = 0.;\r\n        float len = -d*(cos(u_t)*.2+.2);\r\n        for(float i = 0.; i<8.0; i+=1.){\r\n            float p = phase +(sin(i+u_t)-1.)*.05+len;\r\n            a = dot(normalize(v_pos), normalize(vec2(cos((p)*dir), sin((p)*dir))));\r\n            a = max(0., a);\r\n            a = pow(a, 10.);\r\n            dir*=-1.;\r\n            phase+=mod(i,6.28);\r\n            f += a;\r\n            f = abs(mod(f+1., 2.)-1.);\r\n        }    \r\n        f+=1.7-d*(.7+sin(u_t+dot(normalize(v_pos), vec2(1., 0.))*12.)*.02);\r\n        f = max(f, 0.);\r\n        vec3 c = mix( vec3(0.5, 0., 0.), vec3(1., .9, .6), f);\r\n        c = clamp(c, 0., 1.);\r\n        c = 1.0-vec3(.6, .4, .3)*3.*(1.0-c);\r\n        gl_FragColor = vec4(c,f);\r\n    }\r\n`;\r\n\r\nexport class RenderSunProgram {\r\n    program: WebGLProgram;\r\n    a_position: GLint;\r\n    u_xy: WebGLUniformLocation;\r\n    u_scale: WebGLUniformLocation;\r\n    u_t: WebGLUniformLocation;\r\n\r\n    vertices_buffer: WebGLBuffer;\r\n    indices_buffer: WebGLBuffer;\r\n\r\n    constructor() {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        const vs = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vs, kVS);\r\n        gl.compileShader(vs);\r\n\r\n        const fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fs, kFS);\r\n        gl.compileShader(fs);\r\n\r\n        this.program = gl.createProgram();\r\n        gl.attachShader(this.program, vs);\r\n        gl.attachShader(this.program, fs);\r\n        gl.linkProgram(this.program);\r\n        gl.useProgram(this.program);\r\n\r\n        this.a_position = gl.getAttribLocation(this.program, \"a_position\");\r\n        this.u_xy = gl.getUniformLocation(this.program, \"u_xy\");\r\n        this.u_scale = gl.getUniformLocation(this.program, \"u_scale\");\r\n        this.u_t = gl.getUniformLocation(this.program, \"u_t\");\r\n\r\n        this.vertices_buffer = gl.createBuffer();\r\n        this.indices_buffer = gl.createBuffer();\r\n\r\n        let vertex_data: StaticArray<f32> = new StaticArray<f32>(8);\r\n        vertex_data[0] = -1.0;\r\n        vertex_data[1] = -1.0;\r\n        vertex_data[2] = 1.0;\r\n        vertex_data[3] = -1.0;\r\n        vertex_data[4] = 1.0;\r\n        vertex_data[5] = 1.0;\r\n        vertex_data[6] = -1.0;\r\n        vertex_data[7] = 1.0;\r\n\r\n        let index_data: StaticArray<u8> = new StaticArray<u8>(6);\r\n        index_data[0] = 0;\r\n        index_data[1] = 2;\r\n        index_data[2] = 1;\r\n        index_data[3] = 0;\r\n        index_data[4] = 3;\r\n        index_data[5] = 2;\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n        gl.bufferData<f32>(gl.ARRAY_BUFFER, vertex_data, gl.STATIC_DRAW);\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices_buffer);\r\n        gl.bufferData<u8>(gl.ELEMENT_ARRAY_BUFFER, index_data, gl.STATIC_DRAW);\r\n    }\r\n\r\n    public DrawSun(\r\n        x: f32, y: f32,\r\n        scale: f32,\r\n        t: u64): void {\r\n        const gl = RenderContext.I.gl;\r\n\r\n        gl.useProgram(this.program);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertices_buffer);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indices_buffer);\r\n\r\n        gl.enableVertexAttribArray(this.a_position);\r\n\r\n        // attribute | dimensions | data type | normalize | stride bytes | offset bytes\r\n        gl.vertexAttribPointer(this.a_position, 2, gl.FLOAT, +false, 8, 0);\r\n\r\n        gl.uniform2f(this.u_xy, x, y);\r\n        gl.uniform1f(this.u_scale, scale);\r\n        gl.uniform1f(this.u_t, f32(t/40 % 1000000) * 0.001);\r\n\r\n        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);\r\n    }\r\n}\r\n","//------------------------------------------------------------------------------\r\n// Imports\r\n\r\nimport { RenderContext } from \"./gl/RenderContext\";\r\nimport { RenderTextData, RenderTextProgram, RenderTextHorizontal, RenderTextVertical } from \"./gl/RenderText\";\r\nimport { Box3 } from \"../node_modules/as-3d-math/src/as/index\";\r\nimport { Netcode, consoleLog, getMilliseconds } from \"../netcode/netcode\";\r\nimport { RenderPlayerProgram, RenderPlayerData } from \"./gl/RenderPlayer\";\r\nimport { RenderStringProgram } from \"./gl/RenderString\";\r\nimport { RenderBombProgram } from \"./gl/RenderBomb\";\r\nimport { RenderBulletProgram } from \"./gl/RenderBullet\";\r\nimport { RenderMapProgram } from \"./gl/RenderMap\";\r\nimport { RenderArrowProgram } from \"./gl/RenderArrow\";\r\nimport { RenderSunProgram } from \"./gl/RenderSun\";\r\nimport { RenderColor } from \"./gl/RenderCommon\";\r\n\r\ndeclare function sendReliable(buffer: Uint8Array): void;\r\ndeclare function sendUnreliable(buffer: Uint8Array): void;\r\ndeclare function playSFX(name: string): void;\r\ndeclare function playMusic(name: string): void;\r\ndeclare function serverLoginGood(): void;\r\ndeclare function serverLoginBad(reason: string): void;\r\n\r\nexport const UINT8ARRAY_ID = idof<Uint8Array>();\r\n\r\nlet TimeSync: Netcode.TimeSync = new Netcode.TimeSync();\r\nlet MessageCombiner: Netcode.MessageCombiner = new Netcode.MessageCombiner();\r\nlet TimeConverter: Netcode.TimeConverter;\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Constants\r\n\r\nconst kTeamColors = [\r\n    new RenderColor(0.8, 0.4, 0.2), // red\r\n    new RenderColor(0.2, 1.0, 0.2), // green\r\n    new RenderColor(0.2, 0.4, 0.8), // blue\r\n    new RenderColor(0.8, 0.3, 0.8), // purple\r\n    new RenderColor(0.8, 0.8, 0.5)  // pink\r\n];\r\n\r\nconst kTeamTextColors = [\r\n    new RenderColor(1.0, 0.4, 0.2), // red\r\n    new RenderColor(0.6, 1.0, 0.6), // green\r\n    new RenderColor(0.2, 0.4, 1.0), // blue\r\n    new RenderColor(1.0, 0.3, 1.0), // purple\r\n    new RenderColor(1.0, 1.0, 0.5)  // pink\r\n];\r\n\r\nconst kTextStrokeColor = new RenderColor(0.0, 0.0, 0.0);\r\n\r\nconst kStringColor = new RenderColor(1.0, 1.0, 1.0);\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Tools\r\n\r\nfunction clamp(x: f32, maxval: f32, minval: f32): f32 {\r\n    return max(maxval, min(minval, x));\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Player\r\n\r\nlet SelfId: i32 = -1;\r\n\r\nclass PositionMessage {\r\n    valid: bool = false;\r\n\r\n    t: u64;\r\n\r\n    x: u16;\r\n    y: u16;\r\n    size: u8;\r\n    vx: i8;\r\n    vy: i8;\r\n    not_moving: u8;\r\n    accel_angle: u8;\r\n\r\n    constructor() {\r\n    }\r\n};\r\n\r\nclass Player {\r\n    id: u8 = 0;\r\n    score: u16 = 0;\r\n    wins: u32 = 0;\r\n    losses: u32 = 0;\r\n    skin: u8 = 0;\r\n    team: u8 = 0;\r\n    name: string = \"\";\r\n\r\n    is_self: bool = false;\r\n\r\n    size: u8 = 0;\r\n\r\n    x: f32 = 0.0;\r\n    y: f32 = 0.0;\r\n    vx: f32 = 0.0;\r\n    vy: f32 = 0.0;\r\n    ax: f32 = 0.0;\r\n    ay: f32 = 0.0;\r\n\r\n    server_x: f32 = 0.0;\r\n    server_y: f32 = 0.0;\r\n    server_vx: f32 = 0.0;\r\n    server_vy: f32 = 0.0;\r\n\r\n    temp_screen_x: f32 = 0;\r\n    temp_screen_y: f32 = 0;\r\n    on_screen: bool = false;\r\n\r\n    LastPositionMessage: PositionMessage = new PositionMessage();\r\n\r\n    name_data: RenderTextData | null = null;\r\n\r\n    constructor() {\r\n    }\r\n};\r\n\r\nlet player_map = new Map<u8, Player>();\r\nlet player_list: Player[]; // temp\r\nlet temp_self: Player | null;\r\n\r\nfunction OnPlayerKilled(killer: Player, killee: Player): void {\r\n\r\n}\r\n\r\nfunction OnChat(player: Player, m: string): void {\r\n    consoleLog(\"Chat: \" + m.toString());\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Music\r\n\r\nlet last_music_change: u64 = 0;\r\nlet active_music: string = \"chill\";\r\nlet next_music: string = \"\";\r\nlet next_music_ts: u64 = 0;\r\n\r\nfunction UpdateMusic(t: u64, sx: f32, sy: f32): void {\r\n    if (temp_self == null) {\r\n        return;\r\n    }\r\n\r\n    // Do not change music faster than 10 seconds.\r\n    const dt: i64 = i64(t - last_music_change);\r\n    if (dt < 10_000 * 4) {\r\n        return;\r\n    }\r\n\r\n    let enemy_near: bool = false;\r\n    let highest_size: i32 = 0;\r\n\r\n    const players_count = player_list.length;\r\n    for (let i: i32 = 0; i < players_count; ++i) {\r\n        const player = player_list[i];\r\n\r\n        if (player.team == temp_self!.team) {\r\n            continue;\r\n        }\r\n\r\n        // Wide radius around screen\r\n        if (IsObjectOnScreen(player.temp_screen_x, player.temp_screen_y, 0.5)) {\r\n            enemy_near = true;\r\n            if (highest_size < i32(player.size)) {\r\n                highest_size = i32(player.size);\r\n            }\r\n        }\r\n    }\r\n\r\n    let music: string = \"chill\";\r\n\r\n    if (enemy_near) {\r\n        const diff: i32 = i32(temp_self!.size) - highest_size;\r\n        if (diff > 3) {\r\n            music = \"fight2\";\r\n        } else {\r\n            music = \"fight1\";\r\n        }\r\n    }\r\n\r\n    // Require new music to be consistent for at least 5 seconds before changing.\r\n    if (next_music != music) {\r\n        next_music_ts = t;\r\n        next_music = music;\r\n        return;\r\n    }\r\n\r\n    const next_dt: i64 = i64(t - next_music_ts);\r\n    if (next_dt < 5_000 * 4) {\r\n        return;\r\n    }\r\n\r\n    if (active_music != next_music) {\r\n        active_music = next_music;\r\n        last_music_change = t;\r\n        playMusic(active_music);\r\n        next_music = \"\";\r\n    }\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Connection\r\n\r\nexport function OnConnectionOpen(now_msec: f64): void {\r\n    consoleLog(\"UDP link up\");\r\n\r\n    TimeConverter = new Netcode.TimeConverter(now_msec);\r\n\r\n    player_map.clear();\r\n    SelfId = -1;\r\n    TimeSync = new Netcode.TimeSync();\r\n\r\n    SendTimeSync();\r\n\r\n    let chat = Netcode.MakeChatRequest(\"Hello World\");\r\n    if (chat != null) {\r\n        sendReliable(chat);\r\n    }\r\n}\r\n\r\nexport function OnReliableSendTimer(): void {\r\n    let buffer : Uint8Array | null = MessageCombiner.PopNextDatagram();\r\n    if (buffer == null) {\r\n        return;\r\n    }\r\n\r\n    sendReliable(buffer);\r\n}\r\n\r\nexport function OnConnectionClose(): void {\r\n    consoleLog(\"UDP link down\");\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Message Deserializers\r\n\r\nexport function OnConnectionUnreliableData(recv_msec: f64, buffer: Uint8Array): void {\r\n    if (buffer.length < 1) {\r\n        // Ignore short messages\r\n        return;\r\n    }\r\n\r\n    // Convert timestamp to integer with 1/4 msec (desired) precision\r\n    let t: u64 = TimeConverter.MsecToTime(recv_msec);\r\n\r\n    let offset: i32 = 0;\r\n    while (offset < buffer.length) {\r\n        let ptr: usize = buffer.dataStart + offset;\r\n        const remaining: i32 = buffer.length - offset;\r\n        const type: u8 = load<u8>(ptr, 0);\r\n\r\n        if (type == Netcode.UnreliableType.TimeSync && remaining >= 14) {\r\n            let remote_send_ts: u32 = Netcode.Load24(ptr, 1);\r\n            let min_trip_send_ts24_trunc: u32 = Netcode.Load24(ptr, 4);\r\n            let min_trip_recv_ts24_trunc: u32 = Netcode.Load24(ptr, 7);\r\n            let slope: f32 = load<f32>(ptr, 10);\r\n\r\n            TimeSync.OnPeerSync(t, remote_send_ts, min_trip_send_ts24_trunc, min_trip_recv_ts24_trunc, slope);\r\n\r\n            //sendUnreliable(Netcode.MakeTimeSyncPong(remote_send_ts, TimeSync.LocalToPeerTime_ToTS23(t)));\r\n\r\n            offset += 14;\r\n        } else if (type == Netcode.UnreliableType.TimeSyncPong && remaining >= 7) {\r\n            let ping_ts: u32 = Netcode.Load24(ptr, 1);\r\n            let pong_ts: u32 = Netcode.Load24(ptr, 4);\r\n\r\n            let ping: u64 = TimeSync.ExpandLocalTime_FromTS23(t, ping_ts);\r\n            let pong: u64 = TimeSync.ExpandLocalTime_FromTS23(t, pong_ts);\r\n\r\n            if (pong < ping || t + 1 < pong) {\r\n                consoleLog(\"*** TEST FAILED!\");\r\n                consoleLog(\"Ping T = \" + ping.toString());\r\n                consoleLog(\"Pong T = \" + pong.toString());\r\n                consoleLog(\"Recv T = \" + t.toString());\r\n                TimeSync.DumpState();\r\n            }\r\n\r\n            offset += 7;\r\n        } else if (type == Netcode.UnreliableType.ServerPosition && remaining >= 6) {\r\n            let server_ts: u32 = Netcode.Load24(ptr, 1);\r\n            let update_t = TimeSync.PeerToLocalTime_FromTS23(server_ts);\r\n\r\n            let dt: i32 = i32(t - update_t);\r\n            if (dt < 0) {\r\n                update_t = t;\r\n            }\r\n\r\n            const bytes_per_client: i32 = 19;\r\n            const player_count: i32 = load<u8>(ptr, 4);\r\n            const expected_bytes: i32 = 5 + player_count * bytes_per_client;\r\n\r\n            if (remaining < expected_bytes) {\r\n                consoleLog(\"Truncated server position\");\r\n                break;\r\n            }\r\n\r\n            let pptr: usize = ptr + 5;\r\n\r\n            for (let i: i32 = 0; i < player_count; ++i) {\r\n                const player_id: u8 = load<u8>(pptr, 0);\r\n                if (player_map.has(player_id)) {\r\n                    const player: Player = player_map.get(player_id);\r\n\r\n                    if (player.is_self) {\r\n                        continue;\r\n                    }\r\n\r\n                    player.server_x = Netcode.Convert16toX(load<u16>(pptr, 1));\r\n                    player.server_y = Netcode.Convert16toX(load<u16>(pptr, 3));\r\n                    player.server_vx = Netcode.Convert16toVX(load<i16>(pptr, 5));\r\n                    player.server_vy = Netcode.Convert16toVX(load<i16>(pptr, 7));\r\n\r\n                    const aa: u16 = load<u16>(pptr, 9);\r\n                    let ax: f32 = 0.0, ay: f32 = 0.0;\r\n                    if (aa != 0) {\r\n                        const angle: f32 = (aa - 1) * Netcode.inv_aa_factor;\r\n                        ax = Mathf.cos(angle);\r\n                        ay = Mathf.sin(angle);\r\n                    }\r\n\r\n                    player.ax = ax;\r\n                    player.ay = ay;\r\n\r\n                    const last_shot_x: f32 = Netcode.Convert16toX(load<u16>(pptr, 11));\r\n                    const last_shot_y: f32 = Netcode.Convert16toX(load<u16>(pptr, 13));\r\n                    const last_shot_vx: f32 = Netcode.Convert16toVX(load<i16>(pptr, 15));\r\n                    const last_shot_vy: f32 = Netcode.Convert16toVX(load<i16>(pptr, 17));\r\n                }\r\n\r\n                pptr += bytes_per_client;\r\n            }\r\n\r\n            offset += expected_bytes;\r\n        } else {\r\n            consoleLog(\"Server sent invalid unreliable data\");\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\nexport function OnConnectionReliableData(buffer: Uint8Array): void {\r\n    if (buffer.length < 1) {\r\n        // Ignore short messages\r\n        return;\r\n    }\r\n\r\n    let offset: i32 = 0;\r\n    while (offset < buffer.length) {\r\n        let ptr = buffer.dataStart + offset;\r\n        const remaining: i32 = buffer.length - offset;\r\n        const type: u8 = load<u8>(ptr, 0);\r\n\r\n        if (type == Netcode.ReliableType.SetId && remaining >= 2) {\r\n            SelfId = load<u8>(ptr, 1);\r\n            offset += 2;\r\n        } else if (type == Netcode.ReliableType.ServerLoginGood) {\r\n            serverLoginGood();\r\n            offset++;\r\n        } else if (type == Netcode.ReliableType.ServerLoginBad && remaining >= 3) {\r\n            let len: i32 = load<u16>(ptr, 1);\r\n            if (len + 3 > remaining) {\r\n                consoleLog(\"Truncated loginbad response\");\r\n                return;\r\n            }\r\n\r\n            let s: string = String.UTF8.decodeUnsafe(ptr + 3, len, false);\r\n\r\n            serverLoginBad(s);\r\n\r\n            offset += 3 + len;\r\n        } else if (type == Netcode.ReliableType.SetPlayer && remaining >= 15) {\r\n            let id: u8 = load<u8>(ptr, 1);\r\n            let player: Player | null = null;\r\n            if (player_map.has(id)) {\r\n                player = player_map.get(id);\r\n            } else {\r\n                player = new Player();\r\n                player_map.set(id, player);\r\n                player.id = id;\r\n            }\r\n\r\n            player.score = load<u16>(ptr, 2);\r\n            player.wins = load<u32>(ptr, 4);\r\n            player.losses = load<u32>(ptr, 8);\r\n            player.skin = load<u8>(ptr, 12);\r\n            player.team = load<u8>(ptr, 13);\r\n\r\n            let name_len: u8 = load<u8>(ptr, 14);\r\n            if (15 + name_len > remaining) {\r\n                consoleLog(\"Truncated setplayer\");\r\n                return;\r\n            }\r\n\r\n            player.name = String.UTF8.decodeUnsafe(ptr + 15, name_len, false);\r\n            player.name_data = firacode_font.GenerateLine(player.name);\r\n\r\n            consoleLog(\"SetPlayer: \" + id.toString() + \" = \" + player.name.toString());\r\n\r\n            offset += 15 + name_len;\r\n        } else if (type == Netcode.ReliableType.RemovePlayer && remaining >= 2) {\r\n            let id: u8 = load<u8>(ptr, 1);\r\n\r\n            player_map.delete(id);\r\n\r\n            consoleLog(\"RemovePlayer: \" + id.toString());\r\n\r\n            offset += 2;\r\n        } else if (type == Netcode.ReliableType.PlayerKill && remaining >= 7) {\r\n            let killer_id: u8 = load<u8>(ptr, 1);\r\n            let killee_id: u8 = load<u8>(ptr, 2);\r\n            if (player_map.has(killer_id) && player_map.has(killee_id)) {\r\n                let killer: Player = player_map.get(killer_id);\r\n                let killee: Player = player_map.get(killee_id);\r\n                killer.score = load<u16>(ptr, 3);\r\n                killee.score = load<u16>(ptr, 5);\r\n\r\n                OnPlayerKilled(killer, killee);\r\n            }\r\n            offset += 7;\r\n        } else if (type == Netcode.ReliableType.Chat && remaining >= 5) {\r\n            let id: u8 = load<u8>(ptr, 1);\r\n            let m_len: u16 = load<u16>(ptr, 2);\r\n\r\n            if (4 + m_len > remaining) {\r\n                consoleLog(\"Truncated chat\");\r\n                return;\r\n            }\r\n\r\n            if (player_map.has(id)) {\r\n                let player: Player = player_map.get(id);\r\n                let m: string = String.UTF8.decodeUnsafe(ptr + 4, m_len, false);\r\n\r\n                OnChat(player, m);\r\n            }\r\n\r\n            offset += 4 + m_len;\r\n        } else {\r\n            consoleLog(\"Server sent invalid reliable data\");\r\n            return;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Message Serializers\r\n\r\nexport function SendClientLogin(name: string, password: string): i32 {\r\n    let buffer: Uint8Array | null = Netcode.MakeClientLogin(name, password);\r\n    if (buffer == null) {\r\n        return -1;\r\n    }\r\n    MessageCombiner.Push(buffer);\r\n    return 0;\r\n}\r\n\r\nexport function SendChatRequest(m: string): i32 {\r\n    let buffer: Uint8Array | null = Netcode.MakeChatRequest(m);\r\n    if (buffer == null) {\r\n        return -1;\r\n    }\r\n    MessageCombiner.Push(buffer);\r\n    return 0;\r\n}\r\n\r\nexport function SendTimeSync(): void {\r\n    const send_msec = getMilliseconds();\r\n    sendUnreliable(TimeSync.MakeTimeSync(TimeConverter.MsecToTime(send_msec)));\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Initialization\r\n\r\nlet firacode_font: RenderTextProgram;\r\nlet player_prog: RenderPlayerProgram;\r\nlet string_prog: RenderStringProgram;\r\nlet bomb_prog: RenderBombProgram;\r\nlet bullet_prog: RenderBulletProgram;\r\nlet map_prog: RenderMapProgram;\r\nlet arrow_prog: RenderArrowProgram;\r\nlet sun_prog: RenderSunProgram;\r\n\r\nexport function Initialize(): void {\r\n    new RenderContext();\r\n\r\n    firacode_font = new RenderTextProgram(\"textures/fira_code_sdf.png\");\r\n    player_prog = new RenderPlayerProgram();\r\n    string_prog = new RenderStringProgram();\r\n    bomb_prog = new RenderBombProgram();\r\n    bullet_prog = new RenderBulletProgram();\r\n    map_prog = new RenderMapProgram();\r\n    arrow_prog = new RenderArrowProgram();\r\n    sun_prog = new RenderSunProgram();\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Weaponry\r\n\r\nclass BulletWeapon {\r\n    x: f32 = 0;\r\n    y: f32 = 0;\r\n    vx: f32 = 0;\r\n    vy: f32 = 0;\r\n    team: u8 = 0;\r\n    angle0: f32 = 0;\r\n    t: u64 = 0;\r\n}\r\n\r\nclass BombWeapon {\r\n    x: f32 = 0;\r\n    y: f32 = 0;\r\n    vx: f32 = 0;\r\n    vy: f32 = 0;\r\n    team: u8 = 0;\r\n    angle0: f32 = 0;\r\n    t: u64 = 0;\r\n}\r\n\r\nlet BulletList: Array<BulletWeapon> = new Array<BulletWeapon>();\r\nlet BombList: Array<BombWeapon> = new Array<BombWeapon>();\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Render\r\n\r\n/*\r\n    Screen coordinates are (-1, -1) for upper-left corner and (1, 1) for the\r\n    lower-right corner.\r\n*/\r\n\r\nfunction ObjectToScreen(x: f32, sx: f32): f32 {\r\n    let d = x - sx;\r\n    if (abs(d) > Netcode.kMapWidth * 0.5) {\r\n        if (d > 0.0) {\r\n            d -= Netcode.kMapWidth;\r\n        } else {\r\n            d += Netcode.kMapWidth;\r\n        }\r\n    }\r\n    return d * 0.001;\r\n}\r\n\r\nfunction IsObjectOnScreen(x: f32, y: f32, r: f32 = 0.0): bool {\r\n    r += 1.0;\r\n    return abs(x) <= r && abs(y) <= r;\r\n}\r\n\r\nfunction RenderPlayers(t: u64, sx: f32, sy: f32): void {\r\n    const players_count = player_list.length;\r\n\r\n    if (players_count == 0) {\r\n        return;\r\n    }\r\n\r\n    for (let i: i32 = 0; i < players_count; ++i) {\r\n        const player = player_list[i];\r\n\r\n        const x = ObjectToScreen(player.x, sx);\r\n        const y = ObjectToScreen(player.y, sy);\r\n\r\n        player.temp_screen_x = x;\r\n        player.temp_screen_y = y;\r\n        player.on_screen = IsObjectOnScreen(x, y, 0.04);\r\n\r\n        if (!player.on_screen) {\r\n            continue;\r\n        }\r\n\r\n        let sun_x: f32 = player.x;\r\n        if (sun_x > Netcode.kMapWidth * 0.5) {\r\n            sun_x -= Netcode.kMapWidth;\r\n        }\r\n        let sun_y: f32 = player.y;\r\n        if (sun_y > Netcode.kMapWidth * 0.5) {\r\n            sun_y -= Netcode.kMapWidth;\r\n        }\r\n        const shine_angle: f32 = Mathf.atan2(sun_y, sun_x);\r\n        const shine_max: f32 = 10000.0;\r\n        const shine_dist: f32 = clamp(1.0 - (sun_x * sun_x + sun_y * sun_y) / (shine_max * shine_max), 0.5, 1.0);\r\n\r\n        player_prog.DrawPlayer(\r\n            kTeamColors[player.team],\r\n            x, y, 0.04, shine_angle, shine_dist, t);\r\n\r\n        string_prog.DrawString(kTeamColors[player.team], x, y, x + player.vx * 0.1, y + player.vy * 0.1, t);\r\n    }\r\n\r\n    firacode_font.BeginRender();\r\n\r\n    for (let i: i32 = 0; i < players_count; ++i) {\r\n        const player = player_list[i];\r\n\r\n        if (player.name_data == null || !player.on_screen) {\r\n            continue;\r\n        }\r\n\r\n        firacode_font.SetColor(kTeamTextColors[player.team],  kTextStrokeColor);\r\n\r\n        firacode_font.Render(\r\n            RenderTextHorizontal.Center, RenderTextVertical.Center,\r\n            player.temp_screen_x, player.temp_screen_y + 0.06,\r\n            0.32/player.name_data!.width, player.name_data!);\r\n    }\r\n}\r\n\r\nfunction RenderBullets(t: u64, sx: f32, sy: f32): void {\r\n    const count = BulletList.length;\r\n\r\n    const angle: f32 = f32(t % 100000) / 5000.0;\r\n\r\n    for (let i: i32 = 0; i < count; ++i) {\r\n        const bullet = BulletList[i];\r\n\r\n        const x = ObjectToScreen(bullet.x, sx);\r\n        const y = ObjectToScreen(bullet.y, sy);\r\n\r\n        if (!IsObjectOnScreen(x, y, 0.04)) {\r\n            continue;\r\n        }\r\n\r\n        bullet_prog.DrawBullet(\r\n            kTeamColors[bullet.team],\r\n            x, y, 0.04, bullet.angle0 + angle, t);\r\n    }\r\n}\r\n\r\nfunction RenderBombs(t: u64, sx: f32, sy: f32): void {\r\n    const count = BombList.length;\r\n\r\n    const angle: f32 = f32(t % 100000) / 4000.0;\r\n\r\n    for (let i: i32 = 0; i < count; ++i) {\r\n        const bomb = BombList[i];\r\n\r\n        const x = ObjectToScreen(bomb.x, sx);\r\n        const y = ObjectToScreen(bomb.y, sy);\r\n\r\n        if (!IsObjectOnScreen(x, y, 0.1)) {\r\n            continue;\r\n        }\r\n\r\n        bomb_prog.DrawBomb(\r\n            kTeamColors[bomb.team],\r\n            x, y, 0.1, bomb.angle0 + angle, t);\r\n    }\r\n}\r\n\r\nfunction RenderArrows(t: u64, sx: f32, sy: f32): void {\r\n    const players_count = player_list.length;\r\n\r\n    if (players_count == 0) {\r\n        return;\r\n    }\r\n\r\n    for (let i: i32 = 0; i < players_count; ++i) {\r\n        const player = player_list[i];\r\n\r\n        if (player.on_screen || player.is_self) {\r\n            continue;\r\n        }\r\n\r\n        let x: f32 = ObjectToScreen(player.x, sx);\r\n        let y: f32 = ObjectToScreen(player.y, sy);\r\n        const dist: f32 = Mathf.sqrt(x * x + y * y);\r\n        const scale_min: f32 = 0.01;\r\n        const scale_max: f32 = 0.04;\r\n        const scale: f32 = scale_min + clamp(scale_max - dist * 0.004, 0.0, scale_max - scale_min);\r\n\r\n        const angle: f32 = Mathf.atan2(y, x);\r\n\r\n        if (x > y) {\r\n            if (x > -y) {\r\n                // right\r\n                x = 1.0;\r\n                y = Mathf.tan(angle);\r\n            } else {\r\n                // top\r\n                x = Mathf.tan(angle - Mathf.PI * 0.5);\r\n                y = -1.0;\r\n            }\r\n        } else {\r\n            if (x > -y) {\r\n                // bottom\r\n                x = -Mathf.tan(angle + Mathf.PI * 0.5);\r\n                y = 1.0;\r\n            } else {\r\n                // left\r\n                x = -1.0;\r\n                y = -Mathf.tan(angle);\r\n            }\r\n        }\r\n\r\n        const edge_limit: f32 = 0.04;\r\n        if (x < -1.0 + edge_limit) {\r\n            x = -1.0 + edge_limit;\r\n        } else if (x > 1.0 - edge_limit) {\r\n            x = 1.0 - edge_limit;\r\n        }\r\n        if (y < -1.0 + edge_limit) {\r\n            y = -1.0 + edge_limit;\r\n        } else if (y > 1.0 - edge_limit) {\r\n            y = 1.0 - edge_limit;\r\n        }\r\n\r\n        arrow_prog.DrawArrow(\r\n            kTeamColors[player.team],\r\n            x, y, scale, angle, t);\r\n    }\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Physics\r\n\r\nfunction SimulateServerPlayerStep(player: Player, dt: f32, t: u64): void {\r\n    // TODO: Make slower if ship is larger\r\n\r\n    const mass: f32 = 1.0;\r\n    const inv_mass: f32 = 1.0 / mass;\r\n\r\n    let ax: f32 = player.ax * inv_mass;\r\n    let ay: f32 = player.ay * inv_mass;\r\n\r\n    let vx = player.server_vx + ax * dt;\r\n    let vy = player.server_vy + ay * dt;\r\n\r\n    let norm: f32 = f32(Math.sqrt(vx * vx + vy * vy));\r\n    let mag = norm;\r\n\r\n    if (norm > 0.0) {\r\n        const friction: f32 = 0.001;\r\n        const vf: f32 = friction * inv_mass;\r\n\r\n        if (mag > vf) {\r\n            mag -= vf;\r\n        } else {\r\n            mag = 0.0;\r\n        }\r\n\r\n        const limit: f32 = 1.0;\r\n        if (mag > limit) {\r\n            mag = limit;\r\n        }\r\n\r\n        mag /= norm;\r\n        vx *= mag;\r\n        vy *= mag;\r\n\r\n        player.server_vx = vx;\r\n        player.server_vy = vy;\r\n\r\n        player.server_x += vx * dt;\r\n        player.server_y += vy * dt;\r\n\r\n        if (player.server_x >= Netcode.kMapWidth) {\r\n            player.server_x -= Netcode.kMapWidth;\r\n        } else if (player.server_x < 0.0) {\r\n            player.server_x += Netcode.kMapWidth;\r\n        }\r\n        if (player.server_y >= Netcode.kMapWidth) {\r\n            player.server_y -= Netcode.kMapWidth;\r\n        } else if (player.server_y < 0.0) {\r\n            player.server_y += Netcode.kMapWidth;\r\n        }\r\n    }\r\n}\r\n\r\nfunction SimulateLocalPlayerStep(player: Player, dt: f32, t: u64): void {\r\n    // TODO: Make slower if ship is larger\r\n\r\n    const mass: f32 = 1.0;\r\n    const inv_mass: f32 = 1.0 / mass;\r\n\r\n    let ax: f32 = player.ax * inv_mass;\r\n    let ay: f32 = player.ay * inv_mass;\r\n\r\n    let vx = player.vx + ax * dt;\r\n    let vy = player.vy + ay * dt;\r\n\r\n    let norm: f32 = f32(Math.sqrt(vx * vx + vy * vy));\r\n    let mag = norm;\r\n\r\n    if (norm > 0.0) {\r\n        const friction: f32 = 0.001;\r\n        const vf: f32 = friction * inv_mass;\r\n\r\n        if (mag > vf) {\r\n            mag -= vf;\r\n        } else {\r\n            mag = 0.0;\r\n        }\r\n\r\n        const limit: f32 = 1.0;\r\n        if (mag > limit) {\r\n            mag = limit;\r\n        }\r\n\r\n        mag /= norm;\r\n        vx *= mag;\r\n        vy *= mag;\r\n\r\n        player.vx = vx;\r\n        player.vy = vy;\r\n\r\n        player.x += vx * dt;\r\n        player.y += vy * dt;\r\n\r\n        if (player.x >= Netcode.kMapWidth) {\r\n            player.x -= Netcode.kMapWidth;\r\n        } else if (player.x < 0.0) {\r\n            player.x += Netcode.kMapWidth;\r\n        }\r\n        if (player.y >= Netcode.kMapWidth) {\r\n            player.y -= Netcode.kMapWidth;\r\n        } else if (player.y < 0.0) {\r\n            player.y += Netcode.kMapWidth;\r\n        }\r\n    }\r\n}\r\n\r\nfunction SimulationStep(dt: f32, t: u64): void {\r\n    const players_count = player_list.length;\r\n\r\n    for (let i: i32 = 0; i < players_count; ++i) {\r\n        const player = player_list[i];\r\n\r\n        SimulateLocalPlayerStep(player, dt, t);\r\n\r\n        if (player.is_self) {\r\n            continue;\r\n        }\r\n        SimulateServerPlayerStep(player, dt, t);\r\n\r\n        player.x = player.server_x;\r\n        player.y = player.server_y;\r\n        player.vx = player.server_vx;\r\n        player.vy = player.server_vy;\r\n    }\r\n\r\n    for (let i: i32 = 0; i < BombList.length; ++i) {\r\n        const bomb = BombList[i];\r\n\r\n        bomb.x += bomb.vx * dt;\r\n        bomb.y += bomb.vy * dt;\r\n\r\n        if (bomb.x >= Netcode.kMapWidth) {\r\n            bomb.x -= Netcode.kMapWidth;\r\n        } else if (bomb.x < 0.0) {\r\n            bomb.x += Netcode.kMapWidth;\r\n        }\r\n        if (bomb.y >= Netcode.kMapWidth) {\r\n            bomb.y -= Netcode.kMapWidth;\r\n        } else if (bomb.y < 0.0) {\r\n            bomb.y += Netcode.kMapWidth;\r\n        }\r\n\r\n        if (i32(t - bomb.t) > 10_000 * 4) {\r\n            BombList[i] = BombList[BombList.length - 1];\r\n            BombList.length--;\r\n            --i;\r\n        }\r\n    }\r\n\r\n    for (let i: i32 = 0; i < BulletList.length; ++i) {\r\n        const bullet = BulletList[i];\r\n\r\n        bullet.x += bullet.vx * dt;\r\n        bullet.y += bullet.vy * dt;\r\n\r\n        if (bullet.x >= Netcode.kMapWidth) {\r\n            bullet.x -= Netcode.kMapWidth;\r\n        } else if (bullet.x < 0.0) {\r\n            bullet.x += Netcode.kMapWidth;\r\n        }\r\n        if (bullet.y >= Netcode.kMapWidth) {\r\n            bullet.y -= Netcode.kMapWidth;\r\n        } else if (bullet.y < 0.0) {\r\n            bullet.y += Netcode.kMapWidth;\r\n        }\r\n\r\n        if (i32(t - bullet.t) > 10_000 * 4) {\r\n            BulletList[i] = BulletList[BulletList.length - 1];\r\n            BulletList.length--;\r\n            --i;\r\n        }\r\n    }\r\n}\r\n\r\nlet last_t: u64 = 0;\r\n\r\nfunction Physics(t: u64): void {\r\n    let dt: i32 = i32(t - last_t);\r\n\r\n    const step: i32 = 40;\r\n\r\n    while (dt >= step) {\r\n        SimulationStep(f32(step) * 0.25, last_t);\r\n        dt -= step;\r\n        last_t += step;\r\n    }\r\n\r\n    if (dt > 0) {\r\n        SimulationStep(f32(dt) * 0.25, last_t);\r\n        last_t += dt;\r\n    }\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Position Update\r\n\r\nlet last_position_send: u64 = 0;\r\nlet last_ax: f32 = 0.0;\r\nlet last_ay: f32 = 0.0;\r\n\r\nfunction SendPosition(t: u64): void {\r\n    if (temp_self == null) {\r\n        return;\r\n    }\r\n\r\n    let dt: i64 = i64(t - last_position_send);\r\n    if (dt < 100 * 4) {\r\n        return;\r\n    }\r\n\r\n    if (dt < 200 * 4) {\r\n        if (Mathf.abs(temp_self!.ax - last_ax) < 0.3 &&\r\n            Mathf.abs(temp_self!.ay - last_ay) < 0.3) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    last_position_send = t;\r\n    last_ax = temp_self!.ax;\r\n    last_ay = temp_self!.ay;\r\n\r\n    let buffer: Uint8Array = new Uint8Array(14);\r\n    let ptr: usize = buffer.dataStart;\r\n\r\n    store<u8>(ptr, Netcode.UnreliableType.ClientPosition, 0);\r\n\r\n    let remote_ts: u32 = TimeSync.LocalToPeerTime_ToTS23(t);\r\n    Netcode.Store24(ptr, 1, remote_ts);\r\n\r\n    store<u16>(ptr, Netcode.ConvertXto16(temp_self!.x), 4);\r\n    store<u16>(ptr, Netcode.ConvertXto16(temp_self!.y), 6);\r\n    store<i16>(ptr, Netcode.ConvertVXto16(temp_self!.vx), 8);\r\n    store<i16>(ptr, Netcode.ConvertVXto16(temp_self!.vy), 10);\r\n    store<u16>(ptr, Netcode.ConvertAccelto16(temp_self!.ax, temp_self!.ay), 12);\r\n\r\n    sendUnreliable(buffer);\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// Render\r\n\r\nlet hack_last_bullet_fire: u64 = 0;\r\nlet hack_bomb_counter: i32 = 0;\r\n\r\nexport function RenderFrame(\r\n    now_msec: f64,\r\n    finger_x: i32, finger_y: i32,\r\n    canvas_w: i32, canvas_h: i32): void\r\n{\r\n    RenderContext.I.UpdateViewport(canvas_w, canvas_h);\r\n    RenderContext.I.Clear();\r\n\r\n    // Convert timestamp to integer with 1/4 msec (desired) precision\r\n    let t: u64 = TimeConverter.MsecToTime(now_msec);\r\n\r\n    let fx: f32 = f32(finger_x) / f32(canvas_w) * 2.0 - 1.0;\r\n    let fy: f32 = f32(finger_y) / f32(canvas_h) * 2.0 - 1.0;\r\n\r\n    let pointer_active: bool = IsObjectOnScreen(fx, fy);\r\n\r\n    player_list = player_map.values();\r\n\r\n    temp_self = null;\r\n    if (SelfId != -1 && player_map.has(u8(SelfId))) {\r\n        temp_self = player_map.get(u8(SelfId));\r\n    }\r\n    if (temp_self != null) {\r\n        temp_self!.ax = 0;\r\n        temp_self!.ay = 0;\r\n\r\n        if (pointer_active) {\r\n            const mag: f32 = Mathf.sqrt(fx * fx + fy * fy);\r\n            const dead_zone: f32 = 0.1;\r\n            if (mag > dead_zone) {\r\n                const accel: f32 = 0.001;\r\n                temp_self!.ax = f32(fx) * accel / mag;\r\n                temp_self!.ay = f32(fy) * accel / mag;\r\n            }\r\n        }\r\n\r\n        temp_self!.is_self = true;\r\n    }\r\n\r\n    Physics(t);\r\n\r\n    SendPosition(t);\r\n\r\n    let sx: f32 = 0, sy: f32 = 0;\r\n    if (temp_self != null) {\r\n        sx = temp_self!.x;\r\n        sy = temp_self!.y;\r\n\r\n        const weapon_dt = i64(t - hack_last_bullet_fire);\r\n        if (weapon_dt > 500 * 4) {\r\n            let vx = temp_self!.vx;\r\n            let vy = temp_self!.vy;\r\n\r\n            if (vx == 0.0 && vy == 0.0) {\r\n            } else {\r\n                const bullet_speed: f32 = 0.5;\r\n\r\n                const mag: f32 = Mathf.sqrt(vx * vx + vy * vy);\r\n                const vfactor = bullet_speed / mag;\r\n                vx *= vfactor;\r\n                vy *= vfactor;\r\n\r\n                if (hack_bomb_counter == 0) {\r\n                    const bomb = new BombWeapon;\r\n                    bomb.vx = temp_self!.vx + vx;\r\n                    bomb.vy = temp_self!.vy + vy;\r\n                    bomb.x = temp_self!.x;\r\n                    bomb.y = temp_self!.y;\r\n                    bomb.t = t;\r\n                    bomb.team = temp_self!.team;\r\n                    bomb.angle0 = Mathf.random() * 3.14159 * 2.0;\r\n                    BombList.push(bomb);\r\n                } else {\r\n                    const bullet = new BulletWeapon;\r\n                    bullet.vx = temp_self!.vx + vx;\r\n                    bullet.vy = temp_self!.vy + vy;\r\n                    bullet.x = temp_self!.x;\r\n                    bullet.y = temp_self!.y;\r\n                    bullet.t = t;\r\n                    bullet.team = temp_self!.team;\r\n                    bullet.angle0 = Mathf.random() * 3.14159 * 2.0;\r\n                    BulletList.push(bullet);\r\n                }\r\n\r\n                hack_bomb_counter++;\r\n                if (hack_bomb_counter >= 4) {\r\n                    hack_bomb_counter = 0;\r\n                }\r\n            }\r\n\r\n            hack_last_bullet_fire = t;\r\n        }\r\n    }\r\n\r\n    const origin_x = ObjectToScreen(0.0, sx);\r\n    const origin_y = ObjectToScreen(0.0, sy);\r\n    map_prog.DrawMap(-origin_x, -origin_y, 1.0, t);\r\n\r\n    RenderPlayers(t, sx, sy);\r\n    RenderBombs(t, sx, sy);\r\n    RenderBullets(t, sx, sy);\r\n\r\n    const sun_radius: f32 = 1.4;\r\n    if (IsObjectOnScreen(origin_x, origin_y, sun_radius)) {\r\n        sun_prog.DrawSun(origin_x, origin_y, sun_radius, t);\r\n    }\r\n\r\n    RenderArrows(t, sx, sy);\r\n\r\n    if (pointer_active) {\r\n        string_prog.DrawString(\r\n            kStringColor,\r\n            fx,\r\n            fy,\r\n            0.0, 0.0,\r\n            t);\r\n    }\r\n\r\n    RenderContext.I.Flush();\r\n\r\n    if (temp_self != null) {\r\n        temp_self!.is_self = false;\r\n    }\r\n\r\n    UpdateMusic(t, sx, sy);\r\n\r\n    // Collect GC after render tasks are done\r\n    __collect();\r\n}\r\n","export class RenderColor {\r\n    r: f32\r\n    g: f32\r\n    b: f32\r\n\r\n    constructor(r: f32 = 0.0, g: f32 = 0.0, b: f32 = 0.0) {\r\n        this.r = r;\r\n        this.g = g;\r\n        this.b = b;\r\n    }\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (value === null) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","export function HASH<T>(key: T): u32 {\n  if (isString<T>()) {\n    return hashStr(changetype<string>(key));\n  } else if (isReference<T>()) {\n    if (sizeof<T>() == 4) return hash32(changetype<u32>(key));\n    if (sizeof<T>() == 8) return hash64(changetype<u64>(key));\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) return hash32(reinterpret<u32>(f32(key)));\n    if (sizeof<T>() == 8) return hash64(reinterpret<u64>(f64(key)));\n  } else {\n    if (sizeof<T>() <= 4) return hash32(u32(key), sizeof<T>());\n    if (sizeof<T>() == 8) return hash64(u64(key));\n  }\n  return unreachable();\n}\n\n// XXHash 32-bit as a starting point, see: https://cyan4973.github.io/xxHash\n\n// primes\n// @ts-ignore: decorator\n@inline const XXH32_P1: u32 = 2654435761;\n// @ts-ignore: decorator\n@inline const XXH32_P2: u32 = 2246822519;\n// @ts-ignore: decorator\n@inline const XXH32_P3: u32 = 3266489917;\n// @ts-ignore: decorator\n@inline const XXH32_P4: u32 = 668265263;\n// @ts-ignore: decorator\n@inline const XXH32_P5: u32 = 374761393;\n// @ts-ignore: decorator\n@inline const XXH32_SEED: u32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction hash32(key: u32, len: u32 = 4): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + len;\n  h += key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hash64(key: u64): u32 {\n  var h: u32 = XXH32_SEED + XXH32_P5 + 8;\n  h += <u32>key * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h += <u32>(key >> 32) * XXH32_P3;\n  h  = rotl(h, 17) * XXH32_P4;\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction mix(h: u32, key: u32): u32 {\n  return rotl(h + key * XXH32_P2, 13) * XXH32_P1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction hashStr(key: string): u32 {\n  if (key === null) return XXH32_SEED;\n\n  var h: u32 = key.length << 1;\n  var len: usize = h;\n  var pos = changetype<usize>(key);\n\n  if (len >= 16) {\n    let s1 = XXH32_SEED + XXH32_P1 + XXH32_P2;\n    let s2 = XXH32_SEED + XXH32_P2;\n    let s3 = XXH32_SEED;\n    let s4 = XXH32_SEED - XXH32_P1;\n\n    let end = len + pos - 16;\n    while (pos <= end) {\n      s1 = mix(s1, load<u32>(pos    ));\n      s2 = mix(s2, load<u32>(pos,  4));\n      s3 = mix(s3, load<u32>(pos,  8));\n      s4 = mix(s4, load<u32>(pos, 12));\n      pos += 16;\n    }\n    h += rotl(s1, 1) + rotl(s2, 7) + rotl(s3, 12) + rotl(s4, 18);\n  } else {\n    h += XXH32_SEED + XXH32_P5;\n  }\n\n  var end = changetype<usize>(key) + len - 4;\n  while (pos <= end) {\n    h += load<u32>(pos) * XXH32_P3;\n    h = rotl(h, 17) * XXH32_P4;\n    pos += 4;\n  }\n\n  end = changetype<usize>(key) + len;\n  while (pos < end) {\n    h += <u32>load<u8>(pos) * XXH32_P5;\n    h = rotl(h, 11) * XXH32_P1;\n    pos++;\n  }\n\n  h ^= h >> 15;\n  h *= XXH32_P2;\n  h ^= h >> 13;\n  h *= XXH32_P3;\n  h ^= h >> 16;\n  return h;\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { HASH } from \"./util/hash\";\nimport { E_KEYNOTFOUND } from \"./util/error\";\n\n// A deterministic hash map based on CloseTable from https://github.com/jorendorff/dht\n\n// @ts-ignore: decorator\n@inline const INITIAL_CAPACITY = 4;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_N = 8;\n\n// @ts-ignore: decorator\n@inline const FILL_FACTOR_D = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_N = 3;\n\n// @ts-ignore: decorator\n@inline const FREE_FACTOR_D = 4;\n\n/** Structure of a map entry. */\n@unmanaged class MapEntry<K,V> {\n  key: K;\n  value: V;\n  taggedNext: usize; // LSB=1 indicates EMPTY\n}\n\n/** Empty bit. */\n// @ts-ignore: decorator\n@inline const EMPTY: usize = 1 << 0;\n\n/** Size of a bucket. */\n// @ts-ignore: decorator\n@inline const BUCKET_SIZE = sizeof<usize>();\n\n/** Computes the alignment of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_ALIGN<K,V>(): usize {\n  // can align to 4 instead of 8 if 32-bit and K/V is <= 32-bits\n  const maxkv = sizeof<K>() > sizeof<V>() ? sizeof<K>() : sizeof<V>();\n  const align = (maxkv > sizeof<usize>() ? maxkv : sizeof<usize>()) - 1;\n  return align;\n}\n\n/** Computes the aligned size of an entry. */\n// @ts-ignore: decorator\n@inline\nfunction ENTRY_SIZE<K,V>(): usize {\n  const align = ENTRY_ALIGN<K,V>();\n  const size = (offsetof<MapEntry<K,V>>() + align) & ~align;\n  return size;\n}\n\nexport class Map<K,V> {\n\n  // buckets referencing their respective first entry, usize[bucketsMask + 1]\n  private buckets: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n  private bucketsMask: u32 = INITIAL_CAPACITY - 1;\n\n  // entries in insertion order, MapEntry<K,V>[entriesCapacity]\n  private entries: ArrayBuffer = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n  private entriesCapacity: i32 = INITIAL_CAPACITY;\n  private entriesOffset: i32 = 0;\n  private entriesCount: i32 = 0;\n\n  constructor() {\n    /* nop */\n  }\n\n  get size(): i32 {\n    return this.entriesCount;\n  }\n\n  clear(): void {\n    this.buckets = new ArrayBuffer(INITIAL_CAPACITY * <i32>BUCKET_SIZE);\n    this.bucketsMask = INITIAL_CAPACITY - 1;\n    this.entries = new ArrayBuffer(INITIAL_CAPACITY * <i32>ENTRY_SIZE<K,V>());\n    this.entriesCapacity = INITIAL_CAPACITY;\n    this.entriesOffset = 0;\n    this.entriesCount = 0;\n  }\n\n  private find(key: K, hashCode: u32): MapEntry<K,V> | null {\n    var entry = load<MapEntry<K,V>>( // unmanaged!\n      changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE\n    );\n    while (entry) {\n      let taggedNext = entry.taggedNext;\n      if (!(taggedNext & EMPTY) && entry.key == key) return entry;\n      entry = changetype<MapEntry<K,V>>(taggedNext & ~EMPTY);\n    }\n    return null;\n  }\n\n  has(key: K): bool {\n    return this.find(key, HASH<K>(key)) !== null;\n  }\n\n  @operator(\"[]\")\n  get(key: K): V {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) throw new Error(E_KEYNOTFOUND); // cannot represent `undefined`\n    return entry.value;\n  }\n\n  @operator(\"[]=\")\n  set(key: K, value: V): this {\n    var hashCode = HASH<K>(key);\n    var entry = this.find(key, hashCode); // unmanaged!\n    if (entry) {\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n    } else {\n      // check if rehashing is necessary\n      if (this.entriesOffset == this.entriesCapacity) {\n        this.rehash(\n          this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n            ?  this.bucketsMask           // just rehash if 1/4+ entries are empty\n            : (this.bucketsMask << 1) | 1 // grow capacity to next 2^N\n        );\n      }\n      // append new entry\n      let entries = this.entries;\n      entry = changetype<MapEntry<K,V>>(changetype<usize>(entries) + <usize>(this.entriesOffset++) * ENTRY_SIZE<K,V>());\n      // link with the map\n      entry.key = key;\n      if (isManaged<K>()) {\n        __link(changetype<usize>(this), changetype<usize>(key), true);\n      }\n      entry.value = value;\n      if (isManaged<V>()) {\n        __link(changetype<usize>(this), changetype<usize>(value), true);\n      }\n      ++this.entriesCount;\n      // link with previous entry in bucket\n      let bucketPtrBase = changetype<usize>(this.buckets) + <usize>(hashCode & this.bucketsMask) * BUCKET_SIZE;\n      entry.taggedNext = load<usize>(bucketPtrBase);\n      store<usize>(bucketPtrBase, changetype<usize>(entry));\n    }\n    return this;\n  }\n\n  delete(key: K): bool {\n    var entry = this.find(key, HASH<K>(key));\n    if (!entry) return false;\n    entry.taggedNext |= EMPTY;\n    --this.entriesCount;\n    // check if rehashing is appropriate\n    var halfBucketsMask = this.bucketsMask >> 1;\n    if (\n      halfBucketsMask + 1 >= max<u32>(INITIAL_CAPACITY, this.entriesCount) &&\n      this.entriesCount < this.entriesCapacity * FREE_FACTOR_N / FREE_FACTOR_D\n    ) this.rehash(halfBucketsMask);\n    return true;\n  }\n\n  private rehash(newBucketsMask: u32): void {\n    var newBucketsCapacity = <i32>(newBucketsMask + 1);\n    var newBuckets = new ArrayBuffer(newBucketsCapacity * <i32>BUCKET_SIZE);\n    var newEntriesCapacity = newBucketsCapacity * FILL_FACTOR_N / FILL_FACTOR_D;\n    var newEntries = new ArrayBuffer(newEntriesCapacity * <i32>ENTRY_SIZE<K,V>());\n\n    // copy old entries to new entries\n    var oldPtr = changetype<usize>(this.entries);\n    var oldEnd = oldPtr + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n    var newPtr = changetype<usize>(newEntries);\n    while (oldPtr != oldEnd) {\n      let oldEntry = changetype<MapEntry<K,V>>(oldPtr);\n      if (!(oldEntry.taggedNext & EMPTY)) {\n        let newEntry = changetype<MapEntry<K,V>>(newPtr);\n        let oldEntryKey = oldEntry.key;\n        newEntry.key = oldEntryKey;\n        newEntry.value = oldEntry.value;\n        let newBucketIndex = HASH<K>(oldEntryKey) & newBucketsMask;\n        let newBucketPtrBase = changetype<usize>(newBuckets) + <usize>newBucketIndex * BUCKET_SIZE;\n        newEntry.taggedNext = load<usize>(newBucketPtrBase);\n        store<usize>(newBucketPtrBase, newPtr);\n        newPtr += ENTRY_SIZE<K,V>();\n      }\n      oldPtr += ENTRY_SIZE<K,V>();\n    }\n\n    this.buckets = newBuckets;\n    this.bucketsMask = newBucketsMask;\n    this.entries = newEntries;\n    this.entriesCapacity = newEntriesCapacity;\n    this.entriesOffset = this.entriesCount;\n  }\n\n  keys(): K[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var keys = new Array<K>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        keys[length++] = entry.key;\n      }\n    }\n    keys.length = length;\n    return keys;\n  }\n\n  values(): V[] {\n    // FIXME: this is preliminary, needs iterators/closures\n    var start = changetype<usize>(this.entries);\n    var size = this.entriesOffset;\n    var values = new Array<V>(size);\n    var length = 0;\n    for (let i = 0; i < size; ++i) {\n      let entry = changetype<MapEntry<K,V>>(start + <usize>i * ENTRY_SIZE<K,V>());\n      if (!(entry.taggedNext & EMPTY)) {\n        values[length++] = entry.value;\n      }\n    }\n    values.length = length;\n    return values;\n  }\n\n  toString(): string {\n    return \"[object Map]\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    __visit(changetype<usize>(this.buckets), cookie);\n    var entries = changetype<usize>(this.entries);\n    if (isManaged<K>() || isManaged<V>()) {\n      let cur = entries;\n      let end = cur + <usize>this.entriesOffset * ENTRY_SIZE<K,V>();\n      while (cur < end) {\n        let entry = changetype<MapEntry<K,V>>(cur);\n        if (!(entry.taggedNext & EMPTY)) {\n          if (isManaged<K>()) {\n            let val = changetype<usize>(entry.key);\n            if (isNullable<K>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n          if (isManaged<V>()) {\n            let val = changetype<usize>(entry.value);\n            if (isNullable<V>()) {\n              if (val) __visit(val, cookie);\n            } else __visit(val, cookie);\n          }\n        }\n        cur += ENTRY_SIZE<K,V>();\n      }\n    }\n    __visit(entries, cookie);\n  }\n}\n","import { COMPARATOR, SORT as SORT_IMPL } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_NOTIMPLEMENTED } from \"./util/error\";\nimport { joinIntegerArray, joinFloatArray } from \"./util/string\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): i8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    return SORT<Int8Array, i8>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SLICE<Int8Array, i8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int8Array {\n    return COPY_WITHIN<Int8Array, i8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  filter(fn: (value: i8, index: i32, self: Int8Array) => bool): Int8Array {\n    return FILTER<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i8>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i8>(this.dataStart, this.length, separator);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int8Array, i8, U, valueof<U>>(this, source, offset);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  at(index: i32): u8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    return SORT<Uint8Array, u8>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SLICE<Uint8Array, u8>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return COPY_WITHIN<Uint8Array, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8Array) => bool): Uint8Array {\n    return FILTER<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8Array, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.byteLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  at(index: i32): u8 {\n    var len = this.byteLength;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\n  }\n\n  sort(fn: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    return SORT<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SLICE<Uint8ClampedArray, u8>(this, begin, end);\n  }\n\n  subarray(start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return COPY_WITHIN<Uint8ClampedArray, u8>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  filter(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): Uint8ClampedArray {\n    return FILTER<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u8>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint8ClampedArray, u8, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  at(index: i32): i16 {\n    var len = this.byteLength >>> alignof<i16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    return SORT<Int16Array, i16>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SLICE<Int16Array, i16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int16Array {\n    return COPY_WITHIN<Int16Array, i16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  filter(fn: (value: i16, index: i32, self: Int16Array) => bool): Int16Array {\n    return FILTER<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i16>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int16Array, i16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  at(index: i32): u16 {\n    var len = this.byteLength >>> alignof<u16>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    return SORT<Uint16Array, u16>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SLICE<Uint16Array, u16>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return COPY_WITHIN<Uint16Array, u16>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  filter(fn: (value: u16, index: i32, self: Uint16Array) => bool): Uint16Array {\n    return FILTER<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u16>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u16>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint16Array, u16, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  at(index: i32): i32 {\n    var len = this.byteLength >>> alignof<i32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    return SORT<Int32Array, i32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SLICE<Int32Array, i32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int32Array {\n    return COPY_WITHIN<Int32Array, i32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  filter(fn: (value: i32, index: i32, self: Int32Array) => bool): Int32Array {\n    return FILTER<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i32>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int32Array, i32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  at(index: i32): u32 {\n    var len = this.byteLength >>> alignof<u32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    return SORT<Uint32Array, u32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SLICE<Uint32Array, u32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return COPY_WITHIN<Uint32Array, u32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  filter(fn: (value: u32, index: i32, self: Uint32Array) => bool): Uint32Array {\n    return FILTER<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u32>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint32Array, u32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  at(index: i32): i64 {\n    var len = this.byteLength >>> alignof<i64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    return SORT<Int64Array, i64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SLICE<Int64Array, i64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Int64Array {\n    return COPY_WITHIN<Int64Array, i64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  filter(fn: (value: i64, index: i32, self: Int64Array) => bool): Int64Array {\n    return FILTER<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i64>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<i64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Int64Array, i64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  at(index: i32): u64 {\n    var len = this.byteLength >>> alignof<u64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    return SORT<Uint64Array, u64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SLICE<Uint64Array, u64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return COPY_WITHIN<Uint64Array, u64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  filter(fn: (value: u64, index: i32, self: Uint64Array) => bool): Uint64Array {\n    return FILTER<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u64>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinIntegerArray<u64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Uint64Array, u64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  at(index: i32): f32 {\n    var len = this.byteLength >>> alignof<f32>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    return SORT<Float32Array, f32>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SLICE<Float32Array, f32>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float32Array {\n    return COPY_WITHIN<Float32Array, f32>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  filter(fn: (value: f32, index: i32, self: Float32Array) => bool): Float32Array {\n    return FILTER<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f32>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f32>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float32Array, f32, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: i32 = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.byteLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  at(index: i32): f64 {\n    var len = this.byteLength >>> alignof<f64>();\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    return SORT<Float64Array, f64>(this, comparator);\n  }\n\n  slice(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SLICE<Float64Array, f64>(this, begin, end);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Float64Array {\n    return COPY_WITHIN<Float64Array, f64>(this, target, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  filter(fn: (value: f64, index: i32, self: Float64Array) => bool): Float64Array {\n    return FILTER<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f64>(this);\n  }\n\n  join(separator: string = \",\"): string {\n    return joinFloatArray<f64>(this.dataStart, this.length, separator);\n  }\n\n  set<U extends ArrayBufferView>(source: U, offset: i32 = 0): void {\n    SET<Float64Array, f64, U, valueof<U>>(this, source, offset);\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var dataStart = array.dataStart;\n  var len = array.length;\n  start = start < 0 ? max(len + start, 0) : min(start, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  if (sizeof<T>() == 1) {\n    if (start < end) memory.fill(dataStart + <usize>start, <u8>value, <usize>(end - start));\n  } else {\n    for (; start < end; ++start) {\n      store<T>(dataStart + (<usize>start << alignof<T>()), value);\n    }\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SORT<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var len = array.length;\n  if (len <= 1) return array;\n  var base = array.dataStart;\n  if (len == 2) {\n    let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n    let b: T = load<T>(base); // b = arr[0]\n    if (comparator(a, b) < 0) {\n      store<T>(base, b, sizeof<T>()); // arr[1] = b\n      store<T>(base, a); // arr[0] = a\n    }\n    return array;\n  }\n  SORT_IMPL<T>(base, len, comparator);\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SLICE<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  start  = start < 0 ? max(start + len, 0) : min(start, len);\n  end    = end   < 0 ? max(end   + len, 0) : min(end  , len);\n  len = max(end - start, 0);\n  var slice = instantiate<TArray>(len);\n  memory.copy(\n    slice.dataStart,\n    array.dataStart + (<usize>start << alignof<T>()),\n    <usize>len << alignof<T>()\n  );\n  return slice;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<usize>(array.buffer);\n  store<usize>(changetype<usize>(out), buf, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), buf, false);\n  store<usize>(changetype<usize>(out), array.dataStart + (<usize>begin << alignof<T>()), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), (end - begin) << alignof<T>(), offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction COPY_WITHIN<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  target: i32,\n  start: i32,\n  end: i32\n): TArray {\n  var len = array.length;\n  var dataStart = array.dataStart;\n\n  end   = min<i32>(end, len);\n  var to    = target < 0 ? max(len + target, 0) : min(target, len);\n  var from  = start < 0 ? max(len + start, 0) : min(start, len);\n  var last  = end < 0 ? max(len + end, 0) : min(end, len);\n  var count = min(last - from, len - to);\n\n  memory.copy(\n    dataStart + (<usize>to << alignof<T>()),\n    dataStart + (<usize>from << alignof<T>()),\n    <usize>count << alignof<T>()\n  );\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var len = array.length;\n  var dataStart = array.dataStart;\n\n  var byteLength = len << alignof<T>();\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n  for (let i = 0; i < len; i++) {\n    store<T>(\n      changetype<usize>(buf) + (<usize>i << alignof<T>()),\n      fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buf), false);\n  store<usize>(changetype<usize>(out), changetype<usize>(buf), offsetof<TArray>(\"dataStart\"));\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILTER<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => bool,\n): TArray {\n  var len = array.length;\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  var buf = changetype<ArrayBuffer>(__new(len << alignof<T>(), idof<ArrayBuffer>()));\n  var dataStart  = array.dataStart;\n  var j: usize = 0;\n  for (let i = 0; i < len; i++) {\n    let value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    if (fn(value, i, array)) {\n      store<T>(\n        changetype<usize>(buf) + (j++ << alignof<T>()),\n        value\n      );\n    }\n  }\n  // shrink output buffer\n  var byteLength = j << alignof<T>();\n  var data = __renew(changetype<usize>(buf), byteLength);\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), data, false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), data, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  if (isFloat<T>()) {\n    let index: isize = fromIndex;\n    let length: isize = array.length;\n    if (length == 0 || index >= length) return false;\n    if (index < 0) index = max(length + index, 0);\n    let dataStart = array.dataStart;\n    while (index < length) {\n      let elem = load<T>(dataStart + (index << alignof<T>()));\n      // @ts-ignore\n      if (elem == searchElement || isNaN(elem) & isNaN(searchElement)) return true;\n      ++index;\n    }\n    return false;\n  } else {\n    return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0 || index >= length) return -1;\n  if (index < 0) index = max(length + index, 0);\n  var dataStart = array.dataStart;\n  while (index < length) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0) return -1;\n  if (index < 0) index = length + index; // no need to clamp\n  else if (index >= length) index = length - 1;\n  var dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REVERSE<TArray extends ArrayBufferView, T>(array: TArray): TArray {\n  var dataStart = array.dataStart;\n  for (let front: usize = 0, back: usize = array.length - 1; front < back; ++front, --back) {\n    let frontPtr = dataStart + (front << alignof<T>());\n    let backPtr = dataStart + (back << alignof<T>());\n    let temp = load<T>(frontPtr);\n    store<T>(frontPtr, load<T>(backPtr));\n    store<T>(backPtr, temp);\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(\n  buffer: ArrayBuffer,\n  byteOffset: i32 = 0,\n  length: i32 = -1\n): TArray {\n  var byteLength: i32;\n  var bufferByteLength = buffer.byteLength;\n  const mask: u32 = sizeof<T>() - 1;\n  if (i32(<u32>byteOffset > <u32>bufferByteLength) | (byteOffset & mask)) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  if (length < 0) {\n    if (length == -1) {\n      if (bufferByteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      }\n      byteLength = bufferByteLength - byteOffset;\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = length << alignof<T>();\n    if (byteOffset + byteLength > bufferByteLength) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  }\n  var out = changetype<TArray>(__new(offsetof<TArray>(), idof<TArray>()));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer), offsetof<TArray>(\"buffer\"));\n  __link(changetype<usize>(out), changetype<usize>(buffer), false);\n  store<u32>(changetype<usize>(out), byteLength, offsetof<TArray>(\"byteLength\"));\n  store<usize>(changetype<usize>(out), changetype<usize>(buffer) + <usize>byteOffset, offsetof<TArray>(\"dataStart\"));\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SET<TArray extends ArrayBufferView, T, UArray extends ArrayBufferView, U>(\n  target: TArray,\n  source: UArray,\n  offset: i32 = 0\n): void {\n  // need to assert at compile time that U is not a reference or a function\n  if (isReference<U>()) {\n    ERROR(E_NOTIMPLEMENTED);\n  }\n\n  // Uncaught RangeError: offset is out of bounds\n  if (offset < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n  if (source.length + offset > target.length) throw new RangeError(E_INDEXOUTOFRANGE);\n\n  // if the types align and match, use memory.copy() instead of manual loop\n  if (isInteger<T>() == isInteger<U>() && alignof<T>() == alignof<U>() &&\n    !(target instanceof Uint8ClampedArray && isSigned<U>())) {\n    memory.copy(\n      target.dataStart + (<usize>offset << alignof<T>()),\n      source.dataStart,\n      source.byteLength\n    );\n  } else {\n    let targetDataStart = target.dataStart + (<usize>offset << alignof<T>());\n    let sourceDataStart = source.dataStart;\n    let count = source.length;\n    for (let i = 0; i < count; i++) {\n      // if TArray is Uint8ClampedArray, then values must be clamped\n      if (target instanceof Uint8ClampedArray) {\n        if (isFloat<U>()) {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          store<T>(\n            targetDataStart + (<usize>i << alignof<T>()),\n            isFinite<U>(value) ? <T>max<U>(0, min<U>(255, value)) : <T>0\n          );\n        } else {\n          let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n          if (!isSigned<U>()) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              min<U>(255, value)\n            );\n          } else if (sizeof<T>() <= 4) {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i32>value >> 31) & (((255 - <i32>value) >> 31) | value)\n            );\n          } else {\n            store<T>(\n              targetDataStart + (<usize>i << alignof<T>()),\n              // @ts-ignore: cast to T is valid for numeric types here\n              ~(<i64>value >> 63) & (((255 - <i64>value) >> 63) | value)\n            );\n          }\n        }\n        // if U is a float, then casting float to int must include a finite check\n      } else if (isFloat<U>() && !isFloat<T>()) {\n        let value = load<U>(sourceDataStart + (<usize>i << alignof<U>()));\n        // @ts-ignore: cast to T is valid for numeric types here\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), isFinite<U>(value) ? <T>value : 0);\n      } else if (isFloat<T>() && !isFloat<U>()) {\n        // @ts-ignore: In this case the <T> conversion is required\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), <T>load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      } else {\n        store<T>(targetDataStart + (<usize>i << alignof<T>()), load<U>(sourceDataStart + (<usize>i << alignof<U>())));\n      }\n    }\n  }\n}\n","import { compareImpl } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): (a: T, b: T) => i32 {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a: T, b: T): i32 => (i32(a) - i32(b));\n    } else {\n      return (a: T, b: T): i32 => (i32(a > b) - i32(a < b));\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a: T, b: T): i32 => {\n        var ia = reinterpret<i32>(f32(a));\n        var ib = reinterpret<i32>(f32(b));\n        ia ^= (ia >> 31) >>> 1;\n        ib ^= (ib >> 31) >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a: T, b: T): i32 => {\n        var ia = reinterpret<i64>(f64(a));\n        var ib = reinterpret<i64>(f64(b));\n        ia ^= (ia >> 63) >>> 1;\n        ib ^= (ib >> 63) >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a: T, b: T): i32 => {\n      if (a === b || a === null || b === null) return 0;\n      var alen = changetype<string>(a).length;\n      var blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(changetype<string>(a), 0, changetype<string>(b), 0, <usize>min(alen, blen));\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a: T, b: T): i32 => (i32(a > b) - i32(a < b));\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function SORT<T>(\n  dataStart: usize,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  if (isReference<T>()) {\n    // TODO replace this to faster stable sort (TimSort) when it implemented\n    insertionSort<T>(dataStart, length, comparator);\n  } else {\n    if (length < 256) {\n      insertionSort<T>(dataStart, length, comparator);\n    } else {\n      weakHeapSort<T>(dataStart, length, comparator);\n    }\n  }\n}\n\nfunction insertionSort<T>(\n  dataStart: usize,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  for (let i = 0; i < length; i++) {\n    let a: T = load<T>(dataStart + (<usize>i << alignof<T>())); // a = arr[i]\n    let j = i - 1;\n    while (j >= 0) {\n      let b: T = load<T>(dataStart + (<usize>j << alignof<T>())); // b = arr[j]\n      if (comparator(a, b) < 0) {\n        store<T>(dataStart + (<usize>(j-- + 1) << alignof<T>()), b); // arr[j + 1] = b\n      } else break;\n    }\n    store<T>(dataStart + (<usize>(j + 1) << alignof<T>()), a); // arr[j + 1] = a\n  }\n}\n\nfunction weakHeapSort<T>(\n  dataStart: usize,\n  length: i32,\n  comparator: (a: T, b: T) => i32\n): void {\n  const shift32 = alignof<u32>();\n\n  var bitsetSize = (<usize>length + 31) >> 5 << shift32;\n  var bitset = __alloc(bitsetSize); // indexed in 32-bit chunks below\n  memory.fill(bitset, 0, bitsetSize);\n\n  // see: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.21.1863&rep=rep1&type=pdf\n\n  for (let i = length - 1; i > 0; i--) {\n    let j = i;\n    while ((j & 1) == (load<u32>(bitset + (<usize>j >> 6 << shift32)) >> (j >> 1 & 31) & 1)) j >>= 1;\n\n    let p = j >> 1;\n    let a: T = load<T>(dataStart + (<usize>p << alignof<T>())); // a = arr[p]\n    let b: T = load<T>(dataStart + (<usize>i << alignof<T>())); // b = arr[i]\n    if (comparator(a, b) < 0) {\n      store<u32>(\n        bitset + (<usize>i >> 5 << shift32),\n        load<u32>(bitset + (<usize>i >> 5 << shift32)) ^ (1 << (i & 31))\n      );\n      store<T>(dataStart + (<usize>i << alignof<T>()), a); // arr[i] = a\n      store<T>(dataStart + (<usize>p << alignof<T>()), b); // arr[p] = b\n    }\n  }\n\n  for (let i = length - 1; i >= 2; i--) {\n    let a: T = load<T>(dataStart); // a = arr[0]\n    store<T>(dataStart, load<T>(dataStart + (<usize>i << alignof<T>()))); // arr[0] = arr[i]\n    store<T>(dataStart + (<usize>i << alignof<T>()), a); // arr[i] = a\n\n    let x = 1, y: i32;\n    while ((y = (x << 1) + ((load<u32>(bitset + (<usize>x >> 5 << shift32)) >> (x & 31)) & 1)) < i) x = y;\n\n    while (x > 0) {\n      a = load<T>(dataStart); // a = arr[0]\n      let b: T = load<T>(dataStart + (<usize>x << alignof<T>())); // b = arr[x]\n\n      if (comparator(a, b) < 0) {\n        store<u32>(\n          bitset + (<usize>x >> 5 << shift32),\n          load<u32>(bitset + (<usize>x >> 5 << shift32)) ^ (1 << (x & 31))\n        );\n        store<T>(dataStart + (<usize>x << alignof<T>()), a); // arr[x] = a\n        store<T>(dataStart, b); // arr[0] = b\n      }\n      x >>= 1;\n    }\n  }\n\n  __free(bitset);\n\n  var t: T = load<T>(dataStart, sizeof<T>()); // t = arr[1]\n  store<T>(dataStart, load<T>(dataStart), sizeof<T>()); // arr[1] = arr[0]\n  store<T>(dataStart, t); // arr[0] = t\n}\n","type auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, s: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return unreachable(); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    var length = source.length;\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    var sourceLen = source.length;\n    var otherLen = select(0, other.length, other === null);\n    var outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<StaticArray<T>>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n    var outStart = changetype<usize>(out);\n    var sourceSize = <usize>sourceLen << alignof<T>();\n    if (isManaged<T>()) {\n      for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(source) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += sourceSize;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(changetype<usize>(other) + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(source), sourceSize);\n      memory.copy(outStart + sourceSize, changetype<usize>(other), <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    var length = source.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var sliceSize = <usize>length << alignof<T>();\n    var slice = changetype<StaticArray<T>>(__new(sliceSize, idof<StaticArray<T>>()));\n    var sourcePtr = changetype<usize>(source) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off: usize = 0;\n      while (off < sliceSize) {\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(slice) + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(changetype<usize>(slice), sourcePtr, sliceSize);\n    }\n    return slice;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var outSize = <usize>length << alignof<T>();\n    var out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    memory.fill(changetype<usize>(out), 0, outSize);\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    var len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    var value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    var length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length;\n    var otherLen = select(0, other.length, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = changetype<usize>(this);\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, changetype<usize>(this), thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n    var sliceBase = slice.dataStart;\n    var thisBase = changetype<usize>(this) + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","import { WebGLRenderingContext } from \"./WebGL\";\r\n\r\nlet gl: WebGLRenderingContext;\r\n\r\nexport class RenderContext {\r\n    public static I: RenderContext;\r\n    public gl!: WebGLRenderingContext;\r\n\r\n    public w: i32 = 0;\r\n    public h: i32 = 0;\r\n\r\n    constructor() {\r\n        if (RenderContext.I == null) {\r\n            RenderContext.I = this;\r\n        }\r\n        gl = this.gl = new WebGLRenderingContext('cnvs', 'webgl2');\r\n\r\n        this.Clear();\r\n\r\n        gl.colorMask(true, true, true, false);\r\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\r\n        gl.enable(gl.BLEND);\r\n        gl.disable(gl.DEPTH_TEST);\r\n    }\r\n\r\n    public UpdateViewport(canvas_w: i32, canvas_h: i32): void {\r\n        if (canvas_w == this.w && canvas_h == this.h) {\r\n            return;\r\n        }\r\n        this.w = canvas_w;\r\n        this.h = canvas_h;\r\n\r\n        gl.viewport(0, 0, canvas_w, canvas_h);\r\n    }\r\n\r\n    public Clear(): void {\r\n        gl.clearColor(0.0, 0.0, 0.0, 1.0);\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n    }\r\n\r\n    public Flush(): void {\r\n        gl.flush();\r\n    }\r\n}\r\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}